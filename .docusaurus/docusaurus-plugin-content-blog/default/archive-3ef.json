{
  "blogPosts": [
    {
      "id": "前端JS沙箱实现的几种方式",
      "metadata": {
        "permalink": "/前端JS沙箱实现的几种方式",
        "source": "@site/blog/前端JS沙箱实现的几种方式.md",
        "title": "前端JS沙箱实现的几种方式",
        "description": "请输入描述",
        "date": "2023-08-28T08:34:33.574Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 9.775,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "前端JS沙箱实现的几种方式",
          "title": "前端JS沙箱实现的几种方式",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "nextItem": {
          "title": "React服务端渲染",
          "permalink": "/React服务端渲染"
        }
      },
      "content": "### 前言\n\n在微前端领域当中，沙箱是很重要的一件事情。像微前端框架`single-spa`没有实现js沙箱，我们在构建大型微前端应用的时候，很容易造成一些变量的冲突，对应用的可靠性面临巨大的风险。在微前端当中，有一些全局对象在所有的应用中需要共享，如`document`,`location`,等对象。子应用开发的过程中可能是多个团队在做，很难约束他们使用全局变量。有些页面可能会有多个不同的子应用，需要我们支持多沙箱，每个沙箱需要有加载，卸载，在恢复的能力。\n\n### `iframe`实现沙箱\n\n在前端中，有一个比较重要的html标签iframe，实际上，我们可以通过iframe对象，把原生浏览器对象通过`contentWindow`取出来，这个对象天然具有所有的属性，而且与主应用的环境隔离。下面我们通过代码看下\n\n```ini\nlet iframe  = document.createElement('iframe',{src:'about:blank'});\ndocument.body.appendChild(iframe);\nconst sandboxGlobal = iframe.contentWindow;\n```\n\n注意：只有同域的ifame才能取出对应的`contentWindow`, iframe的src设置为`about:blank`,可以保证一定是同域的，也不会发生资源加载，参考[iframe src](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#attr-src \"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#attr-src\")\n\n在前言中我们提到，微前端除了有一个隔离的window环境外，其实还需要共享一些全局对象,这时候我们可以用代理去实现。下面我们通过代码看下\n\n```javascript\nclass SandboxWindow {\n    /**\n     * 构造函数\n     * @param {*} context 需要共享的对象\n     * @param {*} frameWindow iframe的window\n     */\n    constructor(context, frameWindow) {\n        \n        return new Proxy(frameWindow, {\n            get(target, name) {\n                if (name in context) { // 优先使用共享对象\n                    return context[name];\n                }\n                return target[name];\n            },\n            set(target, name, value) {\n                if (name in context) { // 修改共享对象的值\n                    return context[name] = value;\n                }\n                target[name] = value;\n            }\n        })\n    }\n}\n\n// 需要全局共享的变量\nconst context = { document:window.document, history: window.history }\n\n// 创建沙箱\nconst newSandboxWindow = new SandboxWindow(context, sandboxGlobal);  \n\n// 判断沙箱上的对象和全局对象是否相等\nconsole.log('equal',newSandboxWindow.document === window.document)\n\nnewSandboxWindow.abc = '1'; //在沙箱上添加属性\nconsole.log(window.abc);   // 在全局上查看属性\nconsole.log(newSandboxWindow.abc) //在沙箱上查看属性\n\n```\n\n我们运行起来，看下结果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e2e37f720f464d8e3115bb39770ab1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n以上我们利用iframe沙箱可以实现以下特性：\n\n+   全局变量隔离，如setTimeout、location、react不同版本隔离\n+   路由隔离，应用可以实现独立路由，也可以共享全局路由\n+   多实例，可以同时存在多个独立的微应用同时运行\n\n### `diff`方式实现沙箱\n\n在不支持代理的浏览器中，我们可以通过diff的方式实习沙箱。在应用运行的时候保存一个快照window对象，将当前window对象的全部属性都复制到快照对象上，子应用卸载的时候将window对象修改做个diff，将不同的属性用个`modifyMap`保存起来，再次挂载的时候再加上这些修改的属性。代码如下：\n\n```javascript\nclass DiffSandbox {\n  constructor(name) {\n    this.name = name;\n    this.modifyMap = {}; // 存放修改的属性\n    this.windowSnapshot = {};\n  }\n  active() {\n    // 缓存active状态的沙箱\n    this.windowSnapshot = {};\n    for (const item in window) {\n      this.windowSnapshot[item] = window[item];\n    }\n\n    Object.keys(this.modifyMap).forEach(p => {\n      window[p] = this.modifyMap[p];\n    })\n\n  }\n\n  inactive() {\n    for (const item in window) {\n      if (this.windowSnapshot[item] !== window[item]) {\n        // 记录变更\n        this.modifyMap[item] = window[item];\n        // 还原window\n        window[item] = this.windowSnapshot[item];\n      }\n    }\n  }\n}\n\nconst diffSandbox = new DiffSandbox('diff沙箱');\ndiffSandbox.active();  // 激活沙箱\nwindow.a = '1'\nconsole.log('开启沙箱：',window.a);\ndiffSandbox.inactive(); //失活沙箱\nconsole.log('失活沙箱：', window.a);\ndiffSandbox.active();   // 重新激活\nconsole.log('再次激活', window.a);\n\n\n```\n\n我们运行一下，查看结果\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/176f4783a1c948ba82cf52f875a859c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n这种方式也无法支持多实例，因为运行期间所有的属性都是保存在window上的。\n\n### 基于代理`(Proxy)`实现单实例沙箱\n\n在ES6当中，我们可以通过代理`(Proxy)`实现对象的劫持。基本实录也是通过window对象的修改进行记录，在卸载时删除这些记录，在应用再次激活时恢复这些记录，来达到模拟沙箱环境的目的。代码如下\n\n```javascript\n// 修改window属性的公共方法\nconst updateWindowProp = (prop, value, isDel) => {\n    if (value === undefined || isDel) {\n        delete window[prop];\n    } else {\n        window[prop] = value;\n    }\n}\n\nclass ProxySandbox {\n\n    active() {\n        // 根据记录还原沙箱\n        this.currentUpdatedPropsValueMap.forEach((v, p) => updateWindowProp(p, v));\n    }\n    inactive() {\n        // 1 将沙箱期间修改的属性还原为原先的属性\n        this.modifiedPropsMap.forEach((v, p) => updateWindowProp(p, v));\n        // 2 将沙箱期间新增的全局变量消除\n        this.addedPropsMap.forEach((_, p) => updateWindowProp(p, undefined, true));\n    }\n\n    constructor(name) {\n        this.name = name;\n        this.proxy = null;\n        // 存放新增的全局变量\n        this.addedPropsMap  = new Map(); \n        // 存放沙箱期间更新的全局变量\n        this.modifiedPropsMap = new Map();\n        // 存在新增和修改的全局变量，在沙箱激活的时候使用\n        this.currentUpdatedPropsValueMap = new Map();\n\n        const { addedPropsMap, currentUpdatedPropsValueMap, modifiedPropsMap } = this;\n        const fakeWindow = Object.create(null);\n        const proxy = new Proxy(fakeWindow, {\n            set(target, prop, value) {\n                if (!window.hasOwnProperty(prop)) {\n                    // 如果window上没有的属性，记录到新增属性里\n                    // debugger;\n                    addedPropsMap.set(prop, value);\n                } else if (!modifiedPropsMap.has(prop)) {\n                    // 如果当前window对象有该属性，且未更新过，则记录该属性在window上的初始值\n                    const originalValue = window[prop];\n                    modifiedPropsMap.set(prop, originalValue);\n                }\n                // 记录修改属性以及修改后的值\n                currentUpdatedPropsValueMap.set(prop, value);\n                // 设置值到全局window上\n                updateWindowProp(prop, value);\n                return true;\n            },\n            get(target, prop) {\n                return window[prop];\n            },\n        });\n        this.proxy = proxy;\n    }\n}\n\n\nconst newSandBox = new ProxySandbox('代理沙箱');\nconst proxyWindow = newSandBox.proxy;\nproxyWindow.a = '1'\nconsole.log('开启沙箱：', proxyWindow.a, window.a);\nnewSandBox.inactive(); //失活沙箱\nconsole.log('失活沙箱：', proxyWindow.a, window.a);\nnewSandBox.active(); //失活沙箱\nconsole.log('重新激活沙箱：', proxyWindow.a, window.a);\n```\n\n我们运行代码，看下结果\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afddf787adbd48f08efafeffdd565870~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n这种方式同一时刻只能有一个激活的沙箱，否则全局对象上的变量会有两个以上的沙箱更新，造成全局变量冲突。\n\n### 基于代理`(Proxy)`实现多实例沙箱\n\n在单实例的场景总，我们的fakeWindow是一个空的对象，其没有任何储存变量的功能，微应用创建的变量最终实际都是挂载在window上的，这就限制了同一时刻不能有两个激活的微应用。\n\n```ini\nclass MultipleProxySandbox {\n\n    active() {\n        this.sandboxRunning = true;\n    }\n    inactive() {\n        this.sandboxRunning = false;\n    }\n\n    /**\n     * 构造函数\n     * @param {*} name 沙箱名称 \n     * @param {*} context 共享的上下文\n     * @returns \n     */\n    constructor(name, context = {}) {\n        this.name = name;\n        this.proxy = null;\n        const fakeWindow = Object.create({});\n        const proxy = new Proxy(fakeWindow, {\n            set: (target, name, value) => {\n                if (this.sandboxRunning) {\n                    if (Object.keys(context).includes(name)) {\n                        context[name] = value;\n                    }\n                    target[name] = value;\n                }\n            },\n            get: (target, name) => {\n                // 优先使用共享对象\n                if (Object.keys(context).includes(name)) {\n                    return context[name];\n                }\n                return target[name];\n            }\n        })\n        this.proxy = proxy;\n    }\n}\n\nconst context = { document: window.document };\n\nconst newSandBox1 = new MultipleProxySandbox('代理沙箱1', context);\nnewSandBox1.active();\nconst proxyWindow1 = newSandBox1.proxy;\n\nconst newSandBox2 = new MultipleProxySandbox('代理沙箱2', context);\nnewSandBox2.active();\nconst proxyWindow2 = newSandBox2.proxy;\nconsole.log('共享对象是否相等', window.document === proxyWindow1.document, window.document ===  proxyWindow2.document);\n\nproxyWindow1.a = '1'; // 设置代理1的值\nproxyWindow2.a = '2'; // 设置代理2的值\nwindow.a = '3';  // 设置window的值\nconsole.log('打印输出的值', proxyWindow1.a, proxyWindow2.a, window.a);\n\n\nnewSandBox1.inactive(); newSandBox2.inactive(); // 两个沙箱都失活\n\nproxyWindow1.a = '4'; // 设置代理1的值\nproxyWindow2.a = '4'; // 设置代理2的值\nwindow.a = '4';  // 设置window的值\nconsole.log('失活后打印输出的值', proxyWindow1.a, proxyWindow2.a, window.a);\n\nnewSandBox1.active(); newSandBox2.active(); // 再次激活\n\nproxyWindow1.a = '4'; // 设置代理1的值\nproxyWindow2.a = '4'; // 设置代理2的值\nwindow.a = '4';  // 设置window的值\nconsole.log('失活后打印输出的值', proxyWindow1.a, proxyWindow2.a, window.a);\n\n```\n\n运行代码，结果如下：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8d1dad97ddc42a88442109ed59c1a8b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n这种方式同一时刻只能有一个激活的多个沙箱，从而实现多实例沙箱。\n\n### 结束语\n\n以上是微前端比较常用的沙箱实现方式，想要在生产中使用，需要我们做很多的判断和约束。请看下篇[qiankun沙箱源码解读](https://juejin.cn/post/6981756262304186405 \"https://juejin.cn/post/6981756262304186405\")，看看框架是怎么实现的。上面的代码在github，如需查看，请移步[js-sandbox](https://github.com/jiechud/micro-frontend-demo/tree/master/js-sandbox \"https://github.com/jiechud/micro-frontend-demo/tree/master/js-sandbox\")\n\n### 参考\n\n+   [iframe src](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#attr-src \"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#attr-src\")\n+   [ES6 Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\")"
    },
    {
      "id": "React服务端渲染",
      "metadata": {
        "permalink": "/React服务端渲染",
        "source": "@site/blog/React服务端渲染.md",
        "title": "React服务端渲染",
        "description": "请输入描述",
        "date": "2023-08-28T08:33:48.770Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 41.175,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "React服务端渲染",
          "title": "React服务端渲染",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "前端JS沙箱实现的几种方式",
          "permalink": "/前端JS沙箱实现的几种方式"
        },
        "nextItem": {
          "title": "自定义Loader",
          "permalink": "/自定义Loader"
        }
      },
      "content": "## 1、前言\n\n在前端项目需要首屏渲染速度优化或 SEO 的场景下，大家或多或少都听过到过服务端渲染( SSR )，但大多数人对服务端渲染具体实现和底层原理还是比较陌生的。本文基于公司官网开发时做了服务端渲染改造基础上，系统理解和梳理这套体系的模式和逻辑，并写了一些笔记和 Demo(文后链接)便于深入理解。这次我们来以 React 为例，把服务端渲染彻底讲弄明白。本文主要有以下内容：\n\n+   什么是服务端渲染，与客户端渲染的区别是什么？\n+   为什么需要服务端渲染，服务端渲染的利弊是什么？\n+   服务端渲染的原理是什么？\n+   如何对 React 项目进行同构？\n+   react 服务端渲染的一些框架\n+   服务端渲染一些新的 API\n\n### 1.1 什么是服务端渲染？\n\n服务端渲染， SSR (Server-side Rendering) ，顾名思义，就是在浏览器发起页面请求后由服务端完成页面的 HTML 结构拼接，返回给浏览器解析后能直接构建出**有内容**的页面。\n\n#### 用 node 实现一个简单的 SSR\n\n我们使用 Koa 框架来创建 node 服务：\n\n```js\n//demo1\nvarKoa=require(\"koa\");\nvarapp=newKoa();\n\n//对于任何请求，app 将调用该函数处理请求：\napp.use(async(ctx)=>{\n//将 HTML 字符串直接返回\nctx.body=`\n<html>\n<head>\n<title>ssr</title>\n</head>\n<body>\n<divid=\"root\">\n<h1>helloserver</h1>\n<p>word</p>\n</div>\n</body>\n</html>`;\n});\n//监听\napp.listen(3001,()=>{\nconsole.log(\"listenon3001port!\");\n});\n```\n\n启动服务后访问页面，查看网页源代码是这样：\n\n![image.png](https://img.bosszhipin.com/beijin/cms/b54784df1ea35938a895d32043658d3812abe361aad786f81676cc89c976cf93c50af8feed84452889411790d0a6f0b9.png?x-oss-process=image/quality,q_60)\n\n  \n\nnpxcreate-react-appmy-app\n\n上面的例子就是一个简单的服务端渲染，其服务侧直接输出了有内容的 HTML，浏览器解析之后就能渲染出页面。与服务端渲染对应的是客户端渲染 ，CSR（Client Side Rendering），通俗的讲就是由客户端完成页面的渲染。其大致渲染流程是这样：在浏览器请求页面时，服务端先返回一个无具体内容的 HTML，浏览器还需要再加载并执行 JS，动态地将内容和数据渲染到页面中，才能完成页面具体内容的显示。目前主流的 React ，Vue， Angular 等 SPA 页面未经特殊处理均采用客户端渲染。最常见脚手架 create-react-app 生成的项目就是客户端渲染：\n\n![image.png](https://img.bosszhipin.com/beijin/cms/7c97da92b71579a01aa746844fb67af012abe361aad786f81676cc89c976cf93e4930547f59e4b39976c95706f43860c.png?x-oss-process=image/quality,q_60)\n\n  \n\n![image.png](https://img.bosszhipin.com/beijin/cms/29d07969fac50fed6703ee1be349437112abe361aad786f81676cc89c976cf932287887eb7f54da6b0b03702e75cdba4.png?x-oss-process=image/quality,q_60)\n\n  \n\n上面采用客户端渲染的 HTML 页面中<div id=\"root\"></div>中无内容，需在浏览器端加载并执行 bundle.js 后才能构建出有内容页面。\n\n### 1.2 为什么用服务端渲染？\n\n#### 1.2.1 服务端渲染的优势\n\n相比于客户端渲染，服务端渲染有什么优势？我们可以从下图对比一下这两种不同的渲染模式。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/8669a77415978b49b9a82886848d1d3812abe361aad786f81676cc89c976cf93e13beb51d4274041baf31c3b6b0cd6a9.png?x-oss-process=image/quality,q_60)\n\n  \n\n**首屏时间更短**\n\n采用客户端渲染的页面，要进行 JS 文件拉取和 JS 代码执行，动态创建 DOM 结构，客户端逻辑越重，初始化需要执行的 JS 越多，首屏性能就越慢；客户端渲染前置的第三方类库/框架、polyfill 等都会在一定程度上拖慢首屏性能。Code splitting、lazy-load 等优化措施能够缓解一部分，但优化空间相对有限。相比而言，服务端渲染的页面直接拉取 HTMl 就能显示内容，更短的首屏时间创造更多的可能性。\n\n**利于 SEO**\n\n在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高，这就是 SEO 的意义所在。那为什么服务端渲染更利于爬虫爬你的页面呢？因为对于很多搜索引擎爬虫（非 google）HTML 返回是什么内容就爬什么内容，而不会动态执行 JS 代码内容。对客户端渲染的页面来说，简直无能为力，因为返回的 HTML 是一个空壳。而服务端渲染返回的 HTML 是有内容的。\n\nSSR 的出现，就是为了解决这些 CSR 的弊端。\n\n#### 1.2.2 权衡使用服务端渲染\n\n并不是所有的 WEB 应用都必须使用 SSR，这需要开发者来权衡，因为服务端渲染会带来以下问题：\n\n代码复杂度增加。为了实现服务端渲染，应用代码中需要兼容服务端和客户端两种运行情况，部分代码只能在客户端运行，需要对其进行特殊处理，才能在服务器渲染应用程序中运行。\n\n需要更多的服务器资源。由于服务器增加了渲染 HTML 的需求，使得原本只需要输出静态资源文件的 nodejs 服务，新增了数据获取的 IO 和渲染 HTML 的 CPU 占用，如果流量突然暴增，有可能导致服务器宕机，因此需要使用响应的缓存策略和准备相应的服务器负载。\n\n涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/4b41d03937ccd4e5ca6058df7683c6f712abe361aad786f81676cc89c976cf932a343f658ac3481eae50fcd777fe9978.png?x-oss-process=image/quality,q_60)\n\n  \n\n因此，在使用服务端渲染 SSR 之前，需要考虑投入产出比：是否真的需要 SEO，是否需要将首屏时间提升到极致。如果都没有，使用 SSR 反而小题大做了。\n\n### 1.3 服务端渲染的发展史\n\n其实服务端渲染并不是什么新奇的概念，前后端分层之前很长的一段时间里都是以服务端渲染为主（JSP、PHP），那时后端一把梭哈，在服务端生成完整的 HTML 页面。但那时的服务端渲染和现在还是有本质的区别，存在比较多的弊端，每一个请求都要动态生成 HTML，存在大量的重复，服务器机器成本也相对比较高，前后端代码完全掺杂在一起，开发维护难。\n\n随着业务不断发展变化，后端要写的 JS 逻辑也越发复杂，而且 JS 有很多潜在的坑使后端越发觉得这是块烫手山芋，于是逐渐出现了前后端分层。伴随 AJAX 的兴起，浏览器可以做到了不再重现请求页面就可更新局部视图。还可以利用客户端免费的计算资源，后端侧逐渐演变成了提供数据支持。jquery 的兴起，良好的客户端兼容性使 JS 不再受困于各种版本浏览器兼容问题，一统了前端天下。\n\n此后伴随 node 的兴起，前后端分离越演越烈。前端能摆脱后端的依赖单独起服务，三大框架 vue，react，angular 也迅势崛起，以操作数据就能更新视图，前端开发人员逐渐摆脱了与烦人的 Dom 操作打交道，能够专心的关注业务和数据逻辑。前端同时探索出了功能插件，UI 库，组件等多种代码复用方案，形成了繁荣的前端生态。\n\n但是三大框架采用客户端渲染模式，随着代码逻辑的加重，首屏时间成了一个很大的问题，同时开发人员也发现 SEO 也出了问题，大多搜索引擎根本不会去执行 JS 代码。但是也不可能再回头走老路，于是前端又探索出了一套服务端渲染的框架来解决掉这些问题。此时的服务端渲染是建立在成熟的组组件，模块生态之上，基于 Node.js 的同构方案成为最佳实践。\n\n## **2、React 服务端渲染的原理**\n\n### 2.1**基本思路**\n\n**React 服务端渲染流程**\n\nReact 服务端渲染的基本思路，简单理解就是将组件或页面通过服务器生成 html 字符串，再发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序。因为要考虑 React 在服务端的运行情况，故相比之前讲的多了在浏览器端绑定状态与事件的过程。\n\n我们可以结合下面的流程图来一览完整的 React 服务端渲染的全貌：当浏览器去请求一个页面，前端服务器端接收到请求并执行 React 组件代码，此时 React 代码中可能包含向后端服务器发起请求，待请求完成返回的数据后，前端服务器组装好有内容的 HTML 里返给浏览器，浏览器解析 HTML 后已具备展示内容，但页面并不具备交互能力。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/98644d4be22ed7ceb3cb83d15641289312abe361aad786f81676cc89c976cf939341123f1ca247a683d4d81d10ac3af6.png?x-oss-process=image/quality,q_60)\n\n  \n\n下一阶段，在返回的 HTMl 中还有 script 链接，浏览器再拉取 JS 并执行其包含的 React 代码，其能在浏览器端执行完整的生命周期，并通过相关 API 实现复用此前返回 HTML 节点并添加事件的绑定，此时页面才就具备完全交互能力。总的来说，react 服务端渲染包含有两个过程：服务端渲染 + 客户端 hydrate 渲染。服务端渲染在服务端渲染出了首屏内容；客户端 hydrate 渲染复用服务端返回的节点，进行一次类似于 render 的 hydrate 渲染过程，把交互事件绑上去（此时页面可交互），并接管页面。\n\n服务端处理后返回的\n\n![image.png](https://img.bosszhipin.com/beijin/cms/dba066f000745d8033404d7a1eee006412abe361aad786f81676cc89c976cf932b6a30b4b5e2484190dd071b9f721584.png?x-oss-process=image/quality,q_60)\n\n  \n\n客户端“浸泡”还原后的\n\n![image.png](https://img.bosszhipin.com/beijin/cms/1aff5acd06caaff5567f98ebc32e6bbe12abe361aad786f81676cc89c976cf9321c7c497fb82497bb0e88c2f7adee460.png?x-oss-process=image/quality,q_60)\n\n  \n\n#### **核心思想（同构）**\n\n从上面的流程中可以看到，客户端和服务端都要执行 React 代码完成渲染，那是不是就要写两份代码，供双端使用? 当然不需要，也完全不合理。所谓同构，就是让一份 React 代码，既可以在服务端中执行，也可以在客户端中执行。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/4737c98bdb7597df1e83b63925b80be012abe361aad786f81676cc89c976cf93616dccb428744acfb1f1af73606f9881.png?x-oss-process=image/quality,q_60)\n\n  \n\n#### **SSR 技术栈**\n\n我们这里简单理了一下服务端渲染涉及到的技术栈：\n\n知道了服务端渲染、同构的大概思路之后，下面从头开始，一步一步完成具体实践，深入理解其原理。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/8e16ee088e637c661ecaec3c532141e712abe361aad786f81676cc89c976cf932370d5628b1e402ca14dc6e644cfd12d.png?x-oss-process=image/quality,q_60)\n\n  \n\n### 2.2 服务端如何渲染 React 组件？\n\n按照之前流程的大概思路，我们首先需要将 React 组件在服务端转换成 HTML 字符串，那怎么做呢？React 提供的面向服务端的 API（react-dom/server），提供了相关方法能够将 React 组件渲染成静态的（HTML）标签。下面我们简单了解下**react-dom/server。**\n\n#### **react-dom/server**\n\nreact-dom/server 有 renderToString、renderToStaticMarkup，renderToNodeStream、renderToStaticNodeStream 四个方法能够将 React 组件渲染成静态的（HTML）标签，前两者能在客户端和服务端运行，后两者只能在服务端运行。\n\nrenderToStaticMarkup VS renderToString：renderToString 方法会在 React 内部创建的额外 DOM 属性，例如 data-reactroot， 在相邻文本节点之间生成<!-- -->，这些属性是客户端执行 hydrate 复用节点的关键所在，data-reactroot 属性是服务端渲染的标志之一。如果你希望把 React 当作静态页面生成器来使用，renderToStaticMarkup 方法会非常有用，因为去除额外的属性可以节省一些字节。\n```js\n\n//Home.jsx\nimportReactfrom\"react\";\nconstHome=()=>{\nreturn(\n<div>\n<h2onClick={()=>console.log(\"hello\")}>ThisisHomePage</h2>\n<p>Homeisthepage.....morediscribe</p>\n</div>\n);\n};\nexportdefaultHome;\n\n我们使用 React-dom/server 下提供的 renderToString 方法，在服务端将其转换为 html 字符串：\n\n//server.js\nimportKoafrom\"koa\";\nimportReactfrom\"react\";\nimport{renderToString}from\"react-dom/server\";\nimportHomefrom\"./containers/Home\";\n\nconstapp=newKoa();\napp.use(async(ctx)=>{\n//核心 apirenderToString将 react 组件转化成 html 字符串\nconstcontent=renderToString(<Home/>);\nctx.body=`\n<html>\n<head>\n<title>ssr</title>\n</head>\n<body>\n<divid=\"root\">${content}</div>\n</body>\n</html>\n`;\n});\napp.listen(3002,()=>{\nconsole.log(\"listen:3002\");\n});\n```\n\n可以看到上面代码里有 ES6 的 import 和 jsx 语法，不能直接运行在 node 环境，需要借助 webpack 打包， 构建目标是 commonjs。新建 webpack.server.js 具体配置如下：\n```js\n\n//webpack.server.js\nconstpath=require(\"path\");\nconstnodeExternals=require(\"webpack-node-externals\");\nmodule.exports={\nmode:\"development\",\ntarget:\"node\",\nentry:\"./server.js\",\nresolve:{\nextensions:[\".jsx\",\".js\",\".tsx\",\".ts\"],\n},\nmodule:{\nrules:[\n{\ntest:/.jsx?$/,\nloader:\"babel-loader\",\nexclude:/node_modules/,\noptions:{\npresets:[\"@babel/preset-react\",\"@babel/preset-env\"],\nplugins:[\n[\n\"@babel/plugin-transform-runtime\",\n{\nabsoluteRuntime:false,\ncorejs:false,\nhelpers:true,\nregenerator:true,\nversion:\"7.0.0-beta.0\",\n},\n],\n],\n},\n},\n],\n},\noutput:{\nfilename:\"bundle.js\",\npath:path.resolve(__dirname,\"build\"),\n},\nexternals:[nodeExternals()],\n};\n```\n\n在 webpack 构建完成后，可在 Node 环境运行 build/bundle.js，访问页面后查看网页源代码，可以看到，React 组件中的内容已经完整地包含在服务端返回到 html 里面。我们成功迈出了服务端渲染第一步。此时，我们也有必要再深入了解 renderToString 到底做了什么，提前踩坑！\n\n![image.png](https://img.bosszhipin.com/beijin/cms/e0033363473e2bb0a6327597f7682b0912abe361aad786f81676cc89c976cf932f78d9a0fc184055a1d12350cab6591b.png?x-oss-process=image/quality,q_60)\n\n  \n\n#### **renderToString**\n\n除了将 React 组件转换成 html 字符串外，renderToString 还有做了下面这些：\n\n1. 会执行传入的 React 组件的代码，但是其只执行到 React 生命周期初始化过程的 render 及之前，即下面红框的部分，其余大部分生命周期函数在服务端都不执行；这也是服务端渲染的坑点之一。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/8f86b4146c4755eec1d4c1d8a45f53d612abe361aad786f81676cc89c976cf931764f263fc5c4b47a7c9c0f8e9301ccb.png?x-oss-process=image/quality,q_60)\n\n  \n\n2.**renderToString**生成的产物中会包含一些额外生成特殊标记，代码体积会有所增大，其中属性 data-reactroot 是服务端渲染的标志，便于后续客户端通过 hydrate 复用 HTML 节点。在 React16 前后其产物也有差距：在 React 16 之前，服务端渲染采用的是基于字符串校验和（string checksum）的 HTML 节点复用方式， 会额外生成生成 data-reactid、data-react-checksum 等属性；React 16 改用单节点校验来复用（服务端返回的）HTML 节点，不再生成 data-reactid、data-react-checksum 等体积占用大户，只在空白节点间多了<!-- --> 这样的标记。\n\nrenderToStringreact16 前\n\n<div data-reactroot=\"\"data-reactid=\"1\"data-react-checksum=\"122239856\">\n<span data-reactid=\"2\">WelcometoReactSSR!</span>\nHelloThere!\n</div>\n\n//renderToStringreact16\n<div data-reactroot=\"\"><h1 class=\"here\"><span>WelcometoReactSSR!</span>HelloThere!</h1></div>\n\n3.会被故意忽略掉的 on 开头的的属性，也就忽略掉了 react 代码中事件处理，这是也是坑点之一。服务端返回的 html 里没有处理事件点击，需要靠后续客户端 js 执行绑定事件。\n```js\n\nfunctionshouldIgnoreAttribute(\nname:string,\npropertyInfo:PropertyInfo|null,\nisCustomComponentTag:boolean,\n):boolean{\nif(propertyInfo!==null){\nreturnpropertyInfo.type===RESERVED;\n}\nif(isCustomComponentTag){\nreturnfalse;\n}\nif(\nname.length>2&&\n(name[0]==='o'||name[0]==='O')&&\n(name[1]==='n'||name[1]==='N')\n){\nreturntrue;\n}\nreturnfalse;\n}\n```\n\n![image.png](https://img.bosszhipin.com/beijin/cms/eb5a43648bbd666db5f65d731b1ab5ca12abe361aad786f81676cc89c976cf93873d2c2b9cba49148d32c713da9e1e4f.png?x-oss-process=image/quality,q_60)\n\n  \n\n上面的例子我们可以看到 React 的代码里有点击事件，但点击后没有反应。需要靠后续客户端 js 执行绑定事件。如何实现？这就需要同构了。\n\n### 2.3 实现基础的同构\n\n前文已经大概讲了同构的概念，那为什么需要同构？之前的服务端代码在处理点击事件时故意忽略掉了这类属性，在服务端执行的生命周期也是不完整的，此时的页面是不具备交互能力的。同构，正是解决这些问题的关键，React 代码在服务器上执行一遍之后，浏览器再去加载 JS 后又运行了一遍 React 代码，完成事件绑定和完整生命周期的执行，从而才能成为完全可交互页面。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/49c100ef5424b8c0f069832d3a4619b812abe361aad786f81676cc89c976cf9308776b90463d4e7fa3a876da6ecae6de.png?x-oss-process=image/quality,q_60)\n\n  \n\n**react-dom：hydrate**\n\n实现同构的另一个核心 API 是 React-dom 下的**hydrate，**该方法能在客户端初次渲染的时候去复用服务端返回的原本已经存在的 DOM 节点，于渲染过程中为其附加交互行为（事件监听等），而不是重新创建 DOM 节点。需要注意是，服务端返回的 HTML 与客户端渲染结果不一致时，出于性能考虑，hydrate 可以弥补文本内容的差异，但并不能保证修补属性的差异，而是将错就错；只在 development 模式下对这些不一致的问题报 Warning，因此必须重视 SSR HydrationWarning，要当 Error 逐个解决。\n\n那具体实现同构？\n\n![image.png](https://img.bosszhipin.com/beijin/cms/97db63aae86e7c37cabd4fe67fc0941b12abe361aad786f81676cc89c976cf93340350acbb524820915c34480ecd700c.png?x-oss-process=image/quality,q_60)\n\n  \n\n上面这里我们提供了一个基本的架构图，可以看到，服务端运行 React 生成 html 代码我们已经基本实现，目前需要做的就是生产出客户端执行的 index.js，那么这个 index.js 我们如何生产出来呢？\n\n**具体实践**\n\n首先新建客户端代码 client.js，引入 React 组件，通过 ReactDom.hydrate 处理挂载到 Dom 节点， hydrate 是实现复用的关键。\n\n```js\n//client.js\nimportReactfrom\"react\";\nimportReactDomfrom\"react-dom\";\nimportHomefrom\"./containers/Home\";\n\nconstApp=()=>{\nreturn<Home></Home>;\n};\n\nReactDom.hydrate(<App/>,document.getElementById(\"root\"));\n```\n\n客户端代码也需要 webpack 打包处理，新建 webpack.client.js 具体配置如下，需要注意打包输出在 public 目录下，后续的静态资源服务也起在了这个目录下。\n```js\n\n//webpack.client.js\nconstpath=require(\"path\");\nconstresolve=(dir)=>path.resolve(__dirname,\"./src\",dir);\nmodule.exports={\nmode:\"development\",\nentry:\"./client.js\",\noutput:{\nfilename:\"index.js\",\npath:path.resolve(__dirname,\"public\"),\n},\nmodule:{\nrules:[\n//babel-loader 处理 js 的一些配置\n],\n},\n};\n```\n\n服务端的静态资源服务使用 koaStatic 起在 public 目录，这样就能通过外链访问到打包出来的客户端 js，同时我们在 html 中嵌入这个链接。\n\n```js\n//server.js\nimportkoaStaticfrom\"koa-static\";\n\nconstapp=newKoa();\napp.use(koaStatic(\"public\"));\n\napp.use(async(ctx)=>{\nconstcontent=renderToString(<Home/>);\nconsole.log(content);\nctx.body=`\n<html>\n<body>\n<divid=\"root\">${content}</div>\n<scriptsrc=\"./index.js\"></script>\n</body>\n</html>\n`;\n});\napp.listen(3003,()=>{\nconsole.log(\"listen:3003\");\n});\n```\n\n简单看下此时的代码结构是这样：\n\n├──package.json\n├──webpack.client.js\n├──webpack.server.js\n├──server.js\n├──client.js\n└──containers\n└──Home.jsx\n\n通过上面一番操作，简单的同构基本可以跑起来了，点击对应位置后看到有了反应，查看网页源代码如下。可以看到多了 script 标签的 index.js 这段，这是在客户端执行的 js 代码。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/383c7283ceb879daaeb3c9b2318b989812abe361aad786f81676cc89c976cf933c35c20c2b4b4339a30176f09182ac7b.png?x-oss-process=image/quality,q_60)\n\n  \n\n![image.png](https://img.bosszhipin.com/beijin/cms/60314255045ded76c1333655cbe58e1712abe361aad786f81676cc89c976cf93deef608328b84cbd95342ddbd09c3ef3.png?x-oss-process=image/quality,q_60)\n\n  \n\n以上我们仅仅是就完成了一个 React 基础的同构，但这还远不够，一个完整的前端页面还包含路由，状态管理，请求服务端数据等，这些也需要进行同构，且看下面为你一一道来。\n\n### 2.4 路由的同构\n\n我们之前页面只是一个页面， 但实际开发的应用用一般都是多个页面的，这就需要加入路由了。服务端渲染加入路由就涉及到同一份路由在不同端的执行，这就是路由的同构。\n\n下面一步步来：首先加入 About 页面，并书写路由配置 routes.js\n\n```js\n//routes.js\nimportHomefrom\"./containers/home\";\nimportAboutfrom\"./containers/about\";\nexportdefault[\n{path:\"/\",component:Home,exact:true},\n{\npath:\"/about\",\ncomponent:About,\nexact:true,\n},\n];\n\n在客户端侧加入路由的写法还是熟悉的写法，考虑到页面中可能涉及多级路由的渲染，这里直接引入 react-router-config 中来处理：\n\n//client.js\nimport{BrowserRouter}from\"react-router-dom\";\nimport{renderRoutes}from\"react-router-config\";\nimportRoutesfrom\"./routes\";\n\nconstApp=()=>{\nreturn(\n<BrowserRouter>\n<div>{renderRoutes(Routes)}</div>\n</BrowserRouter>\n);\n};\n\nreact-router 为服务端提供了 StaticRouter，需显式地向 location 传 path。\n\n//server.js\nimport{StaticRouter}from\"react-router-dom\";\nimport{renderToString}from\"react-dom/server\";\nimportRoutesfrom\"./routes\";\nimport{renderRoutes}from\"react-router-config\";\n\nconstapp=newKoa();\napp.use(koaStatic(\"public\"));\n\napp.use(async(ctx)=>{\nconstcontent=renderToString(\n<StaticRouterlocation={ctx.request.path}>\n<div>{renderRoutes(Routes)}</div>\n</StaticRouter>\n)；\n}\n```\n\n以上就完成了路由的配置，还比较简单吧，此时页面的路由跳转基本没问题了。\n\n### 2.5 Redux 的同构\n\n如何让前端页面的应用状态可控、让协作开发高效也是我们必须考虑的问题。Redux 作为 React 最常见的状态管理方案被很多项目引入来解决这一问题。那引入 Redux 如何被到同构项目中？这里，我们还是简单回顾一下 redux 运作流程，不熟悉的可以移步 redux 熟悉下。接下来开启 Redux 的同构之旅。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/82279be78283234177a7a65edb4225ce12abe361aad786f81676cc89c976cf9309b5787c70064e4fbdf0e807501965c4.png?x-oss-process=image/quality,q_60)\n\n  \n\n**第一步：创建全局 STORE**\n\n首先我们创建了一个 store.js，初始化配置并导出一个函数用来实例化 store，以提供给客户端和服务端同时使用。为什么 store 要导出一个函数？因为这段代码后面服务端使用时，如果下面的 store 导出的是一个单例，所有的用户用的是同一份 store，那将是灾难性的结果。\n\n```js\n//store.js\nimport{createStore,applyMiddleware,combineReducers}from\"redux\";\nimportthunkfrom\"redux-thunk\";\n//这里提前引入了 About 组件下的 store\nimport{reducerasAboutReducer}from\"../containers/store\";\n\nconstreducer=combineReducers({\nabout:AboutReducer,\n});\n\n//导出成函数的原因\nexportdefault()=>{\nreturncreateStore(reducer,applyMiddleware(thunk));\n};\n```\n\n**第二步：连接全局 STORE**\n\n客户端的写法还是熟悉的样子：\n\n```js\n//client.js\nimport{Provider}from\"react-redux\";\nimportgetStorefrom\"./store\";\n\nconstApp=()=>{\nreturn(\n<Providerstore={getStore()}>\n<BrowserRouter>\n<div>{renderRoutes(Routes)}</div>\n</BrowserRouter>\n</Provider>\n);\n};\n```\n\n服务端 server.js 的写法也是类似：\n\n```js\n//server.js\nimport{Provider}from\"react-redux\";\nimportgetStorefrom\"./store\";\n\nconstapp=newKoa();\napp.use(koaStatic(\"public\"));\n\napp.use(async(ctx)=>{\nconstcontent=renderToString(\n<Providerstore={getStore()}>\n<StaticRouterlocation={ctx.request.path}>\n<div>{renderRoutes(Routes)}</div>\n</StaticRouter>\n</Provider>\n);\n}\n```\n\n**第三步：组件的 store**\n\n新建 About 组件使用的 store，其 action 和 reducer 的写法如下，注意此时我们在 action 里发起了一个异步请求。\n\n```js\n//containers/store/reduccer.js\nimport{CHANGE_LIST}from\"./constants\";\n\nconstdefaultState={name:\"panpan\",age:18,list:[]};\nexportdefault(state=defaultState,action)=>{\nswitch(action.type){\ncaseCHANGE_LIST:\nreturn{...state,list:action.payload};\ndefault:\nreturnstate;\n}\n};\n//containers/store/action.js\nimportaxiosfrom\"axios\";\nimport{CHANGE_LIST}from\"./constants\";\n\nconstchangeAction=(payload)=>({\ntype:CHANGE_LIST,\npayload,\n});\n\nconstgetHomeList=()=>{\nreturn(dispatch)=>{\nreturnaxios.get(\"http://localhost:3008/mock/1\").then((res)=>{\ndispatch(changeAction(res.data.data||[]));\n});\n};\n};\n\nexportdefault{\ngetHomeList,\n};\n```\n\nAbout 组件连接 Redux:\n\n```js\n//containers/About.js\nimport{connect}from\"react-redux\";\nimport{action}from\"./store\";\n\nconstAbout=()=>{\nuseEffect(()=>{\nprops.getList();\n},[]);\n//...\n}\nconstmapStateToProps=(state)=>({\nname:state.about.name,\nage:state.about.age,\nlist:state.about.list,\n});\nconstmapDispatchToProps=(dispatch)=>({\ngetList(){\ndispatch(action.getHomeList());\n},\n});\n\nexportdefaultconnect(mapStateToProps,mapDispatchToProps)(About);\n```\n\n经过一番改造后，项目变成了这样：\n\n├──package.json\n├──mock.server.js\n├──webpack.client.js\n├──webpack.server.js\n├──routes.js\n├──server.js\n├──client.js\n└──store\n└──index.js\n└──containers\n├──Home.js\n├──About.js\n└──store\n├──index.js\n├──action.js\n├──reducer.js\n└──constants.js\n\n通过上述操作 Redux 基本可以跑起来了，可以发现写法跟熟悉的客户端渲染大体差不多，只多了引入 server 端的步骤。但是目前的 redux 还存在一定的问题，我们一起再来看。\n\n**服务端没数据问题**\n\n上面的 redux 在同构项目中跑起来咋一看是没什么问题，但当我们把 js 禁用或直接查看源代码时，就会发现 About 组件内并不存在异步请求的数据列表，换句话说服务器端的 store 的 list 始终是空的，服务端并没有发起相应的数据请求。为什么会这样呢？\n\n分析一下：当浏览器发起页面请求后，服务器接收到请求，此时服务器和客户端的 store 的 list 都为空， 接着服务端开始渲染执行 React 代码，根据此前讲 rendertostring 坑之一，服务端调用 React 代码时里面的生命周期的只到初始化时的 render 及之前，而 About 组件内发起的异步请求是在 useEffect 内，相当于是在*ComponentDidMount*阶段发起请求，所以服务器端渲染时根本不会执行里面的异步请求，因此服务器端的 store 的 list 始终是空的，所以我们看不到列表数据。之后客户端拉取了 JS 并执行 React 代码，React 在客户端能够执行完整的生命周期，故可以执行 useEffect 里的函数获取到数据并渲染到页面。换而言之，目前获取异步数据只是进行了后期的客户端渲染阶段。\n\n如何让服务端将获得数据的操作执行一遍，以达到真正的服务端渲染的效果？这就是接下来要讲的服务端渲染异步数据。\n\n### 2.6 服务端渲染异步数据\n\n上文的同构项目中跑起来后，我们是在组件的 useEffect 中发起的异步请求，服务端并不能执行到这一块。那能不能在其他生命周期获取异步请求数据？答案是不推荐，因为 React16 采用了 Fiber 架构后，render 之前的生命周期都可能被中断而执行多次，类似 getDerivedStateFromProps(静态方法), ComponentWillMount（废弃）, UNSAFE_componentWillMount 的生命周期钩子都有可能执行多次，所以不建议在这些生命周期中做有请求数据之类副作用的操作。而 componentDidMount 在 render 之后是确定被执行一次的，所以 React 开发中建议在 componentDidMount 生命周期函数进行异步数据的获取。那有没有其他的解决方案呢? React Router 恰好也考虑到了这点，提供了这样一种解决方案，需要我们对路由进行一些改造。\n\n**React Router 解决方案**\n\nReact Router 解决方案的基本思路：\n\n![image.png](https://img.bosszhipin.com/beijin/cms/69bed1d8a01ad7bff25df7630588c81d12abe361aad786f81676cc89c976cf93b55b8929f1b9455fb5cae093421e8146.png?x-oss-process=image/quality,q_60)\n\n  \n\n首先，改造原有的路由，配置了一个 loadData 参数，这个参数代表要在服务端获取数据的函数：\n\n```js\n//router.js\nimportHomefrom\"./containers/home\";\nimportAboutfrom\"./containers/about\";\nexportdefault[\n{path:\"/\",component:Home,exact:true},\n{\npath:\"/about\",\ncomponent:About,\nexact:true,\nloadData:About.loadData,\n},\n];\n```\n\n在服务端匹配路径对应的路由，如果这个路由对应的组件有 loadData 方法，那么就执行一次,并将 store 传进 loadData 里面去，注意 loadData 函数调用后需要返回 Promise 对象，等待 Promise.all 都 resolve 后，此时传过去的 store 已经完成了更新，便可以在 renderToString 时放心使用：\n\n```js\n//server.js\nimport{renderRoutes,matchRoutes}from\"react-router-config\";\nimport{Provider}from\"react-redux\";\nimportgetStorefrom\"./store\";\n\napp.use(async(ctx)=>{\nconststore=getStore();\n//匹配到路径对应的路由\nconstmatchArr=matchRoutes(Routes,ctx.request.path);\nletpromiseArr=[];\nmatchArr.forEach((item)=>{\n//判断有没有loadData\nif(item.route.loadData){\n//要将 store 传递过去\n//item.route.loadData()返回的是一个 promise\npromiseArr.push(item.route.loadData(store));\n}\n});\n//等待异步完成，store 已完成更新\nawaitPromise.all(promiseArr);\nconstcontent=renderToString(\n<Providerstore={store}>\n<StaticRouterlocation={ctx.request.path}>\n<div>{renderRoutes(Routes)}</div>\n</StaticRouter>\n</Provider>\n);\n}\n\n```\n接下来是组件内 loadData 函数，发起异步请求，并返回一个 Promise\n\n```js\n//containers/About.js\nimport{connect}from\"react-redux\";\nimport{action}from\"./store\";\n\nconstAbout=(props)=>{\nuseEffect(()=>{\nprops.getList();\n},[]);\n//...\n};\nAbout.loadData=(store)=>{\n//可能存在多个数据请求，所以用 promise.all包一层\nreturnPromise.all([store.dispatch(action.getHomeList())]);\n};\nconstmapStateToProps=(state)=>({\nname:state.about.name,\nage:state.about.age,\nlist:state.about.list,\n});\nconstmapDispatchToProps=(dispatch)=>({\ngetList(){\ndispatch(action.getHomeList());\n},\n});\n\nexportdefaultconnect(mapStateToProps,mapDispatchToProps)(About);\n```\n\n通过以上改造，服务端可以获取到异步数据了。但是眼尖的朋友可能注意到，页面此时还存在问题，页面中还不时存在 list 闪烁问题，这是什么原因导致的呢？这就涉及到数据的同步问题。\n\n**数据的注水和脱水**\n\n让我们来分析一下客户端和服务端的运行流程：\n\n可以看到客户端和服务端的 store 都经历了初始化置空的问题，导致 store 不同步, 那如何才能让这两个 store 的数据同步变化呢? 这就涉及到数据的注水和脱水。“注水”：在服务端获取获取之后，在返回的 html 代码中加入这样一个 script 标签，这样就将服务端 store 数据注入到了客户端全局的 window.context 对象中。\n```js\n\n//server.js\napp.use(async(ctx)=>{\n//...\nctx.body=`\n<html>\n<head>\n<title>ssr</title>\n\n</head>\n<body>\n<divid=\"root\">${content}</div>\n<script>\nwindow.context={\nstate:${JSON.stringify(store.getState())}\n}\n</script>\n<scriptsrc=\"./index.js\"></script>\n</body>\n</html>\n`;\n});\n```\n\n“脱水”处理：把 window 上绑定的数据给到客户端的 store，因此在 store.js 区分了客户端和服务端不同的导出函数。\n\n```js\n//store.js\n//客户端使用\nexportconstgetClientStore=()=>{\nconstdefaultState=window.context?window.context.state:{};\nreturncreateStore(reducer,defaultState,applyMiddleware(thunk));\n};\n//服务端使用\nexportconstgetServerSore=()=>{\nreturncreateStore(reducer,applyMiddleware(thunk));\n};\n```\n\n至此 redux 包含异步数据的获取的同构就完成了。\n\n### 2.7 css 的服务端渲染\n\n为什么需要做 css 要服务端渲染？主要是解决页面的 FOUC 闪屏问题。页面如果没做 css 的服务服务端渲染，我们一开始拉取到的 HTML 页面是没有样式的，页面的样式正常显示主要依赖于后面的客户端渲染，我们知道客户端渲染的时间相对要长很多，如果渲染前后存在较大的样式差距，就会引起闪屏。\n\n还是以 About 组件为例，页面中加入样式：\n\n```js\n.title{\ncolor:aqua;\nbackground:#999;\nheight:100px;\nline-height:100px;\nfont-size:40px;\n}\n//containers/About.js\nimportstylesfrom\"./about.css\";\n\nconstAbout=(props)=>{\n//...\nreturn(\n<h3className={styles.title}>ListContent</h3>\n);\n};\n```\n需要 webpack 中相应的配置处理 css，我们先处理客户端打包\n\n```js\n{\ntest:/.css?$/,\nuse:[\n\"style-loader\",\n{\nloader:\"css-loader\",\noptions:{\nmodules:true,\n},\n},\n],\n}\n```\n\n上面的代码跑起来，就会发现有明显的闪烁，复盘一下：页面一开始 html 是没样式的，待到客户端 js 执行完成后，页面才突然有了样式显示正常。为了避免这种闪烁带来的不愉快体验，服务端也需要进行 css 的渲染。\n\n**在服务端如何处理 css？**\n\n客户端 webpack 采用 css-loader 处理后，style-loader 直接将样式通过 DOM 操作进行插入，这对于浏览器环境很好很方便，但是对于服务端的 Node 环境，这就没法愉快的玩耍了。Node 环境下可将样式插入到生成的 html 字符串中，而不是进行 DOM 操作。这时就需要用到另外一个跨平台的 loader：isomorphic-style-loader，在服务端的 webpack 配置是这样：\n\n```js\n//webpack.server.js\n{\ntest:/.css?$/,\nuse:[\n\"isomorphic-style-loader\",\n{\nloader:\"css-loader\",\noptions:{\nmodules:true,\n},\n},\n],\n},\n```\n\n通过 isomorphic-style-loader 处理，我们可以在组件内直接通过 styles._getCss 即可拿到 CSS 代码，但这还不够，如何将拿到的 css 传回到服务端 sever.js 里从而塞入返回体呢？\n\n```js\n//containers/About.js\nimportstylesfrom\"./about.css\";\n\nconstAbout=(props)=>{\nconsole.log(styles._getCss&&styles._getCss());\n//...\n}\n```\n\n**CSS 的服务端渲染**\n\nCSS 服务端渲染还需要借助 StaticRouter 中已经帮我们准备的一个钩子变量 context，传入外部对象变量到 StaticRouter 到 context 里。路由配置对象 routes 中的组件都能在服务端渲染的过程中拿到这个 context，这个 context 对于组件来说相当于 props.staticContext。将获取到的 css 推入到 staticContext.css 里，这样服务端的 context 对象就完成了改变,我们便可以拼接 css 到 head 中。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/ae340609f138848247bd90ae99203a0912abe361aad786f81676cc89c976cf93d71988ef943a4b3d953b289c06d2d0ea.png?x-oss-process=image/quality,q_60)\n\n```js\n\n//server.js\napp.use(async(ctx)=>{\n//初始化context\nletcontext={css:[]};\nconstcontent=renderToString(\n<Providerstore={store}>\n//StaticRouter传入 context，组件接收到的 props 为 staticContext\n<StaticRouterlocation={ctx.request.path}context={context}>\n<div>{renderRoutes(Routes)}</div>\n</StaticRouter>\n</Provider>\n);\n//将 css 插入到 head 里面\nctx.body=`\n<html>\n<head>\n<title>ssr</title>\n<style>${context.css.join(\"n\")}</style>\n</head>\n...\n</html>\n`;\n});\n//containers/About.js\nimportstylesfrom\"./about.css\";\n\nconstAbout=(props)=>{\n//只有服务端才传过来了 context，组件中 props 为 staticContext\nif(props.staticContext){\n//将 css 推入数组，改变了传入的 context\nprops.staticContext.css.push(styles._getCss());\n}\n//...\n}\n```\n\n通过上面的操作，css 的服务端渲染基本能正常工作。需要注意的是 React-router 传过来的 context 只有配置对象 routes 中的组件才能拿到，如果组件里面再嵌入子组件，需要把 staticContext 透传过去，才能对子组件 props.staticContext 进行相应操作。当然这里更推荐官方 demo 里的另一种写法，且看下面。\n\n**更推荐写法**\n\n我们可以查看 isomorphic-style-loader 的 demo，更推荐写法是：客户端、服务端都用 isomorphic-style-loader，webpack 处理客户端 css 是这样配置的：\n\n```js\n//webpack.client.js\n{\ntest:/.css?$/,\nuse:[\n\"isomorphic-style-loader\",\n{\nloader:\"css-loader\",\noptions:{\nmodules:true,\n},\n},\n],\n},\n```\n\n组件内的写法也有相应改变，isomorphic-style-loader 提供了 hooks：useStyles\n\n```js\n//containers/About.js\nimportuseStylesfrom\"isomorphic-style-loader/useStyles\";\nimportstylesfrom\"./about.css\";\n\nconstAbout=(props)=>{\nuseStyles(styles);\n//...\n}\n```\n\n在服务端的代码里是这样的：\n\n```js\n//server.js\nimportStyleContextfrom\"isomorphic-style-loader/StyleContext\";\n//...\n\napp.use(async(ctx)=>{\nconstcss=newSet();\nconstinsertCss=(...styles)=>\nstyles.forEach((style)=>css.add(style._getCss()));\nconstcontent=renderToString(\n<Providerstore={store}>\n<StyleContext.Providervalue={{insertCss}}>\n<StaticRouterlocation={ctx.request.path}context={context}>\n<div>{renderRoutes(Routes)}</div>\n</StaticRouter>\n</StyleContext.Provider>\n</Provider>\n);\nctx.body=`\n<html>\n<head>\n<title>ssr</title>\n<style>${[...css].join(\"\")}</style>\n</head>\n<body>\n<divid=\"root\">${content}</div>\n<script>\nwindow.context={\nstate:${JSON.stringify(store.getState())}\n}\n</script>\n<scriptsrc=\"./index.js\"></script>\n</body>\n</html>\n`;\n})\n```\n\n类似的，客户端也需要做下面的调整：\n\n```js\n//client.js\nimportStyleContextfrom\"isomorphic-style-loader/StyleContext\";\n//...\n\nconstApp=()=>{\nconstinsertCss=(...styles)=>{\nconstremoveCss=styles.map((style)=>style._insertCss());\nreturn()=>removeCss.forEach((dispose)=>dispose());\n};\nreturn(\n<Providerstore={getStore()}>\n<StyleContext.Providervalue={{insertCss}}>\n<BrowserRouter>\n<div>{renderRoutes(Routes)}</div>\n</BrowserRouter>\n</StyleContext.Provider>\n</Provider>\n)\n}\n```\n\n### 2.8 优化 title 和 description\n\n页面中的 title，keywords 和 description 在 SEO 中具有举足轻重的地位。上面的 React 项目中初始只有一份 title 和 description，虽然不同页面可使用 js 生成的动态 title 和 descroption，但这类信息搜索引擎是没办法抓取到的。为了更好的 SEO，我们需要根据不同的页面组件显示来对应不同的网站标题和描述，这如何实现的呢？我们可以引入 react-helmet 来解决这个问题。\n\n**引入 react-helmet**\n\n组件内：\n\n```js\n//containers/About.js\nimport{Helmet}from\"react-helmet\";\n//...\nreturn(\n<div>\n<Helmet>\n<metacharSet=\"utf-8\"/>\n<title>SSRAboutPage</title>\n<metaname=\"description\"content=\"thisispanpanaboutpage\"/>\n</Helmet>\n<div>\n)\n//..\n```\n\n服务端 html 部分：\n\n```js\n//server.js\nconsthtml=`\n<!doctypehtml>\n<html>\n<head>\n${helmet.title.toString()}\n${helmet.meta.toString()}\n</head>\n</html>\n`;\n```\n\n## 3、开箱即用的 SSR 框架\n\n### Next.js\n\nNext.js 是一款面向生产使用的 React 框架，提供了好些开箱即用的特性，支持静态渲染/服务端渲染混用、支持 TypeScript、支持打包优化、支持按路由预加载等等：其中，完善的静态渲染/服务端渲染支持让 Next.js 在 React 生态中独树一帜。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/d16bff8eb4e2f76d1d1e85f4aef1b54812abe361aad786f81676cc89c976cf939206c78b2f71471892fed55b6d11c0fa.png?x-oss-process=image/quality,q_60)\n\n  \n\nNext.js 中的预渲染（Pre-rendering），具体的分为两种方式：\n\nSSG（Static Site Generation）：也叫 Static Generation，在编译时生成静态 HTML\n\nSSR（Server-Side Rendering）：也叫 Server Rendering，用户请求到来时动态生成 HTML\n\n与 SSR 相比，Next.js 更推崇的是 SSG，因为其性能优势更大（静态内容可托管至 CDN，性能提升立竿见影）。因此建议优先考虑 SSG，只在 SSG 无法满足的情况下（比如一些无法在编译时静态生成的个性化内容）才考虑 SSR、CSR。\n\n### UmiJS\n\nUmi 很多功能是*参考 next.js*做的，要说有哪些地方不如 Umi，可能是不够贴近业务，不够接地气。Umi 3 结合自身业务场景，在 SSR 上做了大量优化及开发体验的提升，内置 SSR，一键开启，开发调试方便。Umi 不耦合服务端框架，无论是哪种框架或者 Serverless 模式，都可以非常简单进行集成。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/a20fc3480da6fc5d9f85c5de6a081b8b12abe361aad786f81676cc89c976cf932b1db153af2243ca9b6147ec4844d6e4.png?x-oss-process=image/quality,q_60)\n\n  \n\n### icejs\n\nicejs 是淘系前端飞冰团队开发的一个基于 React 的渐进式框架。支持服务端渲染（即 SSR）能力，开发者可以按需一键开启 SSR 的模式。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/22d57d869b146fd60658513b5e8fff8612abe361aad786f81676cc89c976cf939ce6646016f7462db6581d0438dff974.png?x-oss-process=image/quality,q_60)\n\n  \n\n## 4、一些新的 API\n\n### **新 Hook：useId**\n\n服务端、客户端无法简单生成稳定、唯一的 id 是个由来已久的问题，早在多年前就有人提过 issue。直到最近 React conf 2021 上再次提出这个问题，推出了官方 Hook——useId，可在服务端、客户端生成唯一的 id，其背后的原理—— 每个 id 代表该组件在组件树中的层级结构，具体的就不展开了，有兴趣的可以去了解一下。\n\n### **服务端 suspense**\n\nReact 18 带来了内置支持了 React.lazy 的 全新 SSR 架构, 性能优化的利器。这个架构能很大程度上提升用户体验：对比 React18 之前对整个应用 hydrate，现在可以做到对单个组件 hydrate，带来的一个好处，就是可以设置组件的渲染优先级。对比 code splitting 的优势在于如果同时设置了多个 suspense 组件，但是用户点击了之中某个组件，会优先 hydrate 那个被点击的组件。\n\n![image.png](https://img.bosszhipin.com/beijin/cms/cda4a273b8503555dbac7ea5f13dee4f12abe361aad786f81676cc89c976cf935eab24568ed948479bd4bdc7db2ebfec.png?x-oss-process=image/quality,q_60)\n\n  \n\n## 5、结语\n\n以上就是本文关于 React 服务端渲染 ( SSR )的全部内容， 内容还是比较复杂的 。对于服务端渲染原理的学习可以帮助更好借鉴优秀的程序写法和激发对日常代码编程架构的思考，如果你更倾向箱即用的解决方案，那可以使用现有的 SSR 框架来搭建项目，这些框架的模版抽象和额外的功能扩展可以提供平滑的开箱体验。"
    },
    {
      "id": "自定义Loader",
      "metadata": {
        "permalink": "/自定义Loader",
        "source": "@site/blog/自定义Loader.md",
        "title": "自定义Loader",
        "description": "请输入描述",
        "date": "2023-08-28T08:31:30.799Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 6.79,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "自定义Loader",
          "title": "自定义Loader",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "React服务端渲染",
          "permalink": "/React服务端渲染"
        },
        "nextItem": {
          "title": "webpack打包原理",
          "permalink": "/webpack打包原理"
        }
      },
      "content": "在前面的内容中，我们学习了Webpack的基本知识、常用脚手架和性能优化，虽然说大部分的开发场景社区已经又成熟的模块给我们使用，但是遇到特殊情况还是需要自己有独立开发的能力，因此今天我们一起来学习如何编写自定义Loader。\n\n## 基本Loader\n\nWebpack中loader是一个CommonJs风格的函数，接收输入的源码，通过同步或异步的方式替换源码后进行输出。\n\n```javascript\nmodule.exports = function(source, sourceMap, meta) {\n  \n}\n```\n\n+   source是输入的内容\n+   sourceMap是可选的\n+   meta是模块的元数据，也是可选的\n\n需要注意的是，该导出函数必须使用function，不能使用箭头函数，因为loader编写过程中会经常使用到`this`访问选项和其他方法。\n\n我们先编写一个基本的Loader，完成的工作很简单，那就是把输出的字符串进行替换。\n\n1.新建loader-example目录，执行npm初始化，并安装webpack\n\n```bash\nmkdir loader-example\ncd loadeer-example\nnpm init -y\nnpm install webpack webpack-cli\n```\n\n2.构建项目目录\n\n```auto\n|----loader # loader目录\n        |----replace-loader.js # 替换字符串的Loader\n|----src   # 应用源码\n        |----index.js # 首页\n|----package.json\n|----webpack.config.js\n```\n\n3.编写loader/replace-loader.js\n\n```javascript\nmodule.exports = function(source) {\n  return source.replace(/World/g, 'Loader');\n};\n```\n\n本例中我们Loader只是简单的将源码中的”World“替换成了”Loader“。\n\n4.编写src/index.js\n\n```javascript\nconsole.log('Hello World');\n```\n\n5.编写webpack.config.js\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index',\n  target: 'node', // 我们编译为Node.js环境下的JS，等下直接使用Node.js执行编译完成的文件\n  output:{\n    path: path.resolve(__dirname, 'build'),\n    filename: '[name].js'\n  },\n  module:{\n    rules:[\n      {\n        test:/\\.js$/,\n        use: 'replace-loader'\n      }\n    ]\n  },\n  resolveLoader: {\n      modules: ['./node_modules', './loader'] // 配置loader的查找目录\n  }\n};\n```\n\n6.编写package.json\n\n```json\n{\n  \"scripts\":{\n    \"build\":\"webpack\"\n  }\n}\n```\n\n7.执行构建\n\n```bash\nnpm run build\n```\n\n8.构建完成后，执行build/main.js\n\n```bash\nnode build/main.js\n```\n\n此时终端输出如下，我们编写的Loader工作正常。\n\n```auto\nHello Loader\n```\n\n## Loader选项\n\n我们使用第三方loader时经常可以看到传递选项的情况：\n\n```javascript\n{\n  test:/\\.js$/,\n  use:[\n    {\n      loader:'babel-loader',\n      options:{\n        plugins:['@babel/transform-runtime'],\n        presets:['@babel/env']\n      }\n    }\n  ]\n}\n```\n\n在Loader编写时，Webpack中官方推荐通过loader-utils来读取配置选项，我们需要先安装。\n\n```bash\nnpm install loader-utils\n```\n\n我们给刚才编写的replace-loader传递一个选项，允许自定义替换结果。\n\n```javascript\nconst loaderUtils = require('loader-utils');\n\nmodule.exports = function(source) {\n    const options = loaderUtils.getOptions(this);\n  return source.replace(/World/g, options.text);\n};\n```\n\n接下来编辑webpack.config.js，给replace-loader传递选项。\n\n```javascript\nmodule.exports = {\n  module:{\n    rules:[\n      {\n        test:/\\.js$/,\n        use:[\n          {\n            loader:'replace-loader',\n            options:{\n              text: 'Webpack4'\n            }\n          }\n        ]\n      }\n    ]\n  },\n  resolveLoader:{\n    modules: ['./node_modules', './loader']\n  }\n};\n```\n\n执行构建之后用Node.js执行build/main.js，可以看到输出的内容已经发生变化了。\n\n```auto\nHello Webpack4\n```\n\n## 异步Loader\n\n在Loader中，如果存在异步调用，那么就无法直接通过return返回构建后的结果了，此时需要使用到Webpack提供的回调函数将数据进行回调。\n\nWebpack4给Loader提供了`this.async()`函数，调用之后返回一个callback，callback的签名如下:\n\n```javascript\nfunction callback(\n  err: Error|null,\n  content: string|Buffer,\n  sourceMap?:SourceMap,\n  meta?: any\n)\n```\n\n例如我们需要在loader中调用setTimeout进行等待，则相应的代码如下：\n\n```javascript\nmodule.exports = function(source) {\n  const callback = this.async();\n  setTimeout(() => {\n    const output = source.replace(/World/g, 'Webpack4');\n    callback(null, output);\n  }, 1000);\n}\n```\n\n执行构建，Webpack会等待一秒，然后再输出构建内容，通过Node.js执行构建后的文件，输出如下\n\n```auto\nHello Webpack4\n```\n\n## \"Raw\" Loader\n\n默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 `raw`，loader 可以接收原始的 `Buffer`。比如处理非文本文件时(如图片等等)。\n\n```javascript\nmodule.exports = function(source) {\n  assert(source instanceof Buffer);\n  return someSyncOperation(source);\n};\nmodule.exports.raw = true; // 设置当前Loader为raw loader, webpack会将原始的Buffer对象传入\n```\n\n## 读取loader配置文件\n\nbabel-loader在使用时可以加载.babelrc配置文件来配置plugins和presets，减少了webpack.config.js的代码量，便于维护。接下来我们编写一个i18n-loader，通过读取语言配置文件完成语言转换。\n\n### 项目结构\n\n```auto\n|----loader\n        |----i18n-loader.js # loader\n|----i18n\n        |----zh.json # 中文语言包\n|----src\n        |----index.js # 入口文件\n|----webpack.config.js\n```\n\ni18n/zh.json\n\n```json\n{\n    \"hello\": \"你好\",\n    \"today\": \"今天\"\n}\n```\n\nloader/i18n-loader.js\n\n```javascript\nconst loaderUtils = require('loader-utils');\nconst path = require('path');\n\nmodule.exports = function (source) {\n    const options = loaderUtils.getOptions(this);\n    const locale = options ? options.locale : null;\n\n    // 读取语言配置文件\n    let json = null;\n    if (locale) {\n        const filename = path.resolve(__dirname, '..', 'i18n', `${locale}.json`);\n        json = require(filename);\n    }\n\n    // 读取语言标记 {{}}\n    const matches = source.match(/\\{\\{\\w+\\}\\}/g); \n    for (const match of matches) {\n        const name = match.match(/\\{\\{(\\w+)\\}\\}/)[1].toLowerCase();\n        if (json !== null && json[name] !== undefined) {\n            source = source.replace(match, json[name]);\n        } else {\n            source = source.replace(match, name);\n        }\n    }\n    return source;\n}\n```\n\nsrc/index.js\n\n```javascript\nconsole.log('{{Hello}}, {{Today}} is a good day.');\n```\n\nwebpack.config.js\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n    entry: './src/index',\n    output: {\n        path: path.resolve(__dirname, 'build'),\n        filename: '[name].js'\n    },\n    target: 'node',\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: [\n                    {\n                        loader: 'i18n-loader',\n                        options: { // 传递选项\n                            locale: 'zh'\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    resolveLoader: {\n        modules: ['./node_modules', './loader']\n    }\n};\n```\n\npackage.json\n\n```json\n{\n  \"scripts\":{\n    \"build\":\"webpack\"\n  }\n}\n```\n\n### 执行构建\n\n```auto\nnpm run build\n```\n\n构建完毕后使用Node.js执行build/main.js输出如下：\n\n```auto\n你好, 今天 is a good day.\n```\n\n可以看到i18n-loader成功读取了配置文件。\n\n## 小结\n\n本文简要介绍了Webpack中如何编写一个自定义的loader，权当抛砖引玉，更多的用法等待读者在实际工作中去挖掘，要想掌握Webpack的高级知识，Loader是必不可少的技能，有时候如果社区找不到合适的Loader，大家可以根据需要自己进行开发。"
    },
    {
      "id": "webpack打包原理",
      "metadata": {
        "permalink": "/webpack打包原理",
        "source": "@site/blog/webpack打包原理.md",
        "title": "webpack打包原理",
        "description": "请输入描述",
        "date": "2023-08-28T08:30:06.992Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 18.56,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "webpack打包原理",
          "title": "webpack打包原理",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "自定义Loader",
          "permalink": "/自定义Loader"
        },
        "nextItem": {
          "title": "理解BFC原理",
          "permalink": "/理解BFC原理"
        }
      },
      "content": "## 什么是 webpack ?\n\n> 本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。\n> \n> webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。  \n> webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。 -- 深入浅出 webpack 吴浩麟\n\n![webpack.png](https://segmentfault.com/img/bVbq0Zk \"webpack.png\")\n\n## webpack 核心概念\n\n### Entry\n\n入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。\n\n进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。\n\n每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。\n\n### Output\n\noutput 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。\n\n基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。\n\n### Module\n\n模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。\n\n### Chunk\n\n代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。\n\n### Loader\n\nloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。\n\nloader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。\n\n本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。\n\n### Plugin\n\nloader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。\n\n插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。\n\n## webpack 构建流程\n\nWebpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :\n\n1.  初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。\n2.  开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。\n3.  确定入口：根据配置中的 entry 找出所有的入口文件。\n4.  编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。\n5.  完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。\n6.  输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。\n7.  输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。\n\n在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n\n## 实践加深理解,撸一个简易 webpack\n\n### 1\\. 定义 Compiler 类\n\n```js\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {}\n  // 重写 require函数,输出bundle\n  generate() {}\n}\n```\n\n### 2\\. 解析入口文件,获取 AST\n\n我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。\n\n```js\n// webpack.config.js\n\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'main.js'\n  }\n}\n//\n```\n\n```js\nconst fs = require('fs')\nconst parser = require('@babel/parser')\nconst options = require('./webpack.config')\n\nconst Parser = {\n  getAst: path => {\n    // 读取入口文件\n    const content = fs.readFileSync(path, 'utf-8')\n    // 将文件内容转为AST抽象语法树\n    return parser.parse(content, {\n      sourceType: 'module'\n    })\n  }\n}\n\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {\n    const ast = Parser.getAst(this.entry)\n  }\n  // 重写 require函数,输出bundle\n  generate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 3\\. 找出所有依赖模块\n\nBabel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\n\nconst Parser = {\n  getAst: path => {\n    // 读取入口文件\n    const content = fs.readFileSync(path, 'utf-8')\n    // 将文件内容转为AST抽象语法树\n    return parser.parse(content, {\n      sourceType: 'module'\n    })\n  },\n  getDependecies: (ast, filename) => {\n    const dependecies = {}\n    // 遍历所有的 import 模块,存入dependecies\n    traverse(ast, {\n      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n      ImportDeclaration({ node }) {\n        const dirname = path.dirname(filename)\n        // 保存依赖模块路径,之后生成依赖关系图需要用到\n        const filepath = './' + path.join(dirname, node.source.value)\n        dependecies[node.source.value] = filepath\n      }\n    })\n    return dependecies\n  }\n}\n\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {\n    const { getAst, getDependecies } = Parser\n    const ast = getAst(this.entry)\n    const dependecies = getDependecies(ast, this.entry)\n  }\n  // 重写 require函数,输出bundle\n  generate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 4\\. AST 转换为 code\n\n将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\nconst Parser = {\n  getAst: path => {\n    // 读取入口文件\n    const content = fs.readFileSync(path, 'utf-8')\n    // 将文件内容转为AST抽象语法树\n    return parser.parse(content, {\n      sourceType: 'module'\n    })\n  },\n  getDependecies: (ast, filename) => {\n    const dependecies = {}\n    // 遍历所有的 import 模块,存入dependecies\n    traverse(ast, {\n      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n      ImportDeclaration({ node }) {\n        const dirname = path.dirname(filename)\n        // 保存依赖模块路径,之后生成依赖关系图需要用到\n        const filepath = './' + path.join(dirname, node.source.value)\n        dependecies[node.source.value] = filepath\n      }\n    })\n    return dependecies\n  },\n  getCode: ast => {\n    // AST转换为code\n    const { code } = transformFromAst(ast, null, {\n      presets: ['@babel/preset-env']\n    })\n    return code\n  }\n}\n\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {\n    const { getAst, getDependecies, getCode } = Parser\n    const ast = getAst(this.entry)\n    const dependecies = getDependecies(ast, this.entry)\n    const code = getCode(ast)\n  }\n  // 重写 require函数,输出bundle\n  generate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 5\\. 递归解析所有依赖项,生成依赖关系图\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\nconst Parser = {\n  getAst: path => {\n    // 读取入口文件\n    const content = fs.readFileSync(path, 'utf-8')\n    // 将文件内容转为AST抽象语法树\n    return parser.parse(content, {\n      sourceType: 'module'\n    })\n  },\n  getDependecies: (ast, filename) => {\n    const dependecies = {}\n    // 遍历所有的 import 模块,存入dependecies\n    traverse(ast, {\n      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n      ImportDeclaration({ node }) {\n        const dirname = path.dirname(filename)\n        // 保存依赖模块路径,之后生成依赖关系图需要用到\n        const filepath = './' + path.join(dirname, node.source.value)\n        dependecies[node.source.value] = filepath\n      }\n    })\n    return dependecies\n  },\n  getCode: ast => {\n    // AST转换为code\n    const { code } = transformFromAst(ast, null, {\n      presets: ['@babel/preset-env']\n    })\n    return code\n  }\n}\n\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {\n    // 解析入口文件\n    const info = this.build(this.entry)\n    this.modules.push(info)\n    this.modules.forEach(({ dependecies }) => {\n      // 判断有依赖对象,递归解析所有依赖项\n      if (dependecies) {\n        for (const dependency in dependecies) {\n          this.modules.push(this.build(dependecies[dependency]))\n        }\n      }\n    })\n    // 生成依赖关系图\n    const dependencyGraph = this.modules.reduce(\n      (graph, item) => ({\n        ...graph,\n        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容\n        [item.filename]: {\n          dependecies: item.dependecies,\n          code: item.code\n        }\n      }),\n      {}\n    )\n  }\n  build(filename) {\n    const { getAst, getDependecies, getCode } = Parser\n    const ast = getAst(filename)\n    const dependecies = getDependecies(ast, filename)\n    const code = getCode(ast)\n    return {\n      // 文件路径,可以作为每个模块的唯一标识符\n      filename,\n      // 依赖对象,保存着依赖模块路径\n      dependecies,\n      // 文件内容\n      code\n    }\n  }\n  // 重写 require函数,输出bundle\n  generate() {}\n}\n\nnew Compiler(options).run()\n```\n\n### 6\\. 重写 require 函数,输出 bundle\n\n```js\nconst fs = require('fs')\nconst path = require('path')\nconst options = require('./webpack.config')\nconst parser = require('@babel/parser')\nconst traverse = require('@babel/traverse').default\nconst { transformFromAst } = require('@babel/core')\n\nconst Parser = {\n  getAst: path => {\n    // 读取入口文件\n    const content = fs.readFileSync(path, 'utf-8')\n    // 将文件内容转为AST抽象语法树\n    return parser.parse(content, {\n      sourceType: 'module'\n    })\n  },\n  getDependecies: (ast, filename) => {\n    const dependecies = {}\n    // 遍历所有的 import 模块,存入dependecies\n    traverse(ast, {\n      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)\n      ImportDeclaration({ node }) {\n        const dirname = path.dirname(filename)\n        // 保存依赖模块路径,之后生成依赖关系图需要用到\n        const filepath = './' + path.join(dirname, node.source.value)\n        dependecies[node.source.value] = filepath\n      }\n    })\n    return dependecies\n  },\n  getCode: ast => {\n    // AST转换为code\n    const { code } = transformFromAst(ast, null, {\n      presets: ['@babel/preset-env']\n    })\n    return code\n  }\n}\n\nclass Compiler {\n  constructor(options) {\n    // webpack 配置\n    const { entry, output } = options\n    // 入口\n    this.entry = entry\n    // 出口\n    this.output = output\n    // 模块\n    this.modules = []\n  }\n  // 构建启动\n  run() {\n    // 解析入口文件\n    const info = this.build(this.entry)\n    this.modules.push(info)\n    this.modules.forEach(({ dependecies }) => {\n      // 判断有依赖对象,递归解析所有依赖项\n      if (dependecies) {\n        for (const dependency in dependecies) {\n          this.modules.push(this.build(dependecies[dependency]))\n        }\n      }\n    })\n    // 生成依赖关系图\n    const dependencyGraph = this.modules.reduce(\n      (graph, item) => ({\n        ...graph,\n        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容\n        [item.filename]: {\n          dependecies: item.dependecies,\n          code: item.code\n        }\n      }),\n      {}\n    )\n    this.generate(dependencyGraph)\n  }\n  build(filename) {\n    const { getAst, getDependecies, getCode } = Parser\n    const ast = getAst(filename)\n    const dependecies = getDependecies(ast, filename)\n    const code = getCode(ast)\n    return {\n      // 文件路径,可以作为每个模块的唯一标识符\n      filename,\n      // 依赖对象,保存着依赖模块路径\n      dependecies,\n      // 文件内容\n      code\n    }\n  }\n  // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle\n  generate(code) {\n    // 输出文件路径\n    const filePath = path.join(this.output.path, this.output.filename)\n    // 懵逼了吗? 没事,下一节我们捋一捋\n    const bundle = `(function(graph){\n      function require(module){\n        function localRequire(relativePath){\n          return require(graph[module].dependecies[relativePath])\n        }\n        var exports = {};\n        (function(require,exports,code){\n          eval(code)\n        })(localRequire,exports,graph[module].code);\n        return exports;\n      }\n      require('${this.entry}')\n    })(${JSON.stringify(code)})`\n\n    // 把文件内容写入到文件系统\n    fs.writeFileSync(filePath, bundle, 'utf-8')\n  }\n}\n\nnew Compiler(options).run()\n```\n\n### 7\\. 看完这节,彻底搞懂 bundle 实现\n\n我们通过下面的例子来进行讲解,先死亡凝视 30 秒\n\n```js\n;(function(graph) {\n  function require(moduleId) {\n    function localRequire(relativePath) {\n      return require(graph[moduleId].dependecies[relativePath])\n    }\n    var exports = {}\n    ;(function(require, exports, code) {\n      eval(code)\n    })(localRequire, exports, graph[moduleId].code)\n    return exports\n  }\n  require('./src/index.js')\n})({\n  './src/index.js': {\n    dependecies: { './hello.js': './src/hello.js' },\n    code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));'\n  },\n  './src/hello.js': {\n    dependecies: {},\n    code:\n      '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n  value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n  return \"hello \".concat(name);\\n}'\n  }\n})\n```\n\n#### step 1 : 从入口文件开始执行\n\n```js\n// 定义一个立即执行函数,传入生成的依赖关系图\n;(function(graph) {\n  // 重写require函数\n  function require(moduleId) {\n    console.log(moduleId) // ./src/index.js\n  }\n  // 从入口文件开始执行\n  require('./src/index.js')\n})({\n  './src/index.js': {\n    dependecies: { './hello.js': './src/hello.js' },\n    code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));'\n  },\n  './src/hello.js': {\n    dependecies: {},\n    code:\n      '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n  value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n  return \"hello \".concat(name);\\n}'\n  }\n})\n```\n\n#### step 2 : 使用 eval 执行代码\n\n```js\n// 定义一个立即执行函数,传入生成的依赖关系图\n;(function(graph) {\n  // 重写require函数\n  function require(moduleId) {\n    ;(function(code) {\n      console.log(code) // \"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));\n      eval(code) // Uncaught TypeError: Cannot read property 'code' of undefined\n    })(graph[moduleId].code)\n  }\n  // 从入口文件开始执行\n  require('./src/index.js')\n})({\n  './src/index.js': {\n    dependecies: { './hello.js': './src/hello.js' },\n    code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));'\n  },\n  './src/hello.js': {\n    dependecies: {},\n    code:\n      '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n  value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n  return \"hello \".concat(name);\\n}'\n  }\n})\n```\n\n可以看到,我们在执行\"./src/index.js\"文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。\n\n#### step 3 : 依赖对象寻址映射,获取 exports 对象\n\n```js\n// 定义一个立即执行函数,传入生成的依赖关系图\n;(function(graph) {\n  // 重写require函数\n  function require(moduleId) {\n    // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象\n    function localRequire(relativePath) {\n      return require(graph[moduleId].dependecies[relativePath]) // {__esModule: true, say: ƒ say(name)}\n    }\n    // 定义exports对象\n    var exports = {}\n    ;(function(require, exports, code) {\n      // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入\n      eval(code)\n    })(localRequire, exports, graph[moduleId].code)\n    // 暴露exports对象,即暴露依赖对象对应的实现\n    return exports\n  }\n  // 从入口文件开始执行\n  require('./src/index.js')\n})({\n  './src/index.js': {\n    dependecies: { './hello.js': './src/hello.js' },\n    code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));'\n  },\n  './src/hello.js': {\n    dependecies: {},\n    code:\n      '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n  value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n  return \"hello \".concat(name);\\n}'\n  }\n})\n```\n\n这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~\n\n[完整代码地址戳我 👈](https://link.segmentfault.com/?enc=4S8j8llRndonbUIEKHtsdg%3D%3D.FKZIc1Tc%2BiaZGADXws%2FoxPPnD9ID4BMnXcfAV7nmX9DAshttT9GD0oBAt2VVBF0WALOrM95XoCHT3Fa6F%2Fy%2FDA%3D%3D)\n\n## 总结\n\n> Webpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。\n> \n> 对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。\n> \n> Webpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。\n\n## 参考\n\n[webpack 中文文档](https://link.segmentfault.com/?enc=U3kIfgVhX9Zh7ylXRLVxEA%3D%3D.X5RJSUm5Ujhn1ZdMRYZ7hYvaMpXhYliMJD%2FYVi4Sah8%3D)\n\n[深入浅出 webpack](https://link.segmentfault.com/?enc=r6AV0egvbLuW5P9IZJ7rsg%3D%3D.X3RwHsItiGDMwRgzQxCEyXJ0oclwkdBb5NWvrUg4XVU%3D)"
    },
    {
      "id": "理解BFC原理",
      "metadata": {
        "permalink": "/理解BFC原理",
        "source": "@site/blog/理解BFC原理.md",
        "title": "理解BFC原理",
        "description": "请输入描述",
        "date": "2023-08-28T08:29:28.840Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 5.425,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "理解BFC原理",
          "title": "理解BFC原理",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "webpack打包原理",
          "permalink": "/webpack打包原理"
        },
        "nextItem": {
          "title": "深入理解webpack自动刷新浏览器",
          "permalink": "/深入理解webpack自动刷新浏览器"
        }
      },
      "content": "## 一、常见定位方案\n\n在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:  \n\n+   普通流 (normal flow)  \n    \n\n> 在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。\n\n+   浮动 (float)  \n    \n\n> 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。\n\n+   绝对定位 (absolute positioning)\n\n> 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\n\n## 二、BFC 概念\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n那么 BFC 是什么呢？  \n\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。  \n\n**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  \n**\n\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。  \n\n## 三、触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n+   body 根元素\n+   浮动元素：float 除 none 以外的值\n+   绝对定位元素：position (absolute、fixed)\n+   display 为 inline-block、table-cells、flex\n+   overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n## 四、BFC 特性及应用\n\n**1\\. 同一个 BFC 下外边距会发生折叠**\n\n  \n\n```html\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n```\n\n![](https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_b.png)\n\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n\n首先这不是 CSS 的 bug，我们可以理解为一种规范，**如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。**\n\n```html\n<div class=\"container\">\n    <p></p>\n</div>\n<div class=\"container\">\n    <p></p>\n</div>\n```\n\n```css\n.container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n```\n\n这时候，两个盒子边距就变成了 200px  \n\n![](https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_b.png)\n\n**2\\. BFC 可以包含浮动的元素（清除浮动）**\n\n我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子  \n\n```html\n<div style=\"border: 1px solid #000;\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n![](https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_b.png)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。\n\n```html\n<div style=\"border: 1px solid #000;overflow: hidden\">\n    <div style=\"width: 100px;height: 100px;background: #eee;float: left;\"></div>\n</div>\n```\n\n效果如图：\n\n![](https://pic4.zhimg.com/v2-cc8365db5c9cc5ca003ce9afe88592e7_b.png)\n\n**3\\. BFC 可以阻止元素被浮动元素覆盖**\n\n先来看一个文字环绕效果：  \n\n```html\n<div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n<div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动, \n也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>\n```\n\n![](https://pic4.zhimg.com/v2-dd3e636d73682140bf4a781bcd6f576b_b.png)\n\n这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：\n\n![](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_b.png)\n\n这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。"
    },
    {
      "id": "深入理解webpack自动刷新浏览器",
      "metadata": {
        "permalink": "/深入理解webpack自动刷新浏览器",
        "source": "@site/blog/深入理解webpack自动刷新浏览器.md",
        "title": "深入理解webpack自动刷新浏览器",
        "description": "请输入描述",
        "date": "2023-08-28T08:28:24.263Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 6.19,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "深入理解webpack自动刷新浏览器",
          "title": "深入理解webpack自动刷新浏览器",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "理解BFC原理",
          "permalink": "/理解BFC原理"
        },
        "nextItem": {
          "title": "前端模块化详解",
          "permalink": "/前端模块化详解"
        }
      },
      "content": "我们在日常开发时，有一个需要在开发状态下的优化，就是**浏览器能自动显示修改后的代码，而无需我们手动刷新**\n\n## 1\\. 自动刷新浏览器\n\n为了能实现浏览器自动刷新，需要做两件事情:\n\n+   监听文件变化\n+   自动刷新浏览器\n\n### 1.1 监听文件变化\n\n监听文件变化是在webpack模块进行。\n\n#### 1.1.1 方式\n\n需要在webpack中开启监听模式，有两种方式（**开启监听模式后，可以设置监听相关配置watchOptions**）：\n\n**1\\. 在webpack配置文件中添加watch:true**\n\n```javascript\nmodule.export = {\n  watch: true,\n  watchOptions: {\n    // 不监听的文件或文件夹\n    ignored: /node_modules/,\n    // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高  \n    aggregateTimeout: 300,  \n    // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的\n    poll: 1000\n  }\n}\n```\n\n**2\\. 在执行启动 Webpack 命令时，带上 --watch 参数**\n\n#### 1.1.2 原理\n\n+   在 Webpack 中监听一个文件发生变化的原理是**定时**（**可在watchOptions.poll中设置**）的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，**如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化**\n+   当发现某个文件发生了变化时，并不会立刻告诉监听者，而是先缓存起来，收集**一段时间**(**可在watchOptions.aggregateTimeout中设置**)的变化后，再一次性告诉监听者。防止在编辑代码的过程中可能会高频的输入文字导致文件变化的事件高频的发生\n\n### 1.2 自动刷新浏览器\n\n监听到文件变化后需要去刷新浏览器，这部分在webpack-dev-server模块中进行。(**在使用 webpack-dev-server 模块去启动 webpack 模块时，webpack 模块的监听模式默认会被开启**)\n\n#### 1.2.1 原理\n\n自动刷新有三种方法：\n\n+   借助浏览器扩展去通过浏览器提供的接口刷新\n+   往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。\n+   把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。\n\nDevServer 支持第2、3种方法，第2种是 DevServer 默认采用的刷新方法。\n\n## 2\\. 模块热更新\n\n以上自动刷新是会刷新整个页面，这种方式的缺点就是时间长，同时不能保存页面的状态。\n\n而模块热更新即可在不刷新整个页面的情况下来实时预览。它只会在代码发生变化时，只编译发生变化的模块，并替换浏览器中的老模块。\n\n### 2.1 两种方式\n\n以下两种方式都能实现模块热替换，区别在于其内部使用的通信方式不同。前者使用webcoket通信，后者使用eventSource通信。\n\n#### 2.1.1 webpack-dev-server\n\n**1\\. 开启方式**\n\n+   开启DevServer的模块热替换模式： webpack-dev-server --hot\n+   添加HotModuleReplacementPlugin插件\n\n**2\\. 原理**\n\n[参考](https://link.segmentfault.com/?enc=ktxfoF77pOArOQikjflVcw%3D%3D.UujWfZWOVIzovPYco%2BYXpY97BoyFd0Mfp2gl9x9STc0lpCVWRMgpLUPgkU0wKUT7)  \n**（1）webpack 对文件系统进行 watch 打包到内存中**\n\n+   依赖**webpack-dev-middleware**，它会调用 webpack 的 api 对文件系统 watch\n+   webpack-dev-middleware依赖**memory-fs库**，它将webpack 原本的 outputFileSystem 替换成了MemoryFileSystem 实例，这样代码就将输出到内存中\n\n**（2）devServer 通知浏览器端文件发生改变**\\~~~~\n\n+   在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 **webSocket 长连接**。\n+   webpack-dev-server 调用 webpack api监听 compile的 done 事件，将编译打包后的**新模块 hash 值发送到浏览器端**。\n\n**（3）webpack-dev-server/client 接收到服务端消息做出响应**\n\n+   webpack-dev-server默认**修改了webpack 配置中的 entry 属性**，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n+   webpack-dev-server/client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后**对应用执行 reload 操作**(根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）).\n\n**（4）webpack 接收到最新 hash 值验证并请求模块代码**\n\n+   webpack/hot/dev-server监听webpack-dev-server/client发出的webpackHotUpdate 消息。\n+   先调用hotDownloadManifest（ajax请求）来获取更新的文件列表。\n+   再调用hotDownloadUpdateChunk获取更新的新模块代码\n\n**（5）HotModuleReplacement.runtime 对模块进行热更新**\n\n+   找出过期的模块和过期的依赖\n+   从缓存中删除过期的模块和依赖\n+   将新的模块添加到 modules 中\n\n#### 2.1.2 webpack-hot-middleware\n\n**1\\. 开启方式**\n\n+   Webpack配置添加HotModuleReplacementPlugin插件\n+   Node Server引入webpack-dev-middlerware 和 webpack-hot-middleware插件（本人参与的项目中用到的是koa-webpack-middleware）\n+   entry中注入热更新代码(必须要注入。为了保证服务端和客户端能够通信)  \n    **webpack-hot-middleware/client?path=/\\_\\_webpack\\_hmr&timeout=20000**\n\n**2\\. 原理**  \n[原理参考](https://link.segmentfault.com/?enc=aHn8M0e%2Fth3Xmvbq%2BSWUOw%3D%3D.E8ZpVNG1LMrwp7J4O3sDuwaEWLYZCYqs4UmzrWkDM99JICzArtXzMwVsjV0fNOJy)"
    },
    {
      "id": "前端模块化详解",
      "metadata": {
        "permalink": "/前端模块化详解",
        "source": "@site/blog/前端模块化详解.md",
        "title": "前端模块化详解",
        "description": "请输入描述",
        "date": "2023-08-28T08:27:38.539Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 24.43,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "前端模块化详解",
          "title": "前端模块化详解",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "深入理解webpack自动刷新浏览器",
          "permalink": "/深入理解webpack自动刷新浏览器"
        },
        "nextItem": {
          "title": "浏览器的回流与重绘Reflow-Repaint",
          "permalink": "/浏览器的回流与重绘Reflow-Repaint"
        }
      },
      "content": "<!-- truncate -->\n\n\n## 前言\n\n在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。 本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的CommonJS, AMD, ES6、CMD规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！\n\n**建议下载本文源代码，自己动手敲一遍，请猛戳[GitHub个人博客(全集)](https://github.com/ljianshu/Blog \"https://github.com/ljianshu/Blog\")**\n\n![模块化规范](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/16/167b650e8d1fcc23~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n## 一、模块化的理解\n\n### 1.什么是模块?\n\n+   将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起\n+   块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n\n### 2.模块化的进化过程\n\n+   **全局function模式 : 将不同的功能封装成不同的全局函数**\n    +   编码: 将不同的功能封装成不同的全局函数\n    +   问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系\n\n```auto\nfunction m1(){\n  //...\n}\nfunction m2(){\n  //...\n}\n```\n\n+   **namespace模式 : 简单对象封装**\n    +   作用: 减少了全局变量，解决命名冲突\n    +   问题: 数据不安全(外部可以直接修改模块内部的数据)\n\n```auto\nlet myModule = {\n  data: 'www.baidu.com',\n  foo() {\n    console.log(`foo() ${this.data}`)\n  },\n  bar() {\n    console.log(`bar() ${this.data}`)\n  }\n}\nmyModule.data = 'other data' //能直接修改模块内部的数据\nmyModule.foo() // foo() other data\n```\n\n这样的写法会暴露所有模块成员，内部状态可以被外部改写。\n\n+   **IIFE模式：匿名函数自调用(闭包)**\n    +   作用: 数据是私有的, 外部只能通过暴露的方法操作\n    +   编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口\n    +   问题: 如果当前这个模块依赖另一个模块怎么办?\n\n```auto\n// index.html文件\n<script type=\"text/javascript\" src=\"module.js\"></script>\n<script type=\"text/javascript\">\n    myModule.foo()\n    myModule.bar()\n    console.log(myModule.data) //undefined 不能访问模块内部数据\n    myModule.data = 'xxxx' //不是修改的模块内部的data\n    myModule.foo() //没有改变\n</script>\n```\n\n```auto\n// module.js文件\n(function(window) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar } //ES6写法\n})(window)\n```\n\n最后得到的结果：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/16793716ec47b94d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n+   **IIFE模式增强 : 引入依赖**\n\n这就是现代模块实现的基石\n\n```auto\n// module.js文件\n(function(window, $) {\n  let data = 'www.baidu.com'\n  //操作数据的函数\n  function foo() {\n    //用于暴露有函数\n    console.log(`foo() ${data}`)\n    $('body').css('background', 'red')\n  }\n  function bar() {\n    //用于暴露有函数\n    console.log(`bar() ${data}`)\n    otherFun() //内部调用\n  }\n  function otherFun() {\n    //内部私有的函数\n    console.log('otherFun()')\n  }\n  //暴露行为\n  window.myModule = { foo, bar }\n})(window, jQuery)\n```\n\n```auto\n // index.html文件\n  <!-- 引入的js必须有一定顺序 -->\n  <script type=\"text/javascript\" src=\"jquery-1.10.1.js\"></script>\n  <script type=\"text/javascript\" src=\"module.js\"></script>\n  <script type=\"text/javascript\">\n    myModule.foo()\n  </script>\n```\n\n上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**。\n\n### 3\\. 模块化的好处\n\n+   避免命名冲突(减少命名空间污染)\n+   更好的分离, 按需加载\n+   更高复用性\n+   高可维护性\n\n### 4\\. 引入多个`<script>`后出现出现问题\n\n+   请求过多\n\n首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\n\n+   依赖模糊\n\n我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\n\n+   难以维护\n\n以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。 模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的commonjs, AMD, ES6, CMD规范。\n\n## 二、模块化规范\n\n### 1.CommonJS\n\n#### (1)概述\n\nNode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**\n\n#### (2)特点\n\n+   所有代码都运行在模块作用域，不会污染全局作用域。\n+   模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n+   模块加载的顺序，按照其在代码中出现的顺序。\n\n#### (3)基本语法\n\n+   暴露模块：`module.exports = value`或`exports.xxx = value`\n+   引入模块：`require(xxx)`,如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径\n\n此处我们有个疑问：**CommonJS暴露的模块到底是什么?** CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。**加载某个模块，其实是加载该模块的module.exports属性**。\n\n```auto\n// example.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n```\n\n上面代码通过module.exports输出变量x和函数addX。\n\n```auto\nvar example = require('./example.js');//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n```\n\nrequire命令用于加载模块文件。**require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**。\n\n#### (4)模块的加载机制\n\n**CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值**。这点与ES6模块化有重大差异（下文会介绍），请看下面这个例子：\n\n```auto\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n```\n\n上面代码输出内部变量counter和改写这个变量的内部方法incCounter。\n\n```auto\n// main.js\nvar counter = require('./lib').counter;\nvar incCounter = require('./lib').incCounter;\n\nconsole.log(counter);  // 3\nincCounter();\nconsole.log(counter); // 3\n```\n\n上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。**这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值**。\n\n#### (5)服务器端实现\n\n#### ①下载安装node.js\n\n#### ②创建项目结构\n\n**注意：用npm init 自动生成package.json时，package name(包名)不能有中文和大写**\n\n```auto\n|-modules\n  |-module1.js\n  |-module2.js\n  |-module3.js\n|-app.js\n|-package.json\n  {\n    \"name\": \"commonJS-node\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ③下载第三方模块\n\n`npm install uniq --save // 用于数组去重`\n\n#### ④定义模块代码\n\n```auto\n//module1.js\nmodule.exports = {\n  msg: 'module1',\n  foo() {\n    console.log(this.msg)\n  }\n}\n```\n\n```auto\n//module2.js\nmodule.exports = function() {\n  console.log('module2')\n}\n```\n\n```auto\n//module3.js\nexports.foo = function() {\n  console.log('foo() module3')\n}\nexports.arr = [1, 2, 3, 3, 2]\n```\n\n```auto\n// app.js文件\n// 引入第三方库，应该放置在最前面\nlet uniq = require('uniq')\nlet module1 = require('./modules/module1')\nlet module2 = require('./modules/module2')\nlet module3 = require('./modules/module3')\n\nmodule1.foo() //module1\nmodule2() //module2\nmodule3.foo() //foo() module3\nconsole.log(uniq(module3.arr)) //[ 1, 2, 3 ]\n```\n\n#### ⑤通过node运行app.js\n\n命令行输入`node app.js`，运行JS文件\n\n#### (6)浏览器端实现(借助Browserify)\n\n#### ①创建项目结构\n\n```auto\n|-js\n  |-dist //打包生成文件的目录\n  |-src //源码所在的目录\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-app.js //应用主源文件\n|-index.html //运行于浏览器上\n|-package.json\n  {\n    \"name\": \"browserify-test\",\n    \"version\": \"1.0.0\"\n  }\n```\n\n#### ②下载browserify\n\n+   全局: npm install browserify -g\n+   局部: npm install browserify --save-dev\n\n#### ③定义模块代码(同服务器端)\n\n注意：`index.html`文件要运行在浏览器上，需要借助browserify将`app.js`文件打包编译，如果直接在`index.html`引入`app.js`就会报错！\n\n#### ④打包处理js\n\n根目录下运行`browserify js/src/app.js -o js/dist/bundle.js`\n\n#### ⑤页面使用引入\n\n在index.html文件中引入`<script type=\"text/javascript\" src=\"js/dist/bundle.js\"></script>`\n\n### 2.AMD\n\nCommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**。此外AMD规范比CommonJS规范在浏览器端实现要来着早。\n\n#### (1)AMD规范基本语法\n\n**定义暴露模块**:\n\n```auto\n//定义没有依赖的模块\ndefine(function(){\n   return 模块\n})\n```\n\n```auto\n//定义有依赖的模块\ndefine(['module1', 'module2'], function(m1, m2){\n   return 模块\n})\n```\n\n**引入使用模块**:\n\n```auto\nrequire(['module1', 'module2'], function(m1, m2){\n   使用m1/m2\n})\n```\n\n#### (2)未使用AMD规范与使用require.js\n\n通过比较两者的实现方法，来说明使用AMD规范的好处。\n\n+   未使用AMD规范\n\n```auto\n// dataService.js文件\n(function (window) {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  window.dataService = {getMsg}\n})(window)\n```\n\n```auto\n// alerter.js文件\n(function (window, dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  window.alerter = {showMsg}\n})(window, dataService)\n```\n\n```auto\n// main.js文件\n(function (alerter) {\n  alerter.showMsg()\n})(alerter)\n```\n\n```auto\n// index.html文件\n<div><h1>Modular Demo 1: 未使用AMD(require.js)</h1></div>\n<script type=\"text/javascript\" src=\"js/modules/dataService.js\"></script>\n<script type=\"text/javascript\" src=\"js/modules/alerter.js\"></script>\n<script type=\"text/javascript\" src=\"js/main.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/15/167b0f75e105b894~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n这种方式缺点很明显：**首先会发送多个请求，其次引入的js文件顺序不能搞错，否则会报错！**\n\n+   使用require.js\n\nRequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，**RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载**。 接下来介绍AMD规范在浏览器实现的步骤：\n\n#### ①下载require.js, 并引入\n\n+   官网: `http://www.requirejs.cn/`\n+   github : `https://github.com/requirejs/requirejs`\n\n然后将require.js导入项目: js/libs/require.js\n\n#### ②创建项目结构\n\n```auto\n|-js\n  |-libs\n    |-require.js\n  |-modules\n    |-alerter.js\n    |-dataService.js\n  |-main.js\n|-index.html\n```\n\n#### ③定义require.js的模块代码\n\n```auto\n// dataService.js文件\n// 定义没有依赖的模块\ndefine(function() {\n  let msg = 'www.baidu.com'\n  function getMsg() {\n    return msg.toUpperCase()\n  }\n  return { getMsg } // 暴露模块\n})\n```\n\n```auto\n//alerter.js文件\n// 定义有依赖的模块\ndefine(['dataService'], function(dataService) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```auto\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //映射: 模块标识名: 路径\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService'\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n```auto\n// index.html文件\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Modular Demo</title>\n  </head>\n  <body>\n    <!-- 引入require.js并指定js主文件的入口 -->\n    <script data-main=\"js/main\" src=\"js/libs/require.js\"></script>\n  </body>\n</html>\n```\n\n#### ④页面引入require.js模块:\n\n在index.html引入 `<script data-main=\"js/main\" src=\"js/libs/require.js\"></script>`\n\n**此外在项目中如何引入第三方库**？只需在上面代码的基础稍作修改：\n\n```auto\n// alerter.js文件\ndefine(['dataService', 'jquery'], function(dataService, $) {\n  let name = 'Tom'\n  function showMsg() {\n    alert(dataService.getMsg() + ', ' + name)\n  }\n  $('body').css('background', 'green')\n  // 暴露模块\n  return { showMsg }\n})\n```\n\n```auto\n// main.js文件\n(function() {\n  require.config({\n    baseUrl: 'js/', //基本路径 出发点在根目录下\n    paths: {\n      //自定义模块\n      alerter: './modules/alerter', //此处不能写成alerter.js,会报错\n      dataService: './modules/dataService',\n      // 第三方库模块\n      jquery: './libs/jquery-1.10.1' //注意：写成jQuery会报错\n    }\n  })\n  require(['alerter'], function(alerter) {\n    alerter.showMsg()\n  })\n})()\n```\n\n上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。 **小结**：通过两者的比较，可以得出**AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系**。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。\n\n### 3.CMD\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。\n\n#### (1)CMD规范基本语法\n\n**定义暴露模块：**\n\n```auto\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n```\n\n```auto\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n```\n\n**引入使用模块：**\n\n```auto\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### (2)sea.js简单使用教程\n\n#### ①下载sea.js, 并引入\n\n+   官网: [seajs.org/](http://seajs.org/ \"http://seajs.org/\")\n+   github : [github.com/seajs/seajs](https://github.com/seajs/seajs \"https://github.com/seajs/seajs\")\n\n然后将sea.js导入项目: js/libs/sea.js\n\n#### ②创建项目结构\n\n```auto\n|-js\n  |-libs\n    |-sea.js\n  |-modules\n    |-module1.js\n    |-module2.js\n    |-module3.js\n    |-module4.js\n    |-main.js\n|-index.html\n```\n\n#### ③定义sea.js的模块代码\n\n```auto\n// module1.js文件\ndefine(function (require, exports, module) {\n  //内部变量数据\n  var data = 'atguigu.com'\n  //内部函数\n  function show() {\n    console.log('module1 show() ' + data)\n  }\n  //向外暴露\n  exports.show = show\n})\n```\n\n```auto\n// module2.js文件\ndefine(function (require, exports, module) {\n  module.exports = {\n    msg: 'I Will Back'\n  }\n})\n```\n\n```auto\n// module3.js文件\ndefine(function(require, exports, module) {\n  const API_KEY = 'abc123'\n  exports.API_KEY = API_KEY\n})\n```\n\n```auto\n// module4.js文件\ndefine(function (require, exports, module) {\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  function show() {\n    console.log('module4 show() ' + module2.msg)\n  }\n  exports.show = show\n  //引入依赖模块(异步)\n  require.async('./module3', function (m3) {\n    console.log('异步引入依赖模块3  ' + m3.API_KEY)\n  })\n})\n```\n\n```auto\n// main.js文件\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n```\n\n#### ④在index.html中引入\n\n```auto\n<script type=\"text/javascript\" src=\"js/libs/sea.js\"></script>\n<script type=\"text/javascript\">\n  seajs.use('./js/modules/main')\n</script>\n```\n\n最后得到结果如下：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/16/167b650e8d5b9e3e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n### 4.ES6模块化\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n\n#### (1)ES6模块化语法\n\nexport命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n```auto\n/** 定义模块 math.js **/\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n/** 引用模块 **/\nimport { basicNum, add } from './math';\nfunction test(ele) {\n    ele.textContent = add(99 + basicNum);\n}\n```\n\n如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\n```auto\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n```auto\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n\n#### (2)ES6 模块与 CommonJS 模块的差异\n\n它们有两个重大差异：\n\n**① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**。\n\n**② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口**。\n\n第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:\n\n```auto\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\nES6 模块的运行机制与 CommonJS 不一样。**ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。\n\n#### (3) ES6-Babel-Browserify使用教程\n\n简单来说就一句话：**使用Babel将ES6编译为ES5代码，使用Browserify编译打包js**。\n\n#### ①定义package.json文件\n\n```auto\n {\n   \"name\" : \"es6-babel-browserify\",\n   \"version\" : \"1.0.0\"\n }\n```\n\n#### ②安装babel-cli, babel-preset-es2015和browserify\n\n+   npm install babel-cli browserify -g\n+   npm install babel-preset-es2015 --save-dev\n+   preset 预设(将es6转换成es5的所有插件打包)\n\n#### ③定义.babelrc文件\n\n```auto\n  {\n    \"presets\": [\"es2015\"]\n  }\n```\n\n#### ④定义模块代码\n\n```auto\n//module1.js文件\n// 分别暴露\nexport function foo() {\n  console.log('foo() module1')\n}\nexport function bar() {\n  console.log('bar() module1')\n}\n```\n\n```auto\n//module2.js文件\n// 统一暴露\nfunction fun1() {\n  console.log('fun1() module2')\n}\nfunction fun2() {\n  console.log('fun2() module2')\n}\nexport { fun1, fun2 }\n```\n\n```auto\n//module3.js文件\n// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据\nexport default () => {\n  console.log('默认暴露')\n}\n```\n\n```auto\n// app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n```\n\n#### ⑤ 编译并在index.html中引入\n\n+   使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : `babel js/src -d js/lib`\n+   使用Browserify编译js : `browserify js/lib/app.js -o js/lib/bundle.js`\n\n然后在index.html文件中引入\n\n```auto\n <script type=\"text/javascript\" src=\"js/lib/bundle.js\"></script>\n```\n\n最后得到如下结果：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/16/167b650e8d8a99c9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n**此外第三方库(以jQuery为例)如何引入呢**？ 首先安装依赖`npm install jquery@1` 然后在app.js文件中引入\n\n```auto\n//app.js文件\nimport { foo, bar } from './module1'\nimport { fun1, fun2 } from './module2'\nimport module3 from './module3'\nimport $ from 'jquery'\n\nfoo()\nbar()\nfun1()\nfun2()\nmodule3()\n$('body').css('background', 'green')\n```\n\n## 三、总结\n\n+   CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。\n+   AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n+   CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重\n+   **ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/1/168a9c0bbdf4457f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n## 参考文章\n\n### [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588 \"https://github.com/seajs/seajs/issues/588\")\n\n### [CommonJS，AMD，CMD区别](https://zccst.iteye.com/blog/2215317 \"https://zccst.iteye.com/blog/2215317\")\n\n### [AMD 和 CMD 的区别有哪些？](https://www.zhihu.com/question/20351507/answer/14859415 \"https://www.zhihu.com/question/20351507/answer/14859415\")\n\n### [Javascript模块化编程](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html \"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\")\n\n### [Javascript标准参考教程](http://javascript.ruanyifeng.com/nodejs/module.html \"http://javascript.ruanyifeng.com/nodejs/module.html\")\n\n### [CMD 模块定义规范](https://github.com/seajs/seajs/issues/242 \"https://github.com/seajs/seajs/issues/242\")\n\n### [理解CommonJS、AMD、CMD三种规范](https://zhuanlan.zhihu.com/p/26625636 \"https://zhuanlan.zhihu.com/p/26625636\")"
    },
    {
      "id": "浏览器的回流与重绘Reflow-Repaint",
      "metadata": {
        "permalink": "/浏览器的回流与重绘Reflow-Repaint",
        "source": "@site/blog/浏览器的回流与重绘Reflow-Repaint.md",
        "title": "浏览器的回流与重绘Reflow-Repaint",
        "description": "请输入描述",
        "date": "2023-08-28T08:26:55.606Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 4.87,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "浏览器的回流与重绘Reflow-Repaint",
          "title": "浏览器的回流与重绘Reflow-Repaint",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "前端模块化详解",
          "permalink": "/前端模块化详解"
        },
        "nextItem": {
          "title": "跨源资源共享CORS",
          "permalink": "/跨源资源共享CORS"
        }
      },
      "content": "## 写在前面\n\n在讨论回流与重绘之前，我们要知道：\n\n1.  浏览器使用流式布局模型 (Flow Based Layout)。\n2.  浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了`Render Tree`。\n3.  有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。\n4.  由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一。\n\n**一句话：回流必将引起重绘，重绘不一定会引起回流。**\n\n## 回流 (Reflow)\n\n当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。\n\n会导致回流的操作：\n\n+   页面首次渲染\n+   浏览器窗口大小发生改变\n+   元素尺寸或位置发生改变\n+   元素内容变化（文字数量或图片大小等等）\n+   元素字体大小变化\n+   添加或者删除**可见**的`DOM`元素\n+   激活`CSS`伪类（例如：`:hover`）\n+   查询某些属性或调用某些方法\n\n一些常用且会导致回流的属性和方法：\n\n+   `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`\n+   `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`\n+   `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`\n+   `scrollIntoView()`、`scrollIntoViewIfNeeded()`\n+   `getComputedStyle()`\n+   `getBoundingClientRect()`\n+   `scrollTo()`\n\n## 重绘 (Repaint)\n\n当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。\n\n## 性能影响\n\n**回流比重绘的代价要更高。**\n\n有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。\n\n现代浏览器会对频繁的回流或重绘操作进行优化：\n\n浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。\n\n当你访问以下属性或方法时，浏览器会立刻清空队列：\n\n+   `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`\n    \n+   `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`\n    \n+   `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`\n    \n+   `width`、`height`\n    \n+   `getComputedStyle()`\n    \n+   `getBoundingClientRect()`\n    \n\n因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。\n\n## 如何避免\n\n### CSS\n\n+   避免使用`table`布局。\n+   尽可能在`DOM`树的最末端改变`class`。\n+   避免设置多层内联样式。\n+   将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。\n+   避免使用`CSS`表达式（例如：`calc()`）。\n\n### JavaScript\n\n+   避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。\n+   避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。\n+   也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。\n+   避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n+   对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。"
    },
    {
      "id": "跨源资源共享CORS",
      "metadata": {
        "permalink": "/跨源资源共享CORS",
        "source": "@site/blog/跨源资源共享CORS.md",
        "title": "跨源资源共享CORS",
        "description": "请输入描述",
        "date": "2023-08-28T08:25:27.756Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 26.17,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "跨源资源共享CORS",
          "title": "跨源资源共享CORS",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "浏览器的回流与重绘Reflow-Repaint",
          "permalink": "/浏览器的回流与重绘Reflow-Repaint"
        },
        "nextItem": {
          "title": "JavaScript的工作原理：解析、抽象语法树",
          "permalink": "/JavaScript的工作原理：解析、抽象语法树"
        }
      },
      "content": "**跨源资源共享**（[CORS](/zh-CN/docs/Glossary/CORS)，或通俗地译为跨域资源共享）是一种基于 [HTTP](/zh-CN/docs/Glossary/HTTP) 头的机制，该机制通过允许服务器标示除了它自己以外的其他[源](/zh-CN/docs/Glossary/Origin)（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\n\n跨源 HTTP 请求的一个例子：运行在 `https://domain-a.com` 的 JavaScript 代码使用 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 来发起一个到 `https://domain-b.com/data.json` 的请求。\n\n出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。例如，`XMLHttpRequest` 和 [Fetch API](/zh-CN/docs/Web/API/Fetch_API) 遵循[同源策略](/zh-CN/docs/Web/Security/Same-origin_policy)。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。\n\n\nCORS 机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](/zh-CN/docs/Web/API/Fetch_API)）使用 CORS，以降低跨源 HTTP 请求所带来的风险。\n\n## 什么情况下需要 CORS？\n\n这份[跨源共享标准](https://fetch.spec.whatwg.org/#http-cors-protocol)允许在下列场景中使用跨站点 HTTP 请求：\n\n+   前文提到的由 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch API](/zh-CN/docs/Web/API/Fetch_API) 发起的跨源 HTTP 请求。\n+   Web 字体（CSS 中通过 `@font-face` 使用跨源字体资源），[因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements)。\n+   [WebGL 贴图](/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL)。\n+   使用 [`drawImage()`](/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage \"drawImage()\") 将图片或视频画面绘制到 canvas。\n+   [来自图像的 CSS 图形 (en-US)](/en-US/docs/Web/CSS/CSS_shapes/Shapes_from_images \"Currently only available in English (US)\")。\n\n本文概述了跨源资源共享机制及其所涉及的 HTTP 标头。\n\n## 功能概述\n\n跨源资源共享标准新增了一组 [HTTP 标头](/zh-CN/docs/Web/HTTP/Headers)字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 [`GET`](/zh-CN/docs/Web/HTTP/Methods/GET) 以外的 HTTP 请求，或者搭配某些 [MIME 类型](/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types)的 [`POST`](/zh-CN/docs/Web/HTTP/Methods/POST) 请求），浏览器必须首先使用 [`OPTIONS`](/zh-CN/docs/Web/HTTP/Methods/OPTIONS) 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 [Cookie](/zh-CN/docs/Web/HTTP/Cookies) 和 [HTTP 认证](/zh-CN/docs/Web/HTTP/Authentication)相关数据）。\n\nCORS 请求失败会产生错误，但是为了安全，在 JavaScript 代码层面*无法*获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。\n\n接下来的内容将讨论相关场景，并剖析该机制所涉及的 HTTP 标头字段。\n\n## 若干访问控制场景\n\n这里，我们使用三个场景来解释跨源资源共享机制的工作原理。这些例子都使用在任意所支持的浏览器上都可以发出跨域请求的 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 对象。\n\n### 简单请求\n\n某些请求不会触发 [CORS 预检请求](/zh-CN/docs/Glossary/Preflight_request)。在废弃的 [CORS 规范](https://www.w3.org/TR/2014/REC-cors-20140116/#terminology)中称这样的请求为*简单请求*，但是目前的 [Fetch 规范](https://fetch.spec.whatwg.org/)（CORS 的现行定义规范）中不再使用这个词语。\n\n其动机是，HTML 4.0 中的 [`<form>`](/zh-CN/docs/Web/HTML/Element/form) 元素（早于跨站 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 和 [`fetch`](/zh-CN/docs/Web/API/fetch)）可以向任何来源提交简单请求，所以任何编写服务器的人一定已经在保护[跨站请求伪造攻击](/zh-CN/docs/Glossary/CSRF)（CSRF）。在这个假设下，服务器不必选择加入（通过响应预检请求）来接收任何看起来像表单提交的请求，因为 CSRF 的威胁并不比表单提交的威胁差。然而，服务器仍然必须提供 [`Access-Control-Allow-Origin`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 的选择，以便与脚本*共享*响应。\n\n若请求**满足所有下述条件**，则该请求可视为*简单请求*：\n\n+   使用下列方法之一：\n    +   [`GET`](/zh-CN/docs/Web/HTTP/Methods/GET)\n    +   [`HEAD`](/zh-CN/docs/Web/HTTP/Methods/HEAD)\n    +   [`POST`](/zh-CN/docs/Web/HTTP/Methods/POST)\n+   除了被用户代理自动设置的标头字段（例如 [`Connection`](/zh-CN/docs/Web/HTTP/Headers/Connection)、[`User-Agent`](/zh-CN/docs/Web/HTTP/Headers/User-Agent) 或其他在 Fetch 规范中定义为[禁用标头名称](https://fetch.spec.whatwg.org/#forbidden-header-name)的标头），允许人为设置的字段为 Fetch 规范定义的[对 CORS 安全的标头字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)。该集合为：\n    +   [`Accept`](/zh-CN/docs/Web/HTTP/Headers/Accept)\n    +   [`Accept-Language`](/zh-CN/docs/Web/HTTP/Headers/Accept-Language)\n    +   [`Content-Language`](/zh-CN/docs/Web/HTTP/Headers/Content-Language)\n    +   [`Content-Type`](/zh-CN/docs/Web/HTTP/Headers/Content-Type)（需要注意额外的限制）\n    +   [`Range`](/zh-CN/docs/Web/HTTP/Headers/Range)（只允许[简单的范围标头值](https://fetch.spec.whatwg.org/#simple-range-header-value) 如 `bytes=256-` 或 `bytes=127-255`）\n\n**备注：** Firefox 还没有将 `Range` 实现为安全的请求标头。参见 [bug 1733981](https://bugzilla.mozilla.org/show_bug.cgi?id=1733981)。\n\n+   [`Content-Type`](/zh-CN/docs/Web/HTTP/Headers/Content-Type) 标头所指定的[媒体类型](/zh-CN/docs/Glossary/MIME_type)的值仅限于下列三者之一：\n    +   `text/plain`\n    +   `multipart/form-data`\n    +   `application/x-www-form-urlencoded`\n+   如果请求是使用 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 对象发出的，在返回的 [`XMLHttpRequest.upload`](/zh-CN/docs/Web/API/XMLHttpRequest/upload) 对象属性上没有注册任何事件监听器；也就是说，给定一个 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 实例 `xhr`，没有调用 `xhr.upload.addEventListener()`，以监听该上传请求。\n+   请求中没有使用 [`ReadableStream`](/zh-CN/docs/Web/API/ReadableStream) 对象。\n\n**备注：** WebKit Nightly 和 Safari Technology Preview 为 [`Accept`](/zh-CN/docs/Web/HTTP/Headers/Accept)、[`Accept-Language`](/zh-CN/docs/Web/HTTP/Headers/Accept-Language) 和 [`Content-Language`](/zh-CN/docs/Web/HTTP/Headers/Content-Language) 标头字段的值添加了额外的限制。如果这些标头字段的值是“非标准”的，WebKit/Safari 就不会将这些请求视为“简单请求”。WebKit/Safari 并没有在文档中列出哪些值是“非标准”的，不过我们可以在这里找到相关讨论：\n\n+   [Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language](https://bugs.webkit.org/show_bug.cgi?id=165178)\n+   [Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS](https://bugs.webkit.org/show_bug.cgi?id=165566)\n+   [Switch to a blacklist model for restricted Accept headers in simple CORS requests](https://bugs.webkit.org/show_bug.cgi?id=166363)\n\n其他浏览器并不支持这些额外的限制，因为它们不属于规范的一部分。\n\n比如说，假如站点 `https://foo.example` 的网页应用想要访问 `https://bar.other` 的资源。`foo.example` 的网页中可能包含类似于下面的 JavaScript 代码：\n\njs\n\n```js\nconst xhr = new XMLHttpRequest();\nconst url = \"https://bar.other/resources/public-data/\";\n\nxhr.open(\"GET\", url);\nxhr.onreadystatechange = someHandler;\nxhr.send();\n```\n\n此操作实行了客户端和服务器之间的简单交换，使用 CORS 标头字段来处理权限：\n\n\n以下是浏览器发送给服务器的请求报文：\n\nhttp\n\n```auto\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https://foo.example\n```\n\n请求标头字段 [`Origin`](/zh-CN/docs/Web/HTTP/Headers/Origin) 表明该请求来源于 `http://foo.example`。\n\n让我们来看看服务器如何响应：\n\nhttp\n\n```auto\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2\nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[…XML Data…]\n```\n\n本例中，服务端返回的 [`Access-Control-Allow-Origin`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 标头的 `Access-Control-Allow-Origin: *` 值表明，该资源可以被**任意**外源访问。\n\nhttp\n\n```auto\nAccess-Control-Allow-Origin: *\n```\n\n使用 [`Origin`](/zh-CN/docs/Web/HTTP/Headers/Origin) 和 [`Access-Control-Allow-Origin`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 就能完成最简单的访问控制。如果 `https://bar.other` 的资源持有者想限制他的资源*只能*通过 `https://foo.example` 来访问（也就是说，非 `https://foo.example` 域无法通过跨源访问访问到该资源），他可以这样做：\n\nhttp\n\n```auto\nAccess-Control-Allow-Origin: https://foo.example\n```\n\n**备注：** 当响应的是[附带身份凭证的请求](#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82)时，服务端**必须**明确 `Access-Control-Allow-Origin` 的值，而不能使用通配符“`*`”。\n\n### 预检请求\n\n与[简单请求](#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82)不同，“需预检的请求”要求必须首先使用 [`OPTIONS`](/zh-CN/docs/Web/HTTP/Methods/OPTIONS) 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\n如下是一个需要执行预检请求的 HTTP 请求：\n\njs\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"https://bar.other/resources/post-here/\");\nxhr.setRequestHeader(\"X-PINGOTHER\", \"pingpong\");\nxhr.setRequestHeader(\"Content-Type\", \"application/xml\");\nxhr.onreadystatechange = handler;\nxhr.send(\"<person><name>Arun</name></person>\");\n```\n\n上面的代码使用 `POST` 请求发送一个 XML 请求体，该请求包含了一个非标准的 HTTP `X-PINGOTHER` 请求标头。这样的请求标头并不是 HTTP/1.1 的一部分，但通常对于 web 应用很有用处。另外，该请求的 `Content-Type` 为 `application/xml`，且使用了自定义的请求标头，所以该请求需要首先发起“预检请求”。\n\n\n**备注：** 如下所述，实际的 `POST` 请求不会携带 `Access-Control-Request-*` 标头，它们仅用于 `OPTIONS` 请求。\n\n下面是服务端和客户端完整的信息交互。首次交互是*预检请求/响应*：\n\nhttp\n\n```auto\nOPTIONS /doc HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nOrigin: https://foo.example\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type\n\nHTTP/1.1 204 No Content\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2\nAccess-Control-Allow-Origin: https://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\nVary: Accept-Encoding, Origin\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\n```\n\n从上面的报文中，我们看到，第 1 - 10 行使用 [`OPTIONS`](/zh-CN/docs/Web/HTTP/Methods/OPTIONS) 方法发送了预检请求，浏览器根据上面的 JavaScript 代码片断所使用的请求参数来决定是否需要发送，这样服务器就可以回应是否可以接受用实际的请求参数来发送请求。OPTIONS 是 HTTP/1.1 协议中定义的方法，用于从服务器获取更多信息，是[安全](/zh-CN/docs/Glossary/Safe/HTTP)的方法。该方法不会对服务器资源产生影响。注意 OPTIONS 预检请求中同时携带了下面两个标头字段：\n\nhttp\n\n```auto\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type\n```\n\n标头字段 [`Access-Control-Request-Method`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method) 告知服务器，实际请求将使用 `POST` 方法。标头字段 [`Access-Control-Request-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) 告知服务器，实际请求将携带两个自定义请求标头字段：`X-PINGOTHER` 与 `Content-Type`。服务器据此决定，该实际请求是否被允许。\n\n第 12 - 21 行为预检请求的响应，表明服务器将接受后续的实际请求方法（`POST`）和请求头（`X-PINGOTHER`）。重点看第 15 - 18 行：\n\nhttp\n\n```auto\nAccess-Control-Allow-Origin: https://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\nAccess-Control-Max-Age: 86400\n```\n\n服务器的响应携带了 `Access-Control-Allow-Origin: https://foo.example`，从而限制请求的源域。同时，携带的 `Access-Control-Allow-Methods` 表明服务器允许客户端使用 `POST` 和 `GET` 方法发起请求（与 [`Allow`](/zh-CN/docs/Web/HTTP/Headers/Allow) 响应标头类似，但该标头具有严格的访问控制）。\n\n标头字段 `Access-Control-Allow-Headers` 表明服务器允许请求中携带字段 `X-PINGOTHER` 与 `Content-Type`。与 `Access-Control-Allow-Methods` 一样，`Access-Control-Allow-Headers` 的值为逗号分割的列表。\n\n最后，标头字段 [`Access-Control-Max-Age`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age) 给定了该预检请求可供缓存的时间长短，单位为秒，默认值是 5 秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。以上例子中，该响应的有效时间为 86400 秒，也就是 24 小时。请注意，浏览器自身维护了一个[最大有效时间](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age)，如果该标头字段的值超过了最大有效时间，将不会生效。\n\n预检请求完成之后，发送实际请求：\n\nhttp\n\n```auto\nPOST /doc HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: https://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: https://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\n<person><name>Arun</name></person>\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2\nAccess-Control-Allow-Origin: https://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some XML payload]\n```\n\n#### 预检请求与重定向\n\n并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误：\n\n> The request was redirected to '[https://example.com/foo](https://example.com/foo)', which is disallowed for cross-origin requests that require preflight. Request requires preflight, which is disallowed to follow cross-origin redirects.\n\nCORS 最初要求浏览器具有该行为，不过在后续的[修订](https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2)中废弃了这一要求。但并非所有浏览器都实现了这一变更，而仍然表现出最初要求的行为。\n\n在浏览器的实现跟上规范之前，有两种方式规避上述报错行为：\n\n+   在服务端去掉对预检请求的重定向；\n+   将实际请求变成一个[简单请求](#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82)。\n\n如果上面两种方式难以做到，我们仍有其他办法：\n\n1.  发出一个[简单请求](#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82)（使用 [`Response.url` (en-US)](/en-US/docs/Web/API/Response/url \"Currently only available in English (US)\") 或 [`XMLHttpRequest.responseURL`](/zh-CN/docs/Web/API/XMLHttpRequest/responseURL)）以判断真正的预检请求会返回什么地址。\n2.  发出另一个请求（*真正*的请求），使用在上一步通过 `Response.url` 或 `XMLHttpRequest.responseURL` 获得的 URL。\n\n不过，如果请求是由于存在 `Authorization` 字段而引发了预检请求，则这一方法将无法使用。这种情况只能由服务端进行更改。\n\n### 附带身份凭证的请求\n\n**备注：** 当发出跨源请求时，第三方 cookie 策略仍将适用。无论如何改变本章节中描述的服务器和客户端的设置，该策略都会强制执行。\n\n[`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](/zh-CN/docs/Web/API/Fetch_API) 与 CORS 的一个有趣的特性是，可以基于 [HTTP cookies](/zh-CN/docs/Web/HTTP/Cookies) 和 HTTP 认证信息发送身份凭证。一般而言，对于跨源 `XMLHttpRequest` 或 [Fetch](/zh-CN/docs/Web/API/Fetch_API) 请求，浏览器**不会**发送身份凭证信息。如果要发送凭证信息，需要设置 `XMLHttpRequest` 对象的某个特殊标志位，或在构造 [`Request`](/zh-CN/docs/Web/API/Request) 对象时设置。\n\n本例中，`https://foo.example` 的某脚本向 `https://bar.other` 发起一个 GET 请求，并设置 Cookies。在 `foo.example` 中可能包含这样的 JavaScript 代码：\n\njs\n\n```js\nconst invocation = new XMLHttpRequest();\nconst url = \"https://bar.other/resources/credentialed-content/\";\n\nfunction callOtherDomain() {\n  if (invocation) {\n    invocation.open(\"GET\", url, true);\n    invocation.withCredentials = true;\n    invocation.onreadystatechange = handler;\n    invocation.send();\n  }\n}\n```\n\n第 7 行将 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 的 `withCredentials` 标志设置为 `true`，从而向服务器发送 Cookies。因为这是一个简单 `GET` 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 [`Access-Control-Allow-Credentials`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)`: true`，浏览器将**不会**把响应内容返回给请求的发送者。\n\n\n客户端与服务器端交互示例如下：\n\nhttp\n\n```auto\nGET /resources/credentialed-content/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nConnection: keep-alive\nReferer: https://foo.example/examples/credential.html\nOrigin: https://foo.example\nCookie: pageAccess=2\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:34:52 GMT\nServer: Apache/2\nAccess-Control-Allow-Origin: https://foo.example\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 106\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[text/plain payload]\n```\n\n即使第 10 行指定了 Cookie 是属于 `https://bar.other` 的内容的，但是，如果 `https://bar.other` 的响应中缺失 [`Access-Control-Allow-Credentials`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)`: true`（第 16 行），则响应内容会被忽略，不会提供给 web 内容。\n\n#### 预检请求和凭据\n\nCORS 预检请求不能包含凭据。预检请求的*响应*必须指定 `Access-Control-Allow-Credentials: true` 来表明可以携带凭据进行实际的请求。\n\n**备注：** 一些企业认证服务要求在预检请求时发送 TLS 客户端证书，这违反了 [Fetch](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials) 的规范。\n\nFirefox 87 允许通过在设置中设定 `network.cors_preflight.allow_client_cert` 为 `true`（[Firefox bug 1511151](https://bugzil.la/1511151)）来允许这种不规范的行为。基于 chromium 的浏览器目前总是在 CORS 预检请求中发送 TLS 客户端证书（[Chrome bug 775438](https://bugs.chromium.org/p/chromium/issues/detail?id=775438)）。\n\n#### 附带身份凭证的请求与通配符\n\n在响应附带身份凭证的请求时：\n\n+   服务器**不能**将 `Access-Control-Allow-Origin` 的值设为通配符“`*`”，而应将其设置为特定的域，如：`Access-Control-Allow-Origin: https://example.com`。\n+   服务器**不能**将 `Access-Control-Allow-Headers` 的值设为通配符“`*`”，而应将其设置为标头名称的列表，如：`Access-Control-Allow-Headers: X-PINGOTHER, Content-Type`\n+   服务器**不能**将 `Access-Control-Allow-Methods` 的值设为通配符“`*`”，而应将其设置为特定请求方法名称的列表，如：`Access-Control-Allow-Methods: POST, GET`\n\n对于附带身份凭证的请求（通常是 `Cookie`），\n\n这是因为请求的标头中携带了 `Cookie` 信息，如果 `Access-Control-Allow-Origin` 的值为“`*`”，请求将会失败。而将 `Access-Control-Allow-Origin` 的值设置为 `https://example.com`，则请求将成功执行。\n\n另外，响应标头中也携带了 `Set-Cookie` 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。\n\n#### 第三方 cookie\n\n注意在 CORS 响应中设置的 cookie 适用一般性第三方 cookie 策略。在上面的例子中，页面是在 `foo.example` 加载，但是第 19 行的 cookie 是被 `bar.other` 发送的，如果用户设置其浏览器拒绝所有第三方 cookie，那么将不会被保存。\n\n请求中的 cookie（第 10 行）也可能在正常的第三方 cookie 策略下被阻止。因此，强制执行的 cookie 策略可能会使本节描述的内容无效（阻止你发出任何携带凭据的请求）。\n\nCookie 策略受 [SameSite](/zh-CN/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value) 属性控制。\n\n## HTTP 响应标头字段\n\n本节列出了服务器为访问控制请求返回的 HTTP 响应头，这是由跨源资源共享规范定义的。上一小节中，我们已经看到了这些标头字段在实际场景中是如何工作的。\n\n### Access-Control-Allow-Origin\n\n响应标头中可以携带一个 [`Access-Control-Allow-Origin`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 字段，其语法如下：\n\nhttp\n\n```auto\nAccess-Control-Allow-Origin: <origin> | *\n```\n\n`Access-Control-Allow-Origin` 参数指定了单一的源，告诉浏览器允许该源访问资源。或者，对于**不需要携带**身份凭证的请求，服务器可以指定该字段的值为通配符“`*`”，表示允许来自任意源的请求。\n\n例如，为了允许来自 `https://mozilla.org` 的代码访问资源，你可以指定：\n\nhttp\n\n```auto\nAccess-Control-Allow-Origin: https://mozilla.org\nVary: Origin\n```\n\n如果服务端指定了具体的单个源（作为允许列表的一部分，可能会根据请求的来源而动态改变）而非通配符“`*`”，那么响应标头中的 [`Vary`](/zh-CN/docs/Web/HTTP/Headers/Vary) 字段的值必须包含 `Origin`。这将告诉客户端：服务器对不同的 [`Origin`](/zh-CN/docs/Web/HTTP/Headers/Origin) 返回不同的内容。\n\n### Access-Control-Expose-Headers\n\n译者注：在跨源访问时，`XMLHttpRequest` 对象的 [`getResponseHeader()`](/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader \"getResponseHeader()\") 方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\n\n[`Access-Control-Expose-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) 头将指定标头放入允许列表中，供浏览器的 JavaScript 代码（如 [`getResponseHeader()`](/zh-CN/docs/Web/API/XMLHttpRequest/getResponseHeader \"getResponseHeader()\")）获取。\n\nhttp\n\n```auto\nAccess-Control-Expose-Headers: <header-name>[, <header-name>]*\n```\n\n例如：\n\nhttp\n\n```auto\nAccess-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header\n```\n\n这样浏览器就能够通过 `getResponseHeader` 访问 `X-My-Custom-Header` 和 `X-Another-Custom-Header` 响应头了。\n\n### Access-Control-Max-Age\n\n[`Access-Control-Max-Age`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age) 头指定了 preflight 请求的结果能够被缓存多久，请参考本文在前面提到的 preflight 例子。\n\nhttp\n\n```auto\nAccess-Control-Max-Age: <delta-seconds>\n```\n\n`delta-seconds` 参数表示 preflight 预检请求的结果在多少秒内有效。\n\n### Access-Control-Allow-Credentials\n\n[`Access-Control-Allow-Credentials`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) 头指定了当浏览器的 `credentials` 设置为 true 时是否允许浏览器读取 response 的内容。当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用 `credentials`。请注意：简单 `GET` 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。\n\nhttp\n\n```auto\nAccess-Control-Allow-Credentials: true\n```\n\n上文已经讨论了[附带身份凭证的请求](#%E9%99%84%E5%B8%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E8%AF%81%E7%9A%84%E8%AF%B7%E6%B1%82)。\n\n### Access-Control-Allow-Methods\n\n[`Access-Control-Allow-Methods`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) 标头字段指定了访问资源时允许使用的请求方法，用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。\n\nhttp\n\n```auto\nAccess-Control-Allow-Methods: <method>[, <method>]*\n```\n\n有关[预检请求](/zh-CN/docs/Glossary/Preflight_request)的示例已在上方给出，包含了将此请求头发送至浏览器的示例。\n\n### Access-Control-Allow-Headers\n\n[`Access-Control-Allow-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) 标头字段用于[预检请求](/zh-CN/docs/Glossary/Preflight_request)的响应。其指明了实际请求中允许携带的标头字段。这个标头是服务器端对浏览器端 [`Access-Control-Request-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) 标头的响应。\n\nhttp\n\n```auto\nAccess-Control-Allow-Headers: <header-name>[, <header-name>]*\n```\n\n## HTTP 请求标头字段\n\n本节列出了可用于发起跨源请求的标头字段。请注意，这些标头字段无须手动设置。当开发者使用 [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest) 对象发起跨源请求时，它们已经被设置就绪。\n\n### Origin\n\n[`Origin`](/zh-CN/docs/Web/HTTP/Headers/Origin) 标头字段表明预检请求或实际跨源请求的源站。\n\nhttp\n\n```auto\nOrigin: <origin>\n```\n\norigin 参数的值为源站 URL。它不包含任何路径信息，只是服务器名称。\n\n**备注：** `origin` 的值可以为 `null`。\n\n注意，在所有访问控制请求中，[`Origin`](/zh-CN/docs/Web/HTTP/Headers/Origin) 标头字段**总是**被发送。\n\n### Access-Control-Request-Method\n\n[`Access-Control-Request-Method`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method) 标头字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。\n\nhttp\n\n```auto\nAccess-Control-Request-Method: <method>\n```\n\n相关示例见[这里](#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82)。\n\n### Access-Control-Request-Headers\n\n[`Access-Control-Request-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) 标头字段用于预检请求。其作用是，将实际请求所携带的标头字段（通过 [`setRequestHeader()`](/zh-CN/docs/Web/API/XMLHttpRequest/setRequestHeader \"setRequestHeader()\") 等设置的）告诉服务器。这个浏览器端标头将由互补的服务器端标头 [`Access-Control-Allow-Headers`](/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) 回答。\n\nhttp\n\n```auto\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n```\n\n相关示例见[这里](#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82)。\n\n## 规范\n\n| Specification |\n| --- |\n| [Fetch Standard  \n\\# http-access-control-allow-origin](https://fetch.spec.whatwg.org/#http-access-control-allow-origin) |\n\n## 浏览器兼容性\n\nBCD tables only load in the browser\n\nwith JavaScript enabled. Enable JavaScript to view data.\n\n## 参见\n\n+   [CORS 错误](/zh-CN/docs/Web/HTTP/CORS/Errors)\n+   [启用 CORS：如何在服务器中添加 CORS 支持](https://enable-cors.org/server.html)\n+   [`XMLHttpRequest`](/zh-CN/docs/Web/API/XMLHttpRequest)\n+   [Fetch API](/zh-CN/docs/Web/API/Fetch_API)\n+   [它会 CORS 吗？](https://httptoolkit.tech/will-it-cors)——交互的 CORS 解释器和生成器\n+   [如何不带 CORS 的运行 Chrome 浏览器](https://alfilatov.com/posts/run-chrome-without-cors/)\n+   [在所有（现代）浏览器中使用 CORS](https://www.telerik.com/blogs/using-cors-with-all-modern-browsers)\n+   [Stack Overflow 面对常见问题的解答](https://stackoverflow.com/questions/43871637/no-access-control-allow-origin-header-is-present-on-the-requested-resource-whe/43881141#43881141):\n    +   如何避免 CORS 预检请求\n    +   如何利用 CORS 代理避免“*No Access-Control-Allow-Origin header*”\n    +   如何修复“*Access-Control-Allow-Origin header must not be the wildcard*”"
    },
    {
      "id": "JavaScript的工作原理：解析、抽象语法树",
      "metadata": {
        "permalink": "/JavaScript的工作原理：解析、抽象语法树",
        "source": "@site/blog/JavaScript的工作原理：解析、抽象语法树.md",
        "title": "JavaScript的工作原理：解析、抽象语法树",
        "description": "请输入描述",
        "date": "2023-08-28T08:24:14.333Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 24.765,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "JavaScript的工作原理：解析、抽象语法树",
          "title": "JavaScript的工作原理：解析、抽象语法树",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "跨源资源共享CORS",
          "permalink": "/跨源资源共享CORS"
        },
        "nextItem": {
          "title": "防抖和节流",
          "permalink": "/防抖和节流"
        }
      },
      "content": "**摘要：** JS的\"编译原理\"。\n\n\n### 概述\n\n我们都知道运行一大段 JavaScript 代码性能会变得很糟糕。这段代码不仅需要通过网络传输，而且还需要解析、编译成字节码，最后执行。在之前的文章中，我们讨论了 JS 引擎、运行时和调用堆栈等，以及主要由谷歌 Chrome 和 NodeJS 使用的V8引擎。它们在整个 JavaScript 执行过程中都发挥着至关重要的作用。这篇说的抽象语法树同样重要:在这我们将了解大多数 JavaScript 引擎如何将文本解析为对机器有意义的内容，转换之后发生的事情以及做为 Web 开发者如何利用这一知识。\n\n### 编程语言原理\n\n那么，首先让我们回顾一下编程语言原理。不管你使用什么编程语言，你需要一些软件来处理源代码以便让计算机能够理解。该软件可以是解释器，也可以是编译器。无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 **抽象语法树(abstract syntax tree, AST)** 的数据结构。\n\n**AST** 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n\n> 抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。\n\n### AST 程序\n\nAST 不仅仅是用于语言解释器和编译器，在计算机世界中，它们还有多种应用。使用它们最常见的方法之一是进行静态代码分析。静态分析器不执行输入的代码，但是，他们仍然需要理解代码的结构。\n\n例如，你可能想要实现一个工具，该工具可以找到公共代码结构，以便你可以重构它们以减少重复。你可能会通过使用字符串比较来实现这一点，但这个会相当简单且有局限性。\n\n当然，如果你对实现这样的工具感兴趣，你不需要编写自己的解析器。有许多与 Ecmascript规范完全兼容的开源项目。**Esprima** 和 **Acorn** 即是黄金搭档，还有许多工具可以帮助解析器生成输出，即 **ASTs** ，ASTs 被广泛应用于代码转换。\n\n例如，你可能希望实现一个将 Python 代码转换为J avaScript 的转换器。基本思想是使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码。\n\n你可能会觉得难以置信，事实是 ASTs 只是部分语言的不同表示法。在解析之前，它被表示为遵循一些规则的文本，这些规则构成了一种语言。在解析之后，它被表示为一个树结构，其中包含与输入文本完全相同的信息。因此，也可以进行反向解析然后回到文本。\n\n**代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具**[**Fundebug**](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3Dxiaozhi)**。**\n\n### JavaScript 解析\n\n让我们看看 AST 是如何构建的。我们用一个简单的 JavaScript 函数作为例子:\n\n```js\nfunction foo(x) {\n    if (x > 10) {\n        var a = 2;\n        return a * x;\n    }\n\n    return x + 10;\n}\n```\n\n解析器会产生如下的 AST：\n\n![](https://ask.qcloudimg.com/http-save/2188212/63aq736avw.png)\n\n注意，为了观看方便，这里是解析器将生成的结果的简化版本。实际的 AST 要复杂得多。然而，这里的目的是为了运行源码之前的第一个步骤前。如果人想查看实际的 AST 是什么样子，可以访问 [AST Explorer](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fastexplorer.net%2F)。它是一个在线工具，你以在其中输入一些 JavaScript 并输出对应的 AST。\n\n你可能会问，为什么需要知道 JavaScript解析器工作原理，毕竟这是浏览器工作，你想法是部分正确。下图展示了 JavaScript 执行过程中不同阶段的耗时。仔细瞅瞅，你或许会发现一些有趣的东西。\n\n![](https://ask.qcloudimg.com/http-save/2188212/anv6h0oxr9.png)\n\n发现没？ 通常情况下，浏览器解析 JavaScript 大约需占总执行时间的 `15%` 到 `20%`。我没有具体统计过这些数值。这些是来自真实应用程序和以某种方式使用 JavaScript 的网站的统计数据。也许 `15%` 看起来不是很多，但相信我，这是很多。\n\n一个典型的单页程序加载 0.4 mb 左右的 JavaScript，浏览器需要大约 `370ms` 来解析它。也许你会又说，这也不是很多嘛，本身花费的时间并不多。但请记住，这只是将 JavaScript 代码解析为 AST 所需要的时间。这并不包括运行本身的时间，也不包括在页面加载 ，如 CSS 和 HTML 渲染过程的耗时。这些还只涉及桌面，移动浏览器的情况会更加复杂，在手机上花在解析上的时间通常是桌面浏览器的 2 到 5 倍。\n\n![](https://ask.qcloudimg.com/http-save/2188212/ycwl25040x.jpeg)\n\n上图显示了 1MB JavaScript 包在不同类的移动和桌面浏览器解析时间。\n\n更重要的是，为了获得更多类原生的用户体验而把越来越多的业务逻辑堆积在前端，Web 应用程序正变得越来越复杂。你可以轻易地想到网络应用受到的性能影响。只需打开浏览器开发工具，然后使用该工具来解析、编译和浏览器中发生的所有其他事情上所消耗的时间。\n\n![](https://ask.qcloudimg.com/http-save/2188212/qw7ms96147.jpeg)\n\n不幸的是，移动浏览器上没有开发者工具。不过不用担心，这并不意味着你对此无能为力。因为有 [DeviceTiming](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fgithub.com%2Fdanielmendel%2FDeviceTiming) 工具,它可以用来帮助检测受控环境中脚本的解析和运行时间。它通过插入代码来封装本地代码，这样每次从不同的设备访问页面时，就可以在本地测量解析和运行时间。\n\n好事就是 JavaScript 引擎做了很多工作来避免冗余的工作，并得到了更好的优化，以下为主流浏览器使用的技术。\n\n例如，V8 实现脚本流(script streaming)和代码缓存技术。脚本流即脚本一旦开始下载，`async` 和 `deferred`的 脚本就会在单独的线程上解析。这意味着在下载脚本完成后几乎立即完成解析，这会提升 10% 的页面加载速度。\n\n每次访问页面时，JavaScript 代码通常编译为字节码。 然而，一旦用户访问另一页面，该字节码就被丢弃。 发生这种情况是因为编译后的代码很大程度上依赖于编译时机器的状态和上下文。 这是 Chrome 42 引入字节码缓存的原因。 该技术会本地缓存编译过的代码，这样当用户返回同一页面时，诸如下载，解析和编译等所有步骤都会被跳过。 这使得 Chrome 可以节省大约 40％ 的解析和编译时间。 此外，这还可以节省移动设备的电量。\n\n在 Opera 中，[Carakan](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdev.opera.com%2Fblog%2Fcarakan%2F) 引擎可以重用另一个程序最近编译过的输出。没有要求代码必须来自相同的页面甚至同个域下。这种缓存技术实际上非常高效，还可以完全跳过编译步骤。它依赖于典型的用户行为和浏览场景:每当用户在应用程序/网站中遵循某个用户的特定浏览习惯，都会加载相同的 JavaScript 代码。不过，Carakan 引擎早已被谷歌的 V8 所取代。\n\n> Opera 新的 JavaScript 引擎 “Carakan”，目前速度是其他已存在 JavaScript 引擎（基于 SunSpider）的2.5倍。其在转化为本地机器代码时专门针对正则表达式做了优化。\n\nFirefox 使用的 [SpiderMonkey](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FMozilla%2FProjects%2FSpiderMonkey) 引擎不会缓存所有内容。它可以过渡到监视阶段，在这个阶段中，它计算执行给定脚本的次数。基于此计算，它推导出频繁使用而可以被优化的代码部分。\n\n> SpiderMonkey 是 Mozilla 项目的一部分，是一个用 C 语言实现的 JavaScript 脚本引擎，另外还有一个叫做Rhino 的 Java 版本。\n\n显然，有些人决定什么都不做。Safari 的首席开发人员 [Maciej Stachowiak](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMaciej_Stachowiak) 表示，Safari 不会对编译后的字节码进行任何缓存。缓存技术他们是有考虑过的问题，但是他们还没有实现，因为生成代码的耗时小于总运行时间的 2%。\n\n这些优化不会直接影响 JavaScript 源代码的解析，但是会尽可能完全避免。毕竟做总比没做好点？\n\n我们可以做很多事情来改善应用程序的初始加载时间。最小化加载的 JavaScript 数量：代码越小、解析所需要时间就越少，运行时间也就越小。要做到这一点，我们只能在当前的路由上加载所需的代码，而不是加载一大陀的代码。例如，[PRPL模式](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fprpl-pattern%2F)即表示该种代码传输类型。或者，可以检查代码的依赖关系，看看是否有什么冗余的依赖导致代码库膨胀，然而，这些东西需要很大的篇幅来进行讨论。\n\n本文的主要的目的讨论作为 Web 开发人员可以做些什么来帮助 JavaScript 解析器更快地完成它的工作。还有,现代JavaScript 解析器使用 **启发法(heuristics)** 来决定是否立即运行指定的代码片段或者推迟在未来的某个时候运行。基于这些启发法，解析器将进行即时或懒解析。\n\n> 启发法是针对模型求解方法而言的，是一种逐次逼近最优解的方法。这种方法对所求得的解进行反复判断实践修正直至满意为止。启发法的特点是模型简单，需要进行方案组合的个数少，因此便于找出最终答案。此方法虽不能保证得到最优解，但只要处理得当，可获得决策者满意的近似最优解。一般步骤包括:定义一个计算总费用的方法;报定判别准则;规定方案改选的途径;建立相应的模型;送代求解。\n\n立即解析会运行需要立即编译的函数。它主要做三件事:构建 AST，构建作用域层级和查找所有语法错误。另一方面， 懒解析只运行未编译的函数。它不构建AST，也不查找所有语法错误，它只构建作用域层级，与立即解析相比节省了大约一半的时间。\n\n显然，这不是一个新概念。即使像 IE 9 这样的浏览器也支持这种类型的优化，尽管与现在的解析器的工作方式相比，这种优化方式还很初级。\n\n来看一个例子，假设有以下代码片段:\n\n```js\nfunction foo() {\n    function bar(x) {\n        return x + 10;\n    }\n\n    function baz(x, y) {\n        return x + y;\n    }\n\n    console.log(baz(100, 200));\n}\n\nfoo()\n```\n\n就像前面的例子一样，代码被输入到语法分析器中，语法分析器进行语法分析并输出AST，如下：\n   声明函数 `foo`\n   调用函数 `foo`\n   在 `foo` 里声明函数 `bar` 接收参数 `x`, 并返回 `x` 和 10 相加的结果\n   在 `foo` 里声明函数 `baz` 接收参数 `x`和 `y`, 并返回 `x` 和 `y` 相加的结果\n   调用 `baz` 函数传入 100 和 2。\n   调用 `console.log` 参数为之前函数调用的返回值。\n\n![](https://ask.qcloudimg.com/http-save/2188212/khlfqbqdum.png)\n\n那么期间发生了什么? 解析器看到 `bar` 函数的声明、`baz` 函数的声明、`bar`函数的调用和 `console.log` 的调用。但是，解析器做了一些完全无关的额外工作即解析 `bar` 函数。为什么这无关紧要? 因为函数 `bar` 从来没有被调用过(或者至少在那个时候没有)。这是一个简单的示例，看起来可能有些不同寻常，但在许多实际应用程序中，许多声明的函数从未被调用。\n\n这里不解析`bar`函数，该函数声明了却没有调用它。只在需要的时候在函数运行前进行真正的解析。懒解析仍然需要找到函数的整个主体并为其声明，但仅此而已。它不需要语法树，因为它还没有被处理。另外，它不会从堆中分配内存，而堆通常会占用相当多的系统资源，简而言之，跳过这些步骤会带来很大的性能改进。\n\n所以之前的例子，解析器实际上会像如下这样解析：\n\n![](https://ask.qcloudimg.com/http-save/2188212/08lyc5pca9.png)\n\n注意，这里只确认 `bar` 函数声明，没有进入 `bar` 函数体。在这种情况下，函数体只是一个返回语句。但是，与大多数实际应用程序一样，它可以更大，包含多个返回语句、条件语句、循环、变量声明，甚至嵌套函数声明。这完全是在浪费时间和系统资源，因为这个函数永远不会被调用。\n\n这是一个相当简单的概念，但实际上，它的实现是非常难的，不局限于以上示例。整个方法还可以适用于函数、循环、条件、对象等。基本上，所有需要解析的东西。\n\n例如，下面是一个非常常见的 JavaScript 模式。\n\n```js\nvar myModule = (function() {\n     // 整个模块的逻辑\n     // 返回模块对象\n})();\n```\n\n大多数现代 JavaScript 解析器都能识别这种模式，此模式表示代码需要立即解析。\n\n那么为什么解析器不都使用懒解析呢? 如果懒解析某些代码，这些代码需要立即执行，这实际上会使代码运行速度变慢。需要运行一次懒解析之后进行另一个立即解析，这和立即解析相比，运行速度会慢 50%。\n\n现在对解析器底层原理有了大致的了解，是时候考虑如何提高解析器的解析速度。可以用这种方式编写代码，以便在正确的时间解析函数。大多数解析器都能识别一种模式:使用括号封装函数。对于解析器来说，这几乎总是一个积极的信号，即函数需要立即执行。如果解析器看到一个左括号，紧接着是一个函数声明，它将立即解析这个函数。可以通过显式地声明立即执行的函数来帮助解析器加快解析速度。\n\n假设有一个名为 `foo` 的函数。\n\n```js\nfunction foo(x) {\n    return x * 10;\n}\n```\n\n因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析。然而，我们确定这是不对的，那么可以运行两个步骤。\n\n首先，将函数存储在一个变量中:\n\n```js\nvar foo = function foo(x) {\n    return x * 10;\n};\n```\n\n注意，这里有使用函数的名称 `foo`,这不是必需的，但是建议这样做，因为在抛出异常的情况下，stacktrace 会保留实际函数名称，而不仅仅是 `<anonymous>`。\n\n以上事例解析器执行懒解析，可以用括号封装起来，让解析器进行立即解析：\n\n```js\nvar foo = (function foo(x) {\n    return x * 10;\n});\n```\n\n现在，解析器看见 `function` 关键字前的左括号便会立即进行解析。\n\n因为需要知道解析器在哪些情况下执行懒解析或者立即解析，所以很难手动管理。此外，还需要花时间考虑是否立即调用某个函数，肯定没人想这么做的。\n\n最后，这种地让代码更难阅读和理解。可以使用 `Optimize.js` 可以帮我们做这类事情，该工具只是用来优化 JavaScript 源代码的初始加载时间，它们对代码进行静态分析，然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们。\n\n像往常一样编码，然后有一段代码看起来像这样的：\n\n```js\n(function() {\n    console.log('Hello, World!');\n})();\n```\n\n一切看起来都很好，如预期的那样工作，而且速度很快，因为在函数声明之前添加左括号。当然，在进入生产环境之前需要进行代码压缩，以下为压缩工具的输出：\n\n```js\n!function(){console.log('Hello, World!')}();\n```\n\n好像没问题，代码像以前一样工作。但是好像少了什么，压缩工具删除包裹函数的括号，而是在函数前放置了一个感叹号，这意味着解析器将跳过此并将执行惰解析。\n\n最重要的是，为了能够执行该函数，它将在懒解析之后立即进行立即解析。 这会使代码运行得更慢，幸运的是，可以利用 `Optimize.js` 来解决此类问题，传给 `Optimize.js` 压缩过的代码会输出如下代码：\n\n```js\n!(function(){console.log('Hello, World!')})();\n```\n\n这还差不多，现在拥有两全其美方案：压缩代码且解析器正确地识别懒解析和立即解析的函数。\n\n### 预编译\n\n但为什么不能在服务器端完成所有这些工作呢？ 毕竟，最好这样做一次并将结果提供给客户端，而不强制各个客户端重复做该项事情。那么，目前正在讨论引擎是否应该提供一种执行预编译脚本的方法，这样就可以节省浏览器运行时间。\n\n从本质上讲，该思路是拥有可以生成字节码的务器端工具，这样只需要传输字节码并在客户端运行，之后会看到启动时间的一些主要差异。 这可能听起来很诱人，但事情并非那么简单，还可能会产生相反的效果，因为它会更大，并且很可能需要签署代码并出于安全原因对其进行处理。 例如，V8 团队正在努力解决重复解析问题，这样预编译有可能实际并没有多大的用处。\n\n### 提升编译速度一些建议\n\n+   检查依赖，减少不必要的依赖\n+   分割代码为更小的块而不是一整陀的\n+   尽可能推迟加载 JavaScript，按需要加载或者动态加载。\n+   使用开发者工具和 DeviceTiming 来检测性能瓶颈\n+   用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度\n\n**原文：**[**How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time**](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8)"
    },
    {
      "id": "防抖和节流",
      "metadata": {
        "permalink": "/防抖和节流",
        "source": "@site/blog/防抖和节流.md",
        "title": "防抖和节流",
        "description": "请输入描述",
        "date": "2023-08-28T08:21:26.862Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 1.95,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "防抖和节流",
          "title": "防抖和节流",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "JavaScript的工作原理：解析、抽象语法树",
          "permalink": "/JavaScript的工作原理：解析、抽象语法树"
        },
        "nextItem": {
          "title": "HTTPS加密原理",
          "permalink": "/HTTPS加密原理"
        }
      },
      "content": "## 防抖\n触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\n\n## 思路：\n每次触发事件时都取消之前的延时调用方法\n```js\nfunction debounce(fn) {\n      let timeout = null; // 创建一个标记用来存放定时器的返回值\n      return function () {\n        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉\n        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数\n          fn.apply(this, arguments);\n        }, 500);\n      };\n    }\n    function sayHi() {\n      console.log('防抖成功');\n    }\n\n    var inp = document.getElementById('inp');\n    inp.addEventListener('input', debounce(sayHi)); // 防抖\n```\n\n## 节流\n高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\n\n## 思路：\n每次触发事件时都判断当前是否有等待执行的延时函数\n\n```js\nfunction throttle(fn) {\n      let canRun = true; // 通过闭包保存一个标记\n      return function () {\n        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return\n        canRun = false; // 立即设置为false\n        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中\n          fn.apply(this, arguments);\n          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉\n          canRun = true;\n        }, 500);\n      };\n    }\n    function sayHi(e) {\n      console.log(e.target.innerWidth, e.target.innerHeight);\n    }\n    window.addEventListener('resize', throttle(sayHi));\n```"
    },
    {
      "id": "HTTPS加密原理",
      "metadata": {
        "permalink": "/HTTPS加密原理",
        "source": "@site/blog/HTTPS加密原理.md",
        "title": "HTTPS加密原理",
        "description": "请输入描述",
        "date": "2023-08-28T08:20:28.854Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 1.005,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "HTTPS加密原理",
          "title": "HTTPS加密原理",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "防抖和节流",
          "permalink": "/防抖和节流"
        },
        "nextItem": {
          "title": "浏览器输入URL后发生了什么",
          "permalink": "/浏览器输入URL后发生了什么"
        }
      },
      "content": "## HTTPS握手的五个阶段：\n\n客户端向服务器发送支持的SSL/TSL的协议版本号，以及客户端支持的加密方法，和一个客户端生成的随机数\n服务器确认协议版本和加密方法，向客户端发送一个由服务器生成的随机数，以及数字证书\n客户端验证证书是否有效，有效则从证书中取出公钥，生成一个随机数，然后用公钥加密这个随机数，发给服务器\n服务器用私钥解密，获取发来的随机数\n客户端和服务器根据约定好的加密方法，使用前面生成的三个随机数，生成对话密钥，用来加密接下来的整个对话过程"
    },
    {
      "id": "浏览器输入URL后发生了什么",
      "metadata": {
        "permalink": "/浏览器输入URL后发生了什么",
        "source": "@site/blog/浏览器输入URL后发生了什么.md",
        "title": "浏览器输入URL后发生了什么",
        "description": "请输入描述",
        "date": "2023-08-28T08:18:14.495Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 4.82,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "浏览器输入URL后发生了什么",
          "title": "浏览器输入URL后发生了什么",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "HTTPS加密原理",
          "permalink": "/HTTPS加密原理"
        },
        "nextItem": {
          "title": "web前端安全攻击与防御",
          "permalink": "/web前端安全攻击与防御"
        }
      },
      "content": "## 1. DNS域名解析\n在浏览器DNS缓存中搜索\n在操作系统DNS缓存中搜索\n读取系统hosts文件，查找其中是否有对应的ip\n向本地配置的首选DNS服务器发起域名解析请求\n\n## 2. 建立TCP连接\n为了准确地传输数据，TCP协议采用了三次握手策略。发送端首先发送一个带SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有SYN/ACK(acknowledegment)标志的数据包以示传达确认信息。最后发送方再回传一个带ACK标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包。\nTCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。\n\n## 3. 发起HTTP请求\n请求方法：\n\nGET:获取资源\nPOST:传输实体主体\nHEAD:获取报文首部\nPUT:传输文件\nDELETE:删除文件\nOPTIONS:询问支持的方法\nTRACE:追踪路径\n\n\n## 4. 接受响应结果\n状态码：\n\n1**：信息性状态码\n2**：成功状态码\n200：OK 请求正常处理\n204：No Content请求处理成功，但没有资源可返回\n206：Partial Content对资源的某一部分的请求\n3**：重定向状态码\n301：Moved Permanently 永久重定向\n302：Found 临时性重定向\n304：Not Modified 缓存中读取\n4**：客户端错误状态码\n400：Bad Request 请求报文中存在语法错误\n401：Unauthorized需要有通过Http认证的认证信息\n403：Forbidden访问被拒绝\n404：Not Found无法找到请求资源\n5**：服务器错误状态码\n500：Internal Server Error 服务器端在执行时发生错误\n503：Service Unavailable 服务器处于超负载或者正在进行停机维护\n\n\n## 5. 浏览器解析html\n浏览器按顺序解析html文件，构建DOM树，在解析到外部的css和js文件时，向服务器发起请求下载资源，若是下载css文件，则解析器会在下载的同时继续解析后面的html来构建DOM树，则在下载js文件和执行它时，解析器会停止对html的解析。这便出现了js阻塞问题。\n预加载器：\n当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索HTML标签中的URL，无法检测到使用脚本添加的URL，这些资源要等脚本代码执行时才会获取。\n注: 预解析并不改变Dom树，它将这个工作留给主解析过程\n\n浏览器解析css，形成CSSOM树，当DOM树构建完成后，浏览器引擎通过DOM树和CSSOM树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head元素和display值为none的元素）\n\n## 6. 浏览器布局渲染\n布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。\n绘制：将计算好的每个像素点信息绘制在屏幕上\n在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。\n\n减少rpaint和reflow 方法"
    },
    {
      "id": "web前端安全攻击与防御",
      "metadata": {
        "permalink": "/web前端安全攻击与防御",
        "source": "@site/blog/web前端安全攻击与防御.md",
        "title": "web前端安全攻击与防御",
        "description": "请输入描述",
        "date": "2023-08-28T08:17:08.959Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 12.63,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "web前端安全攻击与防御",
          "title": "web前端安全攻击与防御",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "浏览器输入URL后发生了什么",
          "permalink": "/浏览器输入URL后发生了什么"
        },
        "nextItem": {
          "title": "cookie、session、sessionStorage、localStorage区别",
          "permalink": "/cookie、session、sessionStorage、localStorage区别"
        }
      },
      "content": "## 前后端安全分类：\n\n1、前端安全：发生在浏览器、单页面应用、web页面的安全问题，比如跨站脚本攻击xss就是前端安全问题\n\n2、后端安全：发生在后端服务器、应用、服务当中的安全问题，比如：SQL注入漏洞发生在后端\n\n## 前端安全攻击手段\n\n1、XSS攻击\n\n2、CSRF攻击\n\n3、点击劫持\n\n4、iframe带来的风险\n\n5、不安全的第三方依赖包\n\n## XSS攻击\n\nXSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。恶意攻击者在web页面中会插入一些恶意的script代码。当目标网站、目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了，因此达到恶意攻击用户的目的。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3bf398db3144~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\n                                                           xss攻击示意图\n\n根据攻击的来源，XSS 攻击可分为反射型、存储型和 DOM 型三种：\n\n反射型XSS：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3bf91ef38b4c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\n反射型XSS示意图\n\n1、用户A给用户B发送一个恶意构造了Web的URL。\n\n2、用户B点击并查看了这个URL。\n\n3、用户B获取到一个具有漏洞的HTML页面并显示在本地浏览器中。\n\n4、漏洞HTML页面执行恶意JavaScript脚本，将用户B信息盗取发送给用户A，或者篡改用户B看到的数据等\n\n#### 反射型XSS防御：\n\n我们可以通过html转义来防范，最好是采用成熟的转义库处理\n\n攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户\n\n存储型XSS：存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端，下次请求目标页面时不用再提交XSS代码，这样，每一个访问特定网页的用户都会被攻击\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3c00c9a1faa1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\n存储型XSS示意图\n\n1、用户A在网页上创建了某个账户，并且账户信息中包含XSS代码。\n\n2、用户B访问该网站查看XSS代码账户详情页面。\n\n3、服务端返回账户详情页面，和带XSS账户信息。\n\n4、用户B浏览器执行XSS代码，将用户B信息盗取发送给用户A，或者篡改用户B看到的数据等。\n\n#### 存储型XSS攻击防范：\n\n1\\. 后端需要对提交的数据进行过滤。\n\n2\\. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。\n\nDOM-based型XSS：DOM型XSS是基于DOM文档对象模型的一种漏洞,通过 HTML DOM，通过植入js代码，造成dom的更改，因此造成了XSS-DOM漏洞，所以DOM类型的XSS可能是反射型也可能是储存型\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3c0414b44ce4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\nDOM型XSS示意图\n\n1、用户B访问网站url中带有XSS代码参数。\n\n2、浏览器下载该网站JavaScript脚本。\n\n3、JavaScript脚本有个方法获取URL中XSS代码参数，并且用innerHtml渲染在dom中。\n\n4、触发XSS代码，造成XSS攻击，cookie数据失窃。\n\nDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\n\n#### DOM 型 XSS防御：\n\n1、在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n\n2、在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n\n3、在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。\n\n4、Http Only cookie\n\n5、对产品输入要求格式严谨检查过滤\n\n## CSRF攻击\n\n攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3c087aaf5013~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\nCSRF攻击示意图\n\n#### CSRF攻击防御：\n\n1、验证 HTTP Referer 字段\n\n2、使用 token验证\n\n3、显示验证方式：添加验证码、密码等\n\n4、涉及到数据修改操作严格使用 post 请求而不是 get 请求\n\n## 点击劫持攻击：\n\n点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/13/170d3c0d54171f64~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)  \n\n点击劫持示意图\n\n一个简单的点击劫持例子，就是当你点击了一个不明链接之后，自动关注了某一个人的博客或者订阅了视频\n\n#### 点击劫持防御\n\n**1****、****X-Frame-Options****浏览器机制：**X-Frame-Options HTTP响应头是用来给浏览器指示允许一个页面能否在frame、iframe、object中展现的标记，有三个可选的值：**DENY**：浏览器会拒绝当前页面加载任何frame页面（即使是相同域名的页面也不允许）**SAMEORIGIN**：允许加载frame页面，但是frame页面的地址只能为同源域名下的页面**ALLOW-FROM****：**可以加载指定来源的frame页面（可以定义frame页面的地址）但这个缺陷就是chrome、Safari是不支持ALLOW-FROM语法！\n\n**2****、使用认证码认证用户：**点击劫持漏洞通过伪造网站界面进行攻击，网站开发人员可以通过认证码识别用户，确定是用户发出的点击命令才执行相应操作。识别用户的方法中最有效的方法是认证码认证。例如，在网站上广泛存在的发帖认证码，要求用户输入图形中的字符，输入某些图形的特征等\n\n**3****、 使用** **FrameBusting** **代码“：**使用 JavaScript 脚本阻止恶意网站载入网页。如果检测到网页被非法网页载入，就执行自动跳转功能。如果用户浏览器禁用JavaScript脚本，那么FrameBusting代码也无法正常运行。所以，该类代码只能提供部分保障功能\n\n## iframe 带来的风险\n\n有些时候我们的前端页面需要用到第三方提供的页面组件，通常会以iframe的方式引入。典型的例子是使用iframe在页面上添加第三方提供的广告、天气预报、社交分享插件等等\n\niframe本身不受我们控制，那么如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了\n\n#### iframe防御：\n\niframe有了一个叫做sandbox的安全属性，通过它可以对iframe的行为进行各种限制，在 iframe 元素中添加上这个关键词就行，另外，sandbox也提供了丰富的配置参数，我们可以进行较为细粒度的控制。一些典型的参数如下：\n\n**allow-forms****：**允许iframe中提交form表单\n\n**allow-popups****：**允许iframe中弹出新的窗口或者标签页（例如，window.open()，showModalDialog()，target=”\\_blank”等等）\n\n**allow-scripts****：**允许iframe中执行JavaScript\n\n**allow-same-origin****：**允许iframe中的网页开启同源策略\n\n如果你只是添加上这个属性而保持属性值为空，那么浏览器将会对 iframe 实施史上最严厉的调控限制\n\n## 不安全的第三方依赖\n\n项目里面使用了很多第三方的依赖，不论应用自己的代码的安全性有多高，如果这些来自第三方的代码有安全漏洞，那么对应用整体的安全性依然会造成严峻的挑战。jQuery就存在多个已知安全漏洞，Node.js也有一些已知的安全漏洞\n\n#### 第三方依赖包防御：\n\n手动检查这些第三方代码有没有安全问题是个苦差事，主要是因为应用依赖的这些组件数量众多，手工检查太耗时，有自动化的工具可以使用，比如NSP(Node Security Platform)，Snyk、sonarQubej检测工具等等\n\n## vue对前端安全的处理：Vue 的安全措施\n\n当然还存在很多别的攻击手段，比如：\n\nHttps 也可能存在的风险（强制让HTTPS降级回HTTP，从而继续进行中间人攻击）\n\n本地存储数据泄露（尽可能不在前端存储任何敏感、机密的数据）\n\ncdn劫持（攻击者劫持了CDN，或者对CDN中的资源进行了污染）"
    },
    {
      "id": "cookie、session、sessionStorage、localStorage区别",
      "metadata": {
        "permalink": "/cookie、session、sessionStorage、localStorage区别",
        "source": "@site/blog/cookie、session、sessionStorage、localStorage区别.md",
        "title": "cookie、session、sessionStorage、localStorage区别",
        "description": "请输入描述",
        "date": "2023-08-28T08:15:54.646Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 8.38,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "cookie、session、sessionStorage、localStorage区别",
          "title": "cookie、session、sessionStorage、localStorage区别",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "web前端安全攻击与防御",
          "permalink": "/web前端安全攻击与防御"
        },
        "nextItem": {
          "title": "前端必须懂的计算机网络TCP",
          "permalink": "/前端必须懂的计算机网络TCP"
        }
      },
      "content": "无衬线\n14px\n经典蓝\ngithub\n\n## cookie、session、sessionStorage、localStorage区别\n​\n### cookie、session区别\n​\n+   cookie 存储于浏览器端，而 session 存储于服务端\n+   cookie 的安全性相比于 session 较弱，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗  \n    考虑到安全应当使用session。\n+   session 会在一定时间内保存在服务器上。当访问增多时，会占用服务器的资源，所以考虑到服务器性能方面，可以使用cookie\n+   cookie 存储容量有限制，单个cookie 保存数据不能超过4k，且很多浏览器限制一个站点最多保存20个cookie。而对于 session ，其默认大小一般是1024k\n​\n### cookie、sessionStorage、localStorage 异同点\n​\n**html5 中 webStorage 包含 sessionStorage 和 localStorage**  \n共同点：\n​\n+   都保存在浏览器端，且是同源的\n​\n区别：\n​\n+   cookie 数据始终在同源的http请求中携带，而 webStorage 不会再请求中携带，仅仅在本地存储\n+   存储大小区别，cookie 是4k，webStorage 可以达到5M甚至更大\n+   数据有效时间区别： sessionStorage 仅仅是会话级别的存储，它只在当前浏览器关闭前有效，不能持久保持；localStorage 始终有效，即使窗口或浏览器关闭也一直有效，除非用户手动删除，其才会失效；cookie 只在设置的 cookie 过期时间之前一直有效。\n+   作用域区别：sessionStorage **不在不同的浏览器窗口中共享**，即使是同一个页面； localStorage 和 cookie 在所有同源窗口是共享的\n+   Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。\n​\n#### web storage和cookie的区别\n​\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\n​\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。\n​\n但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\n​\nCookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；\n​\n本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除\n​\n最后编辑于\n​\n：2017.12.10 06:43:14\n​\n+   序言：七十年代末，一起剥皮案震惊了整个滨河市，随后出现的几起案子，更是在滨河造成了极大的恐慌，老刑警刘岩，带你破解...\n    \n+   序言：滨河连续发生了三起死亡事件，死亡现场离奇诡异，居然都是意外死亡，警方通过查阅死者的电脑和手机，发现死者居然都...\n    \n+   文/潘晓璐 我一进店门，熙熙楼的掌柜王于贵愁眉苦脸地迎上来，“玉大人，你说我怎么就摊上这事。” “怎么了？”我有些...\n    \n+   文/不坏的土叔 我叫张陵，是天一观的道长。 经常有香客问我，道长，这世上最难降的妖魔是什么？ 我笑而不...\n    \n+   正文 为了忘掉前任，我火速办了婚礼，结果婚礼上，老公的妹妹穿的比我还像新娘。我一直安慰自己，他们只是感情好，可当我...\ncookie、session、sessionStorage、localStorage区别\ncookie、session区别\n•cookie 存储于浏览器端，而 session 存储于服务端\n•cookie 的安全性相比于 session 较弱，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。\n•session 会在一定时间内保存在服务器上。当访问增多时，会占用服务器的资源，所以考虑到服务器性能方面，可以使用cookie\n•cookie 存储容量有限制，单个cookie 保存数据不能超过4k，且很多浏览器限制一个站点最多保存20个cookie。而对于 session ，其默认大小一般是1024k\n\ncookie、sessionStorage、localStorage 异同点\nhtml5 中 webStorage 包含 sessionStorage 和 localStorage\n共同点：\n\n•都保存在浏览器端，且是同源的\n\n区别：\n\n•cookie 数据始终在同源的http请求中携带，而 webStorage 不会再请求中携带，仅仅在本地存储\n•存储大小区别，cookie 是4k，webStorage 可以达到5M甚至更大\n•数据有效时间区别： sessionStorage 仅仅是会话级别的存储，它只在当前浏览器关闭前有效，不能持久保持；localStorage 始终有效，即使窗口或浏览器关闭也一直有效，除非用户手动删除，其才会失效；cookie 只在设置的 cookie 过期时间之前一直有效。\n•作用域区别：sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 和 cookie 在所有同源窗口是共享的\n•Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。\n\nweb storage和cookie的区别\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\n\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。\n\n但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\n\nCookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；\n\n本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除"
    },
    {
      "id": "前端必须懂的计算机网络TCP",
      "metadata": {
        "permalink": "/前端必须懂的计算机网络TCP",
        "source": "@site/blog/前端必须懂的计算机网络TCP.md",
        "title": "前端必须懂的计算机网络TCP",
        "description": "请输入描述",
        "date": "2023-08-28T08:15:07.551Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 20.235,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "前端必须懂的计算机网络TCP",
          "title": "前端必须懂的计算机网络TCP",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "cookie、session、sessionStorage、localStorage区别",
          "permalink": "/cookie、session、sessionStorage、localStorage区别"
        },
        "nextItem": {
          "title": "深入理解浏览器的缓存机制",
          "permalink": "/深入理解浏览器的缓存机制"
        }
      },
      "content": "## 计算机网络在IT行业的重要性\n\nIT即互联网技术，从事的工作和网络有很大的关系，前端要负责和后台(服务器)进行交互，其必然得经过网络，所以懂点网络知识有很大的帮助。\n\n## 前端必须懂的计算机网络知识系列文章：\n\n+   [DNS服务器和跨域问题](https://juejin.cn/post/6844903682526412813 \"https://juejin.cn/post/6844903682526412813\")\n+   [计算机网络的分层模型](https://juejin.cn/post/6844903682526412813 \"https://juejin.cn/post/6844903682526412813\")\n+   [IP地址和MAC地址](https://juejin.cn/post/6844903682526412813 \"https://juejin.cn/post/6844903682526412813\")\n+   [前端必须懂的计算机网络知识—(跨域、代理、本地存储)](https://juejin.cn/post/6844903686775242760 \"https://juejin.cn/post/6844903686775242760\")\n+   [前端必须懂的计算机网络知识—(TCP)](https://juejin.cn/post/6844903682820014094 \"https://juejin.cn/post/6844903682820014094\")\n+   [前端必须懂的计算机网络知识—(HTTP)](https://juejin.cn/post/6844903683927310349 \"https://juejin.cn/post/6844903683927310349\")\n+   [前端必须懂的计算机网络知识—(XSS、CSRF和HTTPS)](https://juejin.cn/post/6844903686951403528 \"https://juejin.cn/post/6844903686951403528\")\n\n## 网络模型数据处理过程\n\n![模型数据处理过程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f78342b47b770~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n## 传输层协议的作用\n\n+   提供了一种端到端(end to end)的连接，一般为前端和后台服务器的连接\n+   由于网络层只管传递数据，并不关心成功与否，TCP协议在数据丢失、损坏的情况下保证数据的可靠性\n\n## 传输层协议的分类\n\n+   传输控制协议TCP(Transimision Control Protocal)：\n\n1.  可靠的、面向连接的协议\n2.  传输效率低\n\n+   用户数据报协议UDP(User Datagram Protocal)：\n\n1.  不可靠的、无连接的服务\n2.  传输效率高\n\n## TCP\n\n### TCP的功能\n\n为了保证TCP是可靠的、面向连接的协议，具备以下功能：\n\n1.  将数据进行分段打包传输，如果不将数据分段打包传输，那么会导致每次传输的数据特别大，而带宽是一定的，所以很容易造成拥塞。想象一下，一辆火车跑在公路上的感觉。\n2.  对每个数据包编号控制顺序，因为数据进行了分段打包传输，而网络中的路线不止一条，而且某些路线会有延迟的情况，没有编号，那么如何保证到达的数据是原来的模样。想象一下，将一副大拼图从一个地方，分多条路运往另外一个地方，并且没有编号。\n3.  运输中丢失、重发和丢弃处理，由于网络中的路线会有延迟，并且存在丢包现象，所以会有重发等机制来保证数据的完整性。\n4.  流量控制避免拥塞，避免发送速率过快，让接收方来不及接收，导致发生丢包。\n\n### TCP首部\n\n![源和目的](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7a4b28f78d88~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n源端口号和目的端口号：用来存放发送端和接收端加上IP协议首部的源端IP及终端IP，确认一个唯一的TCP连接。\n\n![32位序号](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7a7606658fef~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n32位序号：TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为l，则下次发送数据时的序列号为s+l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。\n\n![32位确认序号](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7a80f5758fcf~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n32位确认序号：ACK为1时有效，上次成功收到的数据字节序号+1（如接收到的为1024--2048，则返回2049），也是下一次发送端要发送数据的序列号。 4位首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示TCP首部的长度为 20 字节。\n\n![控制位](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7a867386aede~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n6个保留位：\n\n+   URG => 紧急指针；\n+   ACK => 为1表示确认序号有效；\n+   PSH => 缓存区将满,接收方应尽快将此报文段交给应用层；\n+   RST => 连接断了重建连接；\n+   SYN => 同步序号为1，用来发起一个新连接；\n+   FIN => 为1表示发端完成发送任务。\n\n![校验](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7aecde265e86~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n16位窗口大小：TCP流量控制，字节数，说明本地可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在TCP传输中进行流量控制的\n\n16位检验和：包括计算TCP首部和数据综合的二进制反码和检验和。\n\n16位紧急指针：URG为1时有效，正向的偏移量，加上序号字段值表示最后一个字节的序号。通常在暂时中断通信时使用（比如输入 Ctrl + C）。\n\n### 三次握手和四次挥手\n\n![三次握手和四次挥手](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f7b595c7e7279~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n三次握手：\n\n1.  第一次握手主机A通过一个标识为SYN标识位的数据段发送给主机B请求连接，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号\n2.  第二次握手是主机B用一个确认应答ACK和同步序列号SYNC标志位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记。\n3.  第三次握手是主机A确认收到了主机B的数据段并可以开始传输实际数据。\n\n第一次握手主要是确定服务端确认客户端能够发送信号；第二次握手主要是客户端确认服务端能够接收和发送信号；第三次握手主要是服务端确认客户端能够接收信号\n\n四次挥手：\n\n1.  主机A发送FIN控制位发出断开连接的请求\n2.  主机B进行响应，确认收到断开连接请求\n3.  主机B提出反方向的关闭要求\n4.  主机A确认收到的主机B的关闭连接请求\n\n第一次挥手是服务端确认客户端需要断开连接；第二次挥手是客户端确认服务器接收断开请；第三次挥手是客户端确认服务器数据发完，断开连接；第四次挥手是服务端确认客户端断开连接，断开连接。所以如果服务端的数据全部发送完，是没有第三次挥手，直接进入第四次挥手。\n\n### TCP流量控制和TCP拥塞控制\n\n窗口：\n\n1.  接收端窗口 rwnd：接收端缓冲区大小。接收端将此窗口值放在TCP报文的首部中的窗口字段，传送给发送端。\n2.  拥塞窗口 cwnd (congestion window)：发送端缓冲区大小\n3.  发送窗口swnd：发送窗口的上限值 = Min \\[rwnd, cwnd\\]，当 rwnd < cwnd 时，是接收端的接收能力限制发送窗口的最大值。当cwnd < rwnd时，则是网络的拥塞限制发送窗口的最大值\n\n拥塞控制和流量控制的差别：\n\n+   拥塞问题是一个全局性的问题,涉及到所有的主机、所有的路由器、以及与降低网络传输性能有关的所有因素。流量控制往往指的是点对点通信量的控制，是个端到端的问题。\n+   流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。拥塞控制控制的是注入网络中的数据量。\n+   流量窗口是接收方控制的，拥塞窗口是发送方控制的\n\n#### TCP流量控制\n\n所谓的流量控制就是接收方让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。\n\n![TCP流量控制](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fa8d0bc51a29b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n假设主机A向主机B发送数据。双方确定的窗口值是400.再设每一个报文段为100字节长，序号的初始值为seq=1,图中的箭头上面大写ACK，表示首部中的却认为为ACK，小写ack表示确认字段的值。\n\n![窗口大小调整](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fa9ead51af9f9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n下面这张接收窗口(rwnd)图和上面的数据不是对应的，但是能说明窗口大小调整的过程，可以自己将下面的图进行修改，用上面的数据分析：\n\n1.  刚开始的窗口值为400字节，每段报文100字节，经过发送2次请求后，此时已发送但未被确认的报文seq=201为100字节，主机B向主机A发送接收情况并调整窗口大小为300字节。\n2.  主机A向主机B发送301-500，并且重发201-300，主机B向主机A发送接收情况，并调整窗口大小为100字节\n3.  主机A向主机B发送501-600,主机B向主机A发送接收情况，并且调整窗口大小为0，让A暂停发送\n\n假设B向A发送了rwnd=0的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwind=400的报文段，然而这个报文段在传送中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。\n\n### TCP拥塞控制\n\n#### 拥塞控制原理\n\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大一些，以便把更多的分组发送出去。但是只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数。\n\n#### 拥塞控制设计\n\n从控制理论的角度来看拥塞控制这个问题，可以分为开环控制和闭环控制两种方法：\n\n+   开环控制就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。\n+   闭环控制是基于反馈环路的概念，包括如下措施：\n\n1.  监测网路系统以便检测拥塞在何时、何地发生\n2.  把拥塞发生的信息传送到可采取行动的地方\n3.  调整网络系统的行动以解决出现的问题。\n\n#### 拥塞控制方法\n\n因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始（Slow-start)、拥塞避免（Congestion Avoidance)、快重传（Fast Restrangsmit)和快回复（Fast Recovery）。我们假定：\n\n1.  数据是单方向传送，而另外一个方向只传送确认\n2.  接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。\n\n#### 慢开始算法\n\n最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加至多1个MSS大小。用这样的方法来逐步增大拥塞窗口CWND。 这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下图：\n\n![慢开始算法](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fad9ae32ae229~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n#### 拥塞避免算法\n\n让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。\n\n#### 慢开始和拥塞避免轮换机制\n\n为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：\n\n+   当cwnd<ssthresh时，使用慢开始算法。\n+   当cwnd>ssthresh时，改用拥塞避免算法。\n+   当cwnd=ssthresh时，慢开始与拥塞避免算法任意。\n\n#### 乘法减小和加法增大\n\n![乘法减小和加法增大](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fadfdd636ce26~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n+   乘法减小：是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时，就把慢开始门限减半，即设置为当前的拥塞窗口的一半（于此同时，执行慢开始算法）。当网络出现频繁拥塞时，ssthresh值就下降的很快，以大大将小注入到网络中的分组数。\n+   加法增大：是指执行拥塞避免算法后是拥塞窗口缓慢增大，以防止网络过早出现拥塞。\n\n#### 快重传和快恢复\n\n一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。\n\n+   快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图：\n    \n    ![快重传](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fae388ca291d1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n    \n+   快恢复算法:\n\n1.  当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n2.  考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的大小，然后执行拥塞避免算法。如下图：\n    \n    ![快恢复](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fae5de0c9f30a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n    \n\n## UDP\n\n### UDP应用\n\n由于UDP是不可靠的、无连接的服务并且传输效率高，所以UDP应用的特点就是需要实时数据，可以允许丢包。所以QQ、视频软件、TFTP 简单文件传输协议(短信)等都是UDP应用。\n\n### UDP的实现\n\n由于在IP地址中存在一些广播地址，UDP主要是通过它们来实现的 结语： IT即互联网技术，从事的工作和网络有很大的关系，前端要负责和后台(服务器)进行交互，其必然得经过网络，所以懂点网络知识有很大的帮助。接下来会介绍： HTTP HTTPS\n\n本文参考：\n\n1.  计算机网络\n2.  [TCP流量控制和拥塞控制](https://www.cnblogs.com/wxgblogs/p/5616829.html \"https://www.cnblogs.com/wxgblogs/p/5616829.html\")"
    },
    {
      "id": "深入理解浏览器的缓存机制",
      "metadata": {
        "permalink": "/深入理解浏览器的缓存机制",
        "source": "@site/blog/深入理解浏览器的缓存机制.md",
        "title": "深入理解浏览器的缓存机制",
        "description": "请输入描述",
        "date": "2023-08-28T08:13:38.298Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 24.74,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "深入理解浏览器的缓存机制",
          "title": "深入理解浏览器的缓存机制",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "前端必须懂的计算机网络TCP",
          "permalink": "/前端必须懂的计算机网络TCP"
        },
        "nextItem": {
          "title": "前端必备HTTP技能之同源策略详解",
          "permalink": "/前端必备HTTP技能之同源策略详解"
        }
      },
      "content": "## 深入理解浏览器的缓存机制\n\n## 一、前言\n\n缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。\n\n对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。\n\n接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。\n\n**如需获取思维导图或想阅读更多优质文章请猛戳[GitHub博客](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fljianshu%2FBlog)**,也欢迎加我个人微信frontJS,一起交流技术！\n\nimage\n\n## 二、缓存位置\n\n从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。\n\n+   Service Worker\n+   Memory Cache\n+   Disk Cache\n+   Push Cache\n\n### 1.Service Worker\n\nService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。**Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的**。\n\nService Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\n\n当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。\n\n### 2.Memory Cache\n\nMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 **一旦我们关闭 Tab 页面，内存中的缓存也就被释放了**。\n\n**那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？**  \n这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。\n\n当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存\n\nimage\n\n内存缓存中有一块重要的缓存资源是preloader相关指令（例如`<link rel=\"prefetch\">`）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。\n\n需要注意的事情是，**内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验**。\n\n### 3.Disk Cache\n\nDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，**比之 Memory Cache 胜在容量和存储时效性上**。\n\n在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。\n\n**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**  \n关于这点，网上说法不一，不过以下观点比较靠得住：\n\n+   对于大文件来说，大概率是不存储在内存中的，反之优先\n+   当前系统内存使用率高的话，文件优先存储进硬盘\n\n### 4.Push Cache\n\nPush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。\n\nPush Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读`Jake Archibald`的 [HTTP/2 push is tougher than I thought](https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F) 这篇文章，文章中的几个结论：\n\n+   所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差\n+   可以推送 no-cache 和 no-store 的资源\n+   一旦连接被关闭，Push Cache 就被释放\n+   多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。\n+   Push Cache 中的缓存只能被使用一次\n+   浏览器可以拒绝接受已经存在的资源推送\n+   你可以给其他域名推送资源\n\n如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。\n\n那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，**通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的**。\n\n## 三、缓存过程分析\n\n浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，**那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢**？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的**。具体过程如下图：\n\n第一次发起HTTP请求\n\n由上图我们可以知道：\n\n+   浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n    \n+   浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n    \n\n以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。\n\n## 四、强缓存\n\n**强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。**\n\n### 1.Expires\n\n**缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n**Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。\n\n### 2.Cache-Control\n\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。\n\nCache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：\n\nimage\n\n**public**：**所有内容都将被缓存（客户端和代理服务器都可缓存）**。具体来说响应可被任何中间节点缓存，如 Browser <-- proxy1 <-- proxy2 <-- Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。\n\n**private**：**所有内容只有客户端可以缓存**，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。\n\n**no-cache**：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。**需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。**\n\n**no-store**：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n**max-age**：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效\n\n**s-maxage**（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。**s-maxage的优先级高于max-age**。如果存在s-maxage，则会覆盖掉max-age和Expires header。\n\n**max-stale**：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。\n\n**min-fresh**：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。  \n\ncache-control\n\n从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。\n\n### 3.Expires和Cache-Control两者对比\n\n其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。  \n强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，**那我们如何获知服务器端内容是否已经发生了更新呢**？此时我们需要用到协商缓存策略。\n\n## 五、协商缓存\n\n**协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况**：\n\n+   协商缓存生效，返回304和Not Modified\n    \n      \n    \n    协商缓存生效\n    \n+   协商缓存失效，返回200和请求结果\n    \n\n协商缓存失效\n\n协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。\n\n### 1.Last-Modified和If-Modified-Since\n\n浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；\n\n```auto\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n```\n\n浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200\n\nimage\n\n#### 但是 Last-Modified 存在一些弊端：\n\n+   如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源\n+   因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源\n\n既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 `ETag` 和`If-None-Match`\n\n### 2.ETag和If-None-Match\n\n**Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成**。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。\n\nETag和If-None-Match\n\n### 3.两者之间对比：\n\n+   首先在精确度上，Etag要优于Last-Modified。\n\nLast-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n\n+   第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。\n+   第三在优先级上，服务器校验优先考虑Etag\n\n## 六、缓存机制\n\n**强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存**。具体流程图如下：\n\n缓存的机制\n\n看到这里，不知道你是否存在这样一个疑问:**如果什么缓存策略都没设置，那么浏览器会怎么处理？**\n\n对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。\n\n## 七、实际场景应用缓存策略\n\n### 1.频繁变动的资源\n\n> Cache-Control: no-cache\n\n对于频繁变动的资源，首先需要使用`Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。\n\n### 2.不常变化的资源\n\n> Cache-Control: max-age=31536000\n\n通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。  \n在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。\n\n## 八、用户行为对浏览器缓存的影响\n\n所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：\n\n+   打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。\n+   普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。\n+   强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`),服务器直接返回 200 和最新内容。\n\n## 参考文章\n\n+   [浅谈web缓存](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F03%2Fdiscussion-on-web-caching%2F)\n+   [web缓存机制](https://links.jianshu.com/go?to=https%3A%2F%2Fsweetamily.github.io%2F2018%2F11%2F06%2Fweb%25E7%25BC%2593%25E5%25AD%2598%25E6%259C%25BA%25E5%2588%25B6%2F)\n+   [彻底理解浏览器的缓存机制](https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMjM5MTA1MjAxMQ%3D%3D%26mid%3D2651228395%26idx%3D1%26sn%3Ddcf7e3bd518f1e189ce17eaed94c27bb%26chksm%3Dbd49516f8a3ed879221bf28bf68ac00c4733a6048c54ea90e75a9e2315a262c2d66fb29a4a34%26mpshare%3D1%26scene%3D1%26srcid%3D0419jU32MPcOkcBWJJVdgj2J%23rd)\n+   [前端面试之道](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fbook%2F5bdc715fe51d454e755f75ef%2Fsection%2F5c024ecbf265da616a476638)\n+   [一文读懂前端缓存](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5c22ee806fb9a049fb43b2c5%3Futm_source%3Dgold_browser_extension)\n+   [A Tale of Four Caches](https://links.jianshu.com/go?to=https%3A%2F%2Fcalendar.perfplanet.com%2F2016%2Fa-tale-of-four-caches%2F)\n+   [HTTP/2 push is tougher than I thought](https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F)\n+   [设计一个无懈可击的浏览器缓存方案：关于思路，细节，ServiceWorker，以及HTTP/2](https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28113197)"
    },
    {
      "id": "前端必备HTTP技能之同源策略详解",
      "metadata": {
        "permalink": "/前端必备HTTP技能之同源策略详解",
        "source": "@site/blog/前端必备HTTP技能之同源策略详解.md",
        "title": "前端必备HTTP技能之同源策略详解",
        "description": "请输入描述",
        "date": "2023-08-28T08:12:37.413Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 16.175,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "前端必备HTTP技能之同源策略详解",
          "title": "前端必备HTTP技能之同源策略详解",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "深入理解浏览器的缓存机制",
          "permalink": "/深入理解浏览器的缓存机制"
        },
        "nextItem": {
          "title": "react-redux之connect方法详解",
          "permalink": "/react-redux之connect方法详解"
        }
      },
      "content": "无衬线\n14px\n经典蓝\ngithub\n\n## 前端必备HTTP技能之同源策略详解\n​\n**同源策略**在web应用的安全模型中是一个重要概念。在这个策略下，web浏览器允许第一个页面的脚本访问第二个页面里的数据，但是也只有在两个页面有相同的源时。源是由URI，主机名，端口号组合而成的。这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。\n​\n对于普遍依赖于cookie维护授权用户session的现代浏览器来说，这种机制有特殊意义。客户端必须在不同站点提供的内容之间维持一个严格限制，以防丢失数据机密或者完整性。\n​\n## **历史**\n​\n同源策略的概念要追溯到1995年的[网景浏览器](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Netscape_Navigator_2)。同源策略作为一个重要的安全基石，所有的现代浏览器都在一定程度上实现了同源策略。同源策略虽然不是一个明确规范，但是经常为某些web技术（例如[Microsoft Silverlight](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Microsoft_Silverlight),[Adobe Flash](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Adobe_Flash),[Adobe Acrobat](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Adobe_Acrobat)）或者某些机制（例如XMLHttpRequest）扩展定义大致兼容的安全边界。\n​\n## **源决定规则**\n​\n[RFC6454](https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc6454)中有定义URI源的算法定义。对于绝对的URIs，源就是{协议，主机，端口}定义的。只有这些值完全一样才认为两个资源是同源的。\n​\n为了举例，下面的表格给出了与URL`\"http://www.example.com/dir/page.html\"`的对比。\n​\n| 对比URL | 结果 | 结果 |\n| --- | --- | --- |\n| `http://www.example.com/dir/page2.html` | 同源 | 相同的协议，主机，端口 |\n| `http://www.example.com/dir2/other.html` | 同源 | 相同的协议，主机，端口 |\n| `http://username:password@www.example.com/dir2/other.html` | 同源 | 相同的协议，主机，端口 |\n| `http://www.example.com:81/dir/other.html` | 不同源 | 相同的协议，主机，端口不同 |\n| `https://www.example.com/dir/other.html` | 不同源 | 协议不同 |\n| `http://en.example.com/dir/other.html` | 不同源 | 不同主机 |\n| `http://example.com/dir/other.html` | 不同源 | 不同主机(需要精确匹配) |\n| `http://v2.www.example.com/dir/other.html` | 不同源 | 不同主机(需要精确匹配) |\n| `http://www.example.com:80/dir/other.html` | 看情况 | 端口明确，依赖浏览器实现 |\n​\n不像其他浏览器，IE在计算源的时候没有包括端口。\n​\n## **安全考量**\n​\n有这种限制的主要原因就是如果没有同源策略将导致安全风险。假设用户在访问银行网站，并且没有登出。然后他又去了任意的其他网站，刚好这个网站有恶意的js代码，在后台请求银行网站的信息。因为用户目前仍然是银行站点的登陆状态，那么恶意代码就可以在银行站点做任意事情。例如，获取你的最近交易记录，创建一个新的交易等等。因为浏览器可以发送接收银行站点的session cookies，在银行站点域上。访问恶意站点的用户希望他访问的站点没有权限访问银行站点的cookie。当然确实是这样的，js不能直接获取银行站点的session cookie，但是他仍然可以向银行站点发送接收附带银行站点session cookie的请求，本质上就像一个正常用户访问银行站点一样。关于发送的新交易，甚至银行站点的CSRF（跨站请求伪造）防护都无能无力，因为脚本可以轻易的实现正常用户一样的行为。所以如果你需要session或者需要登陆时，所有网站都面临这个问题。如果上例中的银行站点只提供公开数据，你就不能触发任意东西，这样的就不会有危险了，这些就是同源策略防护的。当然，如果两个站点是同一个组织的或者彼此互相信任，那么就没有这种危险了。\n​\n## **规避同源策略**\n​\n在某些情况下同源策略太严格了，给拥有多个子域的大型网站带来问题。下面就是解决这种问题的技术：\n​\n##### document.domain属性\n​\n如果两个window或者frames包含的脚本可以把domain设置成一样的值，那么就可以规避同源策略，每个window之间可以互相沟通。例如，`orders.example.com`下页面的脚本和`catalog.example.com`下页面的脚本可以设置他们的`document.domain`属性为`example.com`，从而让这两个站点下面的文档看起来像在同源下，然后就可以让每个文档读取另一个文档的属性。这种方式也不是一直都有用，因为端口号是在内部保存的，有可能被保存成null。换句话说，`example.com`的端口号80，在我们更新`document.domain`属性的时候可能会变成null。为null的端口可能不被认为是80，这主要依赖浏览器实现。\n​\n##### 跨域资源共享\n前端必备HTTP技能之同源策略详解\n同源策略在web应用的安全模型中是一个重要概念。在这个策略下，web浏览器允许第一个页面的脚本访问第二个页面里的数据，但是也只有在两个页面有相同的源时。源是由URI，主机名，端口号组合而成的。这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。\n\n对于普遍依赖于cookie维护授权用户session的现代浏览器来说，这种机制有特殊意义。客户端必须在不同站点提供的内容之间维持一个严格限制，以防丢失数据机密或者完整性。\n\n历史\n同源策略的概念要追溯到1995年的网景浏览器。同源策略作为一个重要的安全基石，所有的现代浏览器都在一定程度上实现了同源策略。同源策略虽然不是一个明确规范，但是经常为某些web技术（例如Microsoft Silverlight,Adobe Flash,Adobe Acrobat）或者某些机制（例如XMLHttpRequest）扩展定义大致兼容的安全边界。\n\n源决定规则\nRFC6454中有定义URI源的算法定义。对于绝对的URIs，源就是{协议，主机，端口}定义的。只有这些值完全一样才认为两个资源是同源的。\n\n为了举例，下面的表格给出了与URL\"http://www.example.com/dir/page.html\"的对比。\n\n对比URL\t结果\t结果\nhttp://www.example.com/dir/page2.html\t同源\t相同的协议，主机，端口\nhttp://www.example.com/dir2/other.html\t同源\t相同的协议，主机，端口\nhttp://username:password@www.example.com/dir2/other.html\t同源\t相同的协议，主机，端口\nhttp://www.example.com:81/dir/other.html\t不同源\t相同的协议，主机，端口不同\nhttps://www.example.com/dir/other.html\t不同源\t协议不同\nhttp://en.example.com/dir/other.html\t不同源\t不同主机\nhttp://example.com/dir/other.html\t不同源\t不同主机(需要精确匹配)\nhttp://v2.www.example.com/dir/other.html\t不同源\t不同主机(需要精确匹配)\nhttp://www.example.com:80/dir/other.html\t看情况\t端口明确，依赖浏览器实现\n不像其他浏览器，IE在计算源的时候没有包括端口。\n\n安全考量\n有这种限制的主要原因就是如果没有同源策略将导致安全风险。假设用户在访问银行网站，并且没有登出。然后他又去了任意的其他网站，刚好这个网站有恶意的js代码，在后台请求银行网站的信息。因为用户目前仍然是银行站点的登陆状态，那么恶意代码就可以在银行站点做任意事情。例如，获取你的最近交易记录，创建一个新的交易等等。因为浏览器可以发送接收银行站点的session cookies，在银行站点域上。访问恶意站点的用户希望他访问的站点没有权限访问银行站点的cookie。当然确实是这样的，js不能直接获取银行站点的session cookie，但是他仍然可以向银行站点发送接收附带银行站点session cookie的请求，本质上就像一个正常用户访问银行站点一样。关于发送的新交易，甚至银行站点的CSRF（跨站请求伪造）防护都无能无力，因为脚本可以轻易的实现正常用户一样的行为。所以如果你需要session或者需要登陆时，所有网站都面临这个问题。如果上例中的银行站点只提供公开数据，你就不能触发任意东西，这样的就不会有危险了，这些就是同源策略防护的。当然，如果两个站点是同一个组织的或者彼此互相信任，那么就没有这种危险了。\n\n规避同源策略\n在某些情况下同源策略太严格了，给拥有多个子域的大型网站带来问题。下面就是解决这种问题的技术：\n\ndocument.domain属性\n如果两个window或者frames包含的脚本可以把domain设置成一样的值，那么就可以规避同源策略，每个window之间可以互相沟通。例如，orders.example.com下页面的脚本和catalog.example.com下页面的脚本可以设置他们的document.domain属性为example.com，从而让这两个站点下面的文档看起来像在同源下，然后就可以让每个文档读取另一个文档的属性。这种方式也不是一直都有用，因为端口号是在内部保存的，有可能被保存成null。换句话说，example.com的端口号80，在我们更新document.domain属性的时候可能会变成null。为null的端口可能不被认为是80，这主要依赖浏览器实现。\n\n跨域资源共享\n这种方式使用了一个新的Origin请求头和一个新的Access-Control-Allow-Origin响应头扩展了HTTP。允许服务端设置Access-Control-Allow-Origin头标识哪些站点可以请求文件，或者设置Access-Control-Allow-Origin头为\"*\"，允许任意站点访问文件。浏览器，例如Firefox3.5，Safari4，IE10使用这个头允许跨域HTTP请求。\n\n跨文档通信\n这种方式允许一个页面的脚本发送文本信息到另一个页面的脚本中，不管脚本是否跨域。在一个window对象上调用postMessage()会异步的触发window上的onmessage事件，然后触发定义好的事件处理方法。一个页面上的脚本仍然不能直接访问另外一个页面上的方法或者变量，但是他们可以安全的通过消息传递技术交流。\n\nJSONP\nJOSNP允许页面接受另一个域的JSON数据，通过在页面增加一个可以从其它域加载带有回调的JSON响应的script标签。\n\nWebSocket\n现代浏览器允许脚本直连一个WebSocket地址而不管同源策略。然而，使用WebSocket URI的时候，在请求中插入Origin头就可以标识脚本请求的源。为了确保跨站安全，WebSocket服务器必须根据允许接受请求的白名单中的源列表比较头数据。\n\n个例以及异常\n在一些个例中，例如哪些没有明确定义主机名或者端口的协议(file:,data:,等)，同源检查以及相关机制如何运作没有很好的定义。这在历史上导致了很多安全问题，例如任意本地存储的HTML文件不能访问磁盘上的其他文件，也不能与任何网络上的站点通信。\n\n另外，很多遗留的跨域操作，早期是不受同源策略限制的，例如script的跨域请求以及表单POST提交。\n\n最后，某些类型的攻击，例如DNS重新绑定，服务端代理，可以破坏主机名检查，让流氓页面可以直接通过地址与站点通信，尽管地址不是同源的。这种攻击的影响仅限于某些特殊情况下，例如，如果浏览器仍然相信正在通信的攻击者的站点，然后没有公开第三方cookie或者其他敏感信息给攻击者。\n\n变通方法\n为了让开发者可以在可控情况下绕过同源策略，一些\"hacks\"方法可以被用来在不同域的文档之间传输数据，例如fragment identifier ，window.name属性。根据HTML5标准，一个postMessage接口可以实现这样的功能，但是只有最新的浏览器才支持。JSONP也可以用来保证通过类似Ajax的方式访问跨域资源。\n\n做好前端开发必须对HTTP的相关知识有所了解，所以我创建了一个专题前端必备HTTP技能专门收集前端相关的HTTP知识，欢迎关注，投稿。"
    },
    {
      "id": "react-redux之connect方法详解",
      "metadata": {
        "permalink": "/react-redux之connect方法详解",
        "source": "@site/blog/react-redux之connect方法详解.md",
        "title": "react-redux之connect方法详解",
        "description": "请输入描述",
        "date": "2023-08-28T08:10:47.602Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 9.545,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "react-redux之connect方法详解",
          "title": "react-redux之connect方法详解",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "前端必备HTTP技能之同源策略详解",
          "permalink": "/前端必备HTTP技能之同源策略详解"
        },
        "nextItem": {
          "title": "深入理解Redux中间件的原理",
          "permalink": "/深入理解Redux中间件的原理"
        }
      },
      "content": "Redux 是「React 全家桶」中极为重要的一员，它试图为 React 应用提供「可预测化的状态管理」机制。Redux 本身足够简单，除了 React，它还能够支持其他界面框架。所以如果要将 Redux 和 React 结合起来使用，就还需要一些额外的工具，其中最重要的莫过于 react-redux 了。\n\nreact-redux 提供了两个重要的对象，`Provider`和`connect`，前者使`React`组件可被连接（connectable），后者把 React 组件和 Redux 的 store 真正连接起来。react-redux 的文档中，对`connect`的描述是一段晦涩难懂的英文，在初学 redux 的时候，我对着这段文档阅读了很久，都没有全部弄明白其中的意思（大概就是，单词我都认识，连起来啥意思就不明白了的感觉吧）。\n\n在使用了一段时间 redux 后，本文尝试再次回到这里，给[这段文档](https://link.segmentfault.com/?enc=J13Z2QXiks8vTWp12aptuw%3D%3D.7MdxRL92fQ3PDKndvytBjr%2Fxs5a3WJ9sB9sFLX7w31Cmh3Dq4QNHikXBkgkA3LOFq5y%2BXLAIuYR1quNfPrJiwS5dRyaOL9eU2UMIlA5ulXXhs8HeJc8wDVpB%2FC9CGIvIARjwqWLjvChJYQbpOWqHsjmpdENGGL67VF0VF8gsGg4%3D)一个靠谱的解读。\n\n## 预备知识\n\n首先回顾一下 redux 的基本用法。如果你还没有阅读过 redux 的文档，你一定要先去[阅读](https://link.segmentfault.com/?enc=0v0gsyuh%2BfiE%2FNd3XEnviQ%3D%3D.IGT4JSCGdhY1k5irJ101a2y28dkorOY7V0FUklWyO3xKYb5YlqPn8LvatTcJd18lgcqlHaBTViWXcXgLSPA6tQ%3D%3D)一下。\n\n```javascript\nconst reducer = (state = {count: 0}, action) => {\n  switch (action.type){\n    case 'INCREASE': return {count: state.count + 1};\n    case 'DECREASE': return {count: state.count - 1};\n    default: return state;\n  }\n}\n\nconst actions = {\n  increase: () => ({type: 'INCREASE'}),\n  decrease: () => ({type: 'DECREASE'})\n}\n\nconst store = createStore(reducer);\n\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\nstore.dispatch(actions.increase()) // {count: 1}\nstore.dispatch(actions.increase()) // {count: 2}\nstore.dispatch(actions.increase()) // {count: 3}\n```\n\n通过`reducer`创建一个`store`，每当我们在`store`上`dispatch`一个`action`，`store`内的数据就会相应地发生变化。\n\n我们当然可以直接在 React 中使用 Redux：在最外层容器组件中初始化`store`，然后将`state`上的属性作为`props`层层传递下去。\n\n```jsx\nclass App extends Component{\n\n  componentWillMount(){\n    store.subscribe((state)=>this.setState(state))\n  }\n\n  render(){\n    return (\n      <Comp\n        state={this.state}\n        onIncrease={()=>store.dispatch(actions.increase())}\n        onDecrease={()=>store.dispatch(actions.decrease())}\n      />\n    )\n  }\n}\n```\n\n> 转载注：\n> \n> +   另一种方法，在入口文件`index.js`中初始化`store`，并将其`export`出来，然后`import`到定义组件的文件中去。\n\n但这并不是最佳的方式。最佳的方式是使用 react-redux 提供的`Provider`和`connect`方法。\n\n## 使用 react-redux\n\n首先在最外层容器中，把所有内容包裹在`Provider`组件中，将之前创建的`store`作为`prop`传给`Provider`。\n\n```jsx\nconst App = () => {\n  return (\n    <Provider store={store}>\n      <Comp/>\n    </Provider>\n  )\n};\n```\n\n`Provider`内的任何一个组件（比如这里的`Comp`），如果需要使用`state`中的数据，就必须是「被 connect 过的」组件——使用`connect`方法对「你编写的组件（`MyComp`）」进行包装后的产物。\n\n```javascript\nclass MyComp extends Component {\n  // content...\n}\n\nconst Comp = connect(...args)(MyComp);\n```\n\n可见，`connect`方法是重中之重。\n\n## connect\n\n究竟`connect`方法到底做了什么，我们来一探究竟。\n\n首先看下函数的签名：\n\n```javascript\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\n```\n\n`connect()`接收四个参数，它们分别是`mapStateToProps`，`mapDispatchToProps`，`mergeProps`和`options`。\n\n### mapStateToProps\n\n```javascript\nmapStateToProps(state, ownProps) : stateProps\n```\n\n这个函数允许我们将`store`中的数据作为`props`绑定到组件上。\n\n```javascript\nconst mapStateToProps = (state) => {\n  return {\n    count: state.count\n  }\n}\n```\n\n这个函数的第一个参数就是 Redux 的`store`，我们从中摘取了`count`属性。因为返回了具有`count`属性的对象，所以`MyComp`会有名为`count`的`props`字段。\n\n```jsx\nclass MyComp extends Component {\n  render(){\n    return <div>计数：{this.props.count}次</div>\n  }\n}\n\nconst Comp = connect(...args)(MyComp);\n```\n\n当然，你不必将`state`中的数据原封不动地传入组件，可以根据`state`中的数据，动态地输出组件需要的（最小）属性。\n\n```javascript\nconst mapStateToProps = (state) => {\n  return {\n    greaterThanFive: state.count > 5\n  }\n}\n```\n\n函数的第二个参数`ownProps`，是`MyComp`自己的`props`。有的时候，`ownProps`也会对其产生影响。比如，当你在`store`中维护了一个用户列表，而你的组件`MyComp`只关心一个用户（通过`props`中的`userId`体现）。\n\n```jsx\nconst mapStateToProps = (state, ownProps) => {\n  // state 是 {userList: [{id: 0, name: '王二'}]}\n  return {\n    user: _.find(state.userList, {id: ownProps.userId})\n  }\n}\n\nclass MyComp extends Component {\n  \n  static PropTypes = {\n    userId: PropTypes.string.isRequired,\n    user: PropTypes.object\n  };\n  \n  render(){\n    return <div>用户名：{this.props.user.name}</div>\n  }\n}\n\nconst Comp = connect(mapStateToProps)(MyComp);\n```\n\n当`state`变化，或者`ownProps`变化的时候，`mapStateToProps`都会被调用，计算出一个新的`stateProps`，（在与`ownProps` merge 后）更新给`MyComp`。\n\n这就是将 Redux `store`中的数据连接到组件的基本方式。\n\n> 转载注：\n> \n> +   **什么叫做“`MyComp`自己的`props`”？**假设在不使用 react-redux 的时候，`MyComp`的父组件是`ParentComp`，那么上文中的`ownProps`是`ParentComp`传递给`MyComp`的全部属性（对于下文中的方法`mapDispatchToProps`亦同）。**也就是说，`ownProps`与 Redux 的`store`与`state`完全无关**。\n> +   **方法`mapStateToProps`为`MyComp`添加的属性，不可能被方法`mapDispatchToProps`访问到，反之亦然。**因为，这涉及到 render 的时机和顺序的问题，笔者在这上面踩过相当多的坑。至于笔者为什么有这种需求，因为笔者设计了一个按钮，功能是：在点击后，根据当前的 state 计算出下一个 state，并更新。在经历了无数`error`以后，笔者终于意识到：react-redux 根本就不是设计用来解决这类问题的。解决方案有两种：一是，在设计 reducer 的时候，就直接根据 state 更新；二是，导入全局`store`并使用 `store.getState()` 获得当前`state`，然后根据这个`state`进行更新。\n> +   另外，如果使用[PropTypes](https://link.segmentfault.com/?enc=NAHThrozvnEJWihMg6iaaw%3D%3D.jIuZKGFC2HTJNcGahJqrj%2BOvLbtoSr4Y3cchdNlGZe3p9Tb58F8YL8sBX1vk3yqdA8b%2FvPDUnm7sdzFLKGpavg%3D%3D)对`MyComp`做属性类型检查，方法`mapStateToProps`和方法`mapDispatchToProps`为`MyComp`添加的属性是存在的。\n\n### mapDispatchToProps\n\n```javascript\nmapDispatchToProps(dispatch, ownProps): dispatchProps\n```\n\nconnect 的第二个参数是`mapDispatchToProps`，它的功能是，将`action`作为`props`绑定到`MyComp`上。\n\n```jsx\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    increase: (...args) => dispatch(actions.increase(...args)),\n    decrease: (...args) => dispatch(actions.decrease(...args))\n  }\n}\n\nclass MyComp extends Component {\n  render(){\n    const {count, increase, decrease} = this.props;\n    return (<div>\n      <div>计数：{this.props.count}次</div>\n      <button onClick={increase}>增加</button>\n      <button onClick={decrease}>减少</button>\n    </div>)\n  }\n}\n\nconst Comp = connect(mapStateToProps， mapDispatchToProps)(MyComp);\n```\n\n由于`mapDispatchToProps`方法返回了具有`increase`属性和`decrease`属性的对象，这两个属性也会成为`MyComp`的`props`。\n\n如上所示，调用`actions.increase()`只能得到一个`action`对象`{type:'INCREASE'}`，要触发这个`action`必须在`store`上调用`dispatch`方法。`dispatch`正是`mapDispatchToProps`的第一个参数。但是，为了不让 MyComp 组件感知到`dispatch`的存在，我们需要将`increase`和`decrease`两个函数包装一下，使之成为直接可被调用的函数（即，调用该方法就会触发`dispatch`）。\n\nRedux 本身提供了`bindActionCreators`函数，来将`action`包装成直接可被调用的函数。\n\n```javascript\nimport {bindActionCreators} from 'redux';\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return bindActionCreators({\n    increase: action.increase,\n    decrease: action.decrease\n  });\n}\n```\n\n同样，当`ownProps`变化的时候，该函数也会被调用，生成一个新的`dispatchProps`，（在与`stateProps`和`ownProps` merge 后）更新给`MyComp`。注意，`action`的变化不会引起上述过程，默认`action`在组件的生命周期中是固定的。\n\n> 转载注：\n> \n> +   函数`connect`甚至`react-redux`的核心在于：将 Redux 中 store 的 state 绑定到组件的属性上，使得对 state 的修改能够直接体现为组件外观的更改。因此，参数`mapStateToProps`是非常重要的，但是参数`mapDispatchToProps`则比较多余——因为简单粗暴地导入全局 store 同样能达到相同的目的（事实上笔者就是这么做的）。\n\n### mergeProps\n\n```javascript\n[mergeProps(stateProps, dispatchProps, ownProps): props]\n```\n\n之前说过，不管是`stateProps`还是`dispatchProps`，都需要和`ownProps` merge 之后才会被赋给`MyComp`。`connect`的第三个参数就是用来做这件事。通常情况下，你可以不传这个参数，`connect`就会使用`Object.assign`替代该方法。\n\n## 其他\n\n最后还有一个`options`选项，比较简单，基本上也不大会用到（尤其是你遵循了其他的一些 React 的「最佳实践」的时候），本文就略过了。希望了解的同学可以直接看文档。\n\n（完）"
    },
    {
      "id": "深入理解Redux中间件的原理",
      "metadata": {
        "permalink": "/深入理解Redux中间件的原理",
        "source": "@site/blog/深入理解Redux中间件的原理.md",
        "title": "深入理解Redux中间件的原理",
        "description": "请输入描述",
        "date": "2023-08-28T08:09:50.985Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 20.975,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "深入理解Redux中间件的原理",
          "title": "深入理解Redux中间件的原理",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "react-redux之connect方法详解",
          "permalink": "/react-redux之connect方法详解"
        },
        "nextItem": {
          "title": "Redux原理解析与实现",
          "permalink": "/Redux原理解析与实现"
        }
      },
      "content": "1、redux中间件简介  \n1.1、什么是redux中间件  \nredux 提供了类似后端 Express 的中间件概念，本质的目的是提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。\n\n通俗来说，redux中间件就是对dispatch的功能做了扩展。\n\n先来看一下传统的redux执行流程：  \n![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220124/1643016257422092330.png)\n\n代码示例：\n\n```js\nimport { createStore } from 'redux';\n\n/**\n * 这是一个 reducer，形式为 (state, action) => state 的纯函数。\n * 描述了 action 如何把 state 转变成下一个 state。\n */\nfunction counter(state = 0, action) {\n  switch (action.type) {\n  case 'INCREMENT':\n    return state + 1;\n  case 'DECREMENT':\n    return state - 1;\n  default:\n    return state;\n  }\n}\n\n// 创建 Redux store 来存放应用的状态。\n// API 是 { subscribe, dispatch, getState }。\nlet store = createStore(counter);\n\n// 可以手动订阅更新，也可以事件绑定到视图层。\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\n// 改变内部 state 惟一方法是 dispatch 一个 action。\n// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行\nstore.dispatch({ type: 'INCREMENT' });\n// 1\nstore.dispatch({ type: 'INCREMENT' });\n// 2\nstore.dispatch({ type: 'DECREMENT' });\n// 1\n```\n\nRedux的核心概念其实很简单：将需要修改的state都存入到store里，发起一个action用来描述发生了什么，用reducers描述action如何改变state tree 。创建store的时候需要传入reducer，真正能改变store中数据的是store.dispatch API。\n\n对dispatch改造后，效果如下：  \n![image.png](https://bbs-img.huaweicloud.com/blogs/img/20220124/1643016304229047381.png)  \n如上图所示，dispatch派发给 redux Store 的 action 对象，到达reducer之前，进行一些额外的操作，会被 Store 上的多个中间件依次处理。例如可以利用中间件来进行日志记录、创建崩溃报告、调用异步接口或者路由等等，那么其实所有的对 action 的处理都可以有中间件组成的。 简单来说，中间件就是对store.dispatch()的增强。  \n1.2、使用redux中间件  \nredux有很多中间件，我们这里以 redux-thunk 为例。\n\n代码示例：\n\n```js\nimport { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\n const store = createStore(\n  reducers, \n  applyMiddleware(thunk)\n);\n```\n\n直接将thunk中间件引入，放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。即可以在reducer中进行一些异步的操作。\n\nRedux middleware 提供了一个分类处理 action 的机会。在 middleware 中，我们可以检阅每一个流过的 action,并挑选出特定类型的 action 进行相应操作，以此来改变 action。其实applyMiddleware就是Redux的一个原生方法，将所有中间件组成一个数组，依次执行。  \n中间件多了可以当做参数依次传进去。\n\n代码示例：\n\n```js\nimport { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\nimport createLogger from 'redux-logger';\n\nconst logger = createLogger();\n\nconst store = createStore(\n  reducers, \n  applyMiddleware(thunk, logger) //会按顺序执行\n);\n```\n\n2、中间件的运行机制  \n2.1、createStore源码分析  \n源码：\n\n```js\n// 摘至createStore\nexport function createStore(reducer, rootState, enhance) {\n    //...\n    \n    if (typeof enhancer !== 'undefined') {\n        if (typeof enhancer !== 'function') {\n          throw new Error('Expected the enhancer to be a function.')\n        }\n       /*\n        若使用中间件，这里 enhancer 即为 applyMiddleware()\n        若有enhance，直接返回一个增强的createStore方法，可以类比成react的高阶函数\n       */\n       return enhancer(createStore)(reducer, preloadedState)\n  }\n    \n  //...\n}\n```\n\n对于createStore的源码我们只需要关注和applyMiddleware有关的地方， 通过源码得知在调用createStore时传入的参数进行一个判断，并对参数做矫正。 据此可以得出createStore有多种使用方法，根据第一段参数判断规则，我们可以得出createStore的两种使用方式：\n\n```js\nconst store = createStore(reducer, {a: 1, b: 2}, applyMiddleware(...));\n```\n\n或：\n\n```js\nconst store = createStore(reducer, applyMiddleware(...));\n\n```\n\n经过createStore中的第一个参数判断规则后，对参数进行了校正，得到了新的enhancer得值，如果新的enhancer的值不为undeifined，便将createStore传入enhancer(即applyMiddleware调用后返回的函数)内，让enhancer执行创建store的过程。也就时说这里的：\n\n```js\nenhancer(createStore)(reducer, preloadedState);\n```\n\n实际上等同于：\n\n```js\napplyMiddleware(mdw1, mdw2, mdw3)(createStore)(reducer, preloadedState);\n```\n\napplyMiddleware会有两层柯里化，同时表明它还有一种很函数式编程的用法，即\n\n```js\nconst store = applyMiddleware(mdw1, mdw2, mdw3)(createStore);\n```\n\n这种方式将创建store的步骤完全放在了applyMiddleware内部，并在其内第二层柯里化的函数内执行创建store的过程即调用createStore，调用后程序将跳转至createStore走参数判断流程最后再创建store。\n\n无论哪一种执行createStore的方式，我们都终将得到store，也就是在creaeStore内部最后返回的那个包含dispatch、subscribe、getState等方法的对象。\n\n2.2、applyMiddleware源码分析  \n源码：\n\n```js\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    // 利用传入的createStore和reducer和创建一个store\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n      )\n    }\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n    dispatch = compose(...chain)(store.dispatch)\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n为方便阅读和理解，部分ES6箭头函数已修改为ES5的普通函数形式，如下：\n\n```js\nfunction applyMiddleware (...middlewares){\n    return function (createStore){\n        return function (reducer, preloadedState, enhancer){\n            const store = createStore(reducer, preloadedState, enhancer);\n            let dispatch = function (){\n                throw new Error()\n            };\n\n            const middlewareAPI = {\n                getState: store.getState,\n                dispatch: (...args) => dispatch(...args)\n            };\n            //一下两行代码是所有中间件被串联起来的核心部分实现\n\t\t\t// 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍\n            const chain = middlewares.map(middleware => middleware(middlewareAPI));\n\t\t\t// 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n            dispatch = compose(...chain)(store.dispatch);\n\n            return {\n                ...store,\n                dispatch\n            };\n        }\n    }\n}\n\n```\n\n从上面的代码我们不难看出，applyMiddleware 这个函数的核心就在于在于组合 compose，通过将不同的 middlewares 一层一层包裹到原生的 dispatch 之上，然后对 middleware 的设计采用柯里化的方式，以便于compose ，从而可以动态产生 next 方法以及保持 store 的一致性。\n\n在函数式编程(Functional Programming)相关的文章中，经常能看到 柯里化（Currying）这个名词。它是数学家柯里（Haskell Curry）提出的。\n\n柯里化，用一句话解释就是，把一个多参数的函数转化为单参数函数的方法。\n\n根据源码，我们可以将其主要功能按步骤划分如下：\n\n1、依次执行middleware\n\n将middleware执行后返回的函数合并到一个chain数组，这里我们有必要看看标准middleware的定义格式，如下：\n\n```js\nconst chain = middlewares.map(middleware => middleware(middlewareAPI));\n\n```\n\n遍历所有的中间件，并调用它们，传入那个类似于store的对象middlewareAPI，这会导致中间件中第一层柯里化函数被调用，并返回一个接收next(即dispatch)方法作为参数的新函数。\n\n```js\nexport default store => next => action => {}\n\n// 即\nfunction (store) {\n    return function(next) {\n        return function (action) {\n            return {}\n        }\n    }\n}\n\n```\n\n那么此时合并的chain结构如下：\n\n```js\n[    ...,\n    function(next) {\n        return function (action) {\n            return {}\n        }\n    }\n]\n```\n\n2、改变dispatch指向\n\n```js\ndispatch = compose(...chain)(store.dispatch);\n```\n\n我们展开了这个数组，并将其内部的元素(函数)传给了compose函数，compose函数又返回了我们一个新函数。然后我们再调用这个新函数并传入了原始的未经任何修改的dispatch方法，最后返回一个经过了修改的新的dispatch方法。\n\n什么是compose？在函数式编程中，compose指接收多个函数作为参数，并返回一个新的函数的方式。调用新函数后传入一个初始的值作为参数，该参数经最后一个函数调用，将结果返回并作为倒数第二个函数的入参，倒数第二个函数调用完后，将其结果返回并作为倒数第三个函数的入参，依次调用，知道最后调用完传入compose的所有的函数后，返回一个最后的结果。\n\ncompose函数如下：  \n\\[…chain\\].reduce((a, b) => (…args) => a(b(…args)))  \n实际就是一个柯里化函数，即将所有的middleware合并成一个middleware，并在最后一个middleware中传入当前的dispatch。\n\n```js\n// 假设chain如下：\nchain = [\n    a: next => action => { console.log('第1层中间件') return next(action) }\n    b: next => action => { console.log('第2层中间件') return next(action) }\n    c: next => action => { console.log('根dispatch') return next(action) }\n]\n```\n\n调用compose(…chain)(store.dispatch)后返回a(b(c(dispatch)))。  \n可以发现已经将所有middleware串联起来了，并同时修改了dispatch的指向。  \n最后看一下这时候compose执行返回，如下：\n\n```js\ndispatch = a(b(c(dispatch)))\n\n// 调用dispatch(action)\n// 执行循序\n/*\n   1. 调用 a(b(c(dispatch)))(action) __print__: 第1层中间件\n   2. 返回 a: next(action) 即b(c(dispatch))(action)\n   3. 调用 b(c(dispatch))(action) __print__: 第2层中间件\n   4. 返回 b: next(action) 即c(dispatch)(action)\n   5. 调用 c(dispatch)(action) __print__: 根dispatch\n   6. 返回 c: next(action) 即dispatch(action)\n   7. 调用 dispatch(action)\n*/\n```\n\n总结来说就是：\n\n在中间件串联的时候，middleware1-3的串联顺序是从右至左的，也就是middleware3被包裹在了最里面，它内部含有对原始的store.dispatch的调用，middleware1被包裹在了最外边。\n\n当我们在业务代码中dispatch一个action时，也就是中间件执行的时候，middleware1-3的执行顺序是从左至右的，因为最后被包裹的中间件，将被最先执行。\n\n3、常见的redux中间件  \n3.1、logger日志中间件  \n源码\n\n```js\nfunction createLogger(options = {}) {\n  /**\n   * 传入 applyMiddleWare 的函数\n   * @param  {Function} { getState      }) [description]\n   * @return {[type]}      [description]\n   */\n  return ({ getState }) => (next) => (action) => {\n    let returnedValue;\n    const logEntry = {};\n    logEntry.prevState = stateTransformer(getState());\n    logEntry.action = action;\n    // .... \n    returnedValue = next(action);\n    // ....\n    logEntry.nextState = stateTransformer(getState());\n    // ....\n    return returnedValue;\n  };\n}\n\nexport default createLogger;\n```\n\n为了方便查看，将代码修改为ES5之后，如下：\n\n```js\n/**\n * getState 可以返回最新的应用 store 数据\n */\nfunction ({getState}) {\n    /**\n     * next 表示执行后续的中间件，中间件有可能有多个\n     */\n    return function (next) {\n        /**\n         * 中间件处理函数，参数为当前执行的 action \n         */\n        return function (action) {...}\n    }\n}\n\n```\n\n这样的结构本质上就是为了将 middleware 串联起来执行。\n\n3.2、redux异步管理中间件  \n在多种中间件中，处理 redux 异步事件的中间件，绝对占有举足轻重的地位。从简单的 react-thunk 到 redux-promise 再到 redux-saga等等，都代表这各自解决redux异步流管理问题的方案。\n\n3.2.1、redux-thunk  \nredux-thunk的使用：\n\n```js\nfunction getWeather(url, params) {\n   return (dispatch, getState) => {\n       fetch(url, params)\n           .then(result => {\n               dispatch({\n                   type: 'GET_WEATHER_SUCCESS', payload: result,\n               });\n           })\n           .catch(err => {\n               dispatch({\n                   type: 'GET_WEATHER_ERROR', error: err,\n               });\n           });\n       };\n}\n```\n\n在上述使用实例中，我们应用thunk中间到redux后，可以dispatch一个方法，在方法内部我们想要真正dispatch一个action对象的时候再执行dispatch即可，特别是异步操作时非常方便。\n\n源码：\n\n```js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n\n为了方便阅读，源码中的箭头函数在这里换成了普通函数，如下：\n\n```js\nfunction createThunkMiddleware (extraArgument){\n    return function ({dispatch, getState}){\n        return function (next){\n            return function (action){\n                if (typeof action === 'function'){\n                    return action(dispatch, getState, extraArgument);\n                }\n                return next(action);\n            };\n        }\n    }\n}\n\nlet thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n\n```\n\nthunk是一个很常用的redux中间件，应用它之后，我们可以dispatch一个方法，而不仅限于一个纯的action对象。它的源码也很简单，如上所示，除去语法固定格式也就区区几行。\n\n下面我们就来看看源码(为了方便阅读，源码中的箭头函数在这里换成了普通函数)，首先是这三层柯里化：\n\n```js\n// 外层\nfunction createThunkMiddleware (extraArgument){\n    // 第一层\n   return function ({dispatch, getState}){\n      // 第二层\n       return function (next){\n           // 第三层\n           return function (action){\n               if (typeof action === 'function'){\n                   return action(dispatch, getState, extraArgument);\n               }\n               return next(action);\n           };\n       }\n   }\n}\n```\n\n首先是外层，上面的源码可知，这一层存在的主要目的是支持在调用applyMiddleware并传入thunk的时候时候可以不直接传入thunk本身，而是先调用包裹了thunk的函数(第一层柯里化的父函数)并传入需要的额外参数，再将该函数调用的后返回的值(也就是真正的thunk)传给applyMiddleware，从而实现对额外参数传入的支持，使用方式如下：\n\n```js\nconst store = createStore(reducer, applyMiddleware(thunk.withExtraArgument({api, whatever})))；\n\n```\n\n如果无需额外参数则用法如下：\n\n```js\nconst store = createStore(reducer, applyMiddleware(thunk))；\n\n```\n\n接下来来看第一层，这一层是真正applyMiddleware能够调用的一层，从形参来看，这个函数接收了一个类似于store的对象，因为这个对象被结构以后获取了它的dispatch和getState这两个方法，巧的是store也有这两方法，但这个对象到底是不是store，还是只借用了store的这两方法合成的一个新对象？这个问题在我们后面分析applyMiddleware源码时，自会有分晓。\n\n再来看第二层，在第二层这个函数中，我们接收的一个名为next的参数，并在第三层函数内的最后一行代码中用它去调用了一个action对象，感觉有点 dispatch({type: ‘XX\\_ACTION’， data: {}}) 的意思，因为我们可以怀疑它就是一个dispatch方法，或者说是其他中间件处理过的dispatch方法，似乎能通过这行代码链接上所有的中间件，并在所有只能中间件自身逻辑处理完成后，最终调用真实的 store.dispath 去dispatch一个action对象，再走到下一步，也就是reducer内。\n\n最后我们看看第三层，在这一层函数的内部源码中首先判断了action的类型，如果action是一个方法，我们就调用它，并传入dispatch、getState、extraArgument三个参数，因为在这个方法内部，我们可能需要调用到这些参数，至少dispatch是必须的。\\*\\*这三行源码才是真正的thunk核心所在。所有中间件的自身功能逻辑也是在这里实现的。\\*\\*如果action不是一个函数，就走之前解析第二层时提到的步骤。\n\n3.2.2、redux-promise  \n不同的中间件都有着自己的适用场景，react-thunk 比较适合于简单的API请求的场景，而 Promise 则更适合于输入输出操作，比较fetch函数返回的结果就是一个Promise对象，下面就让我们来看下最简单的 Promise 对象是怎么实现的：\n\n```js\nimport { isFSA } from 'flux-standard-action';\n\nfunction isPromise(val) {\n return val && typeof val.then === 'function';\n}\n\nexport default function promiseMiddleware({ dispatch }) {\n return next => action => {\n   if (!isFSA(action)) {\n     return isPromise(action)\n       ? action.then(dispatch)\n       : next(action);\n   }\n\n   return isPromise(action.payload)\n     ? action.payload.then(\n         result => dispatch({ ...action, payload: result }),\n         error => {\n           dispatch({ ...action, payload: error, error: true });\n           return Promise.reject(error);\n         }\n       )\n     : next(action);\n };\n}\n```\n\n它的逻辑也很简单主要是下面两部分：\n\n先判断是不是标准的 flux action。如果不是，那么判断是否是 promise, 是的话就执行 action.then(dispatch)，否则执行 next(action)。  \n如果是, 就先判断 payload 是否是 promise，如果是的话 payload.then 获取数据，然后把数据作为 payload 重新 dispatch({ …action, payload: result})；不是的话就执行 next(action)  \n结合 redux-promise 我们就可以利用 es7 的 async 和 await 语法，来简化异步操作了，比如这样：\n\n```js\nconst fetchData = (url, params) => fetch(url, params)\nasync function getWeather(url, params) {\n    const result = await fetchData(url, params)\n    if (result.error) {\n        return {\n            type: 'GET_WEATHER_ERROR', error: result.error,\n        }\n    }\n        return {\n            type: 'GET_WEATHER_SUCCESS', payload: result,\n        }\n    }\n```\n\nsaga特点：\n\nsaga 的应用场景是复杂异步。  \n可以使用 takeEvery 打印 logger（logger大法好），便于测试。  \n提供 takeLatest/takeEvery/throttle 方法，可以便利的实现对事件的仅关注最近实践还是关注每一次实践的时间限频。  \n提供 cancel/delay 方法，可以便利的取消或延迟异步请求。  \n提供 race(effects)，\\[…effects\\] 方法来支持竞态和并行场景。  \n提供 channel 机制支持外部事件。\n\n```js\nfunction *getCurrCity(ip) {\n   const data = yield call('/api/getCurrCity.json', { ip })\n   yield put({\n       type: 'GET_CITY_SUCCESS', payload: data,\n   })\n}\nfunction * getWeather(cityId) {\n   const data = yield call('/api/getWeatherInfo.json', { cityId })\n   yield put({\n       type: 'GET_WEATHER_SUCCESS', payload: data,\n   })\n}\nfunction loadInitData(ip) {\n   yield getCurrCity(ip)\n   yield getWeather(getCityIdWithState(state))\n   yield put({\n       type: 'GET_DATA_SUCCESS',\n   })\n}\n```\n\n总的来讲Redux Saga适用于对事件操作有细粒度需求的场景，同时它也提供了更好的可测试性，与可维护性，比较适合对异步处理要求高的大型项目，而小而简单的项目完全可以使用redux-thunk就足以满足自身需求了。毕竟react-thunk对于一个项目本身而言，毫无侵入，使用极其简单，只需引入这个中间件就行了。而react-saga则要求较高，难度较大。"
    },
    {
      "id": "Redux原理解析与实现",
      "metadata": {
        "permalink": "/Redux原理解析与实现",
        "source": "@site/blog/Redux原理解析与实现.md",
        "title": "Redux原理解析与实现",
        "description": "请输入描述",
        "date": "2023-08-28T08:09:11.823Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 17.805,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "Redux原理解析与实现",
          "title": "Redux原理解析与实现",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "深入理解Redux中间件的原理",
          "permalink": "/深入理解Redux中间件的原理"
        },
        "nextItem": {
          "title": "React中的forwardRef究竟该怎么用",
          "permalink": "/React中的forwardRef究竟该怎么用"
        }
      },
      "content": "## Redux\n\n对于 SPA 应用来说，前端所需要管理的状态渐渐增多，需要查询、更新、传递的状态也渐渐增多，如果让每个组件都存储自身相关的状态，理论上是不影响应用运行的，但是在开发以及后续升级维护阶段，我们将花费大量的精力去查询状态的变化过程，在多组合组件通信或客户端与服务端有较多交互过程中，我们往往需要去更新，维护并监听每一个组件的状态。\n\n在这种情况下，如果有一种可以对状态做集中管理的地方是不是会更好呢？状态管理好比是一个集中在一起的总的配置箱，当需要更新状态的时候，我们仅对这个配置箱镜进行输入，而不用去关心开关状态是如何分发到每个组件内部的，这样开发者能把更多精力放在业务逻辑上。 今天我们来了详细了解下`redux`这个库，看看它能帮助我们干些什么....\n\n## 什么是 Redux ？\n\n“Redux is a pattern and library for managing and updating application state, using events called \"actions\". It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.”\n\n简单意思就是；`Redux` 是一个有用的架构，用操作的事件来管理和更新应用的状态，在整个应用中，它用于状态集中存储，状态的更新必须是一种可预测的方式更新。\n\n## 为什么要用 Redux ?\n\n官方解释：\" It helps to understand what this \"Redux\" thing is in the first place. What does it do? What problems does it help me solve? Why would I want to use it?\n\nRedux is a pattern and library for managing and updating application state, using events called \"actions\". It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion. \"\n\n其实，状态管理不是必须的，当你UI层比较简单或者没有较多的交互需要去改变状态的场景下，使用状态管理方式反而提高项目的复杂度，`Redux`作者 Daniel Abramov 就说过”只有遇到`React`实在解决不了的问题，你才需要`Redux`。\n\n## 何时使用redux?\n\n1.多交互，多数据源等场景：\n\n+   用户的使用方式复杂\n+   不同身份的用户有不同的使用方式（比如普通用户和管理员）\n+   多个用户之间可以协作\n+   与服务器大量交互，或者使用了`WebSocket`\n+   View要从多个来源获取数据\n\n2.组件角度，以下场景可考虑`Redux`：\n\n+   某个组件的状态，需要共享\n+   某个组件状态需要在任何地方都可以拿到\n+   一个组件需要改变全局状态\n+   一个组件需要改变另一个组件的状态\n\n发生上面情况时，如果不使用`Redux`或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。 另外，本篇文章更关注业务模型层的数据流，业务模型是指所处领域的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也可以不依赖于展示层而独立运行，这里要强调一点，`Redux`之类的状态管理库充当了一个应用的业务模型层，并不会受限于如`React`之类的`View`层。假如你已经明白了`Redux`的定位及应用场景的话，我们来对其原理一探究竟。\n\n## 设计思想\n\n`Redux`的设计思想很简单，用阮老师的两句话：\n\n+   `Web`应用是一个状态机，视图与状态是一一对应的。\n+   所有的状态，保存在一个对象里面。\n\n## Redux的三大原则\n\n+   单一数据源\n    \n    整个应用的`state` 被储存在一棵`object tree`中，并且这个`object tree`只存在于唯一一个`store`中。\n    \n    这让同构应用开发变得非常容易。来自服务端的`state`可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 `state tree`，调试也变得非常容易。在开发中，你可以把应用的`state`保存在本地，从而加快开发速度。此外，受益于单一的`state tree` ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。\n    \n+   State是只读的\n    \n    唯一改变`state`的方法就是触发`action`，`action` 是一个用于描述已发生事件的普通对象。 这样确保了视图和网络请求都不能直接修改`state`，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心竞争条件（race condition）的出现。 `action` 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。\n    \n+   使用纯函数来执行修改\n    \n    为了描述`action` 如何改变`state tree` ，你需要编写`reducers`。 `Reducer`只是一些纯函数，它接收先前的`state`和`action`，并返回新的`state`。刚开始你可以只有一个`reducer`，随着应用变大，你可以把它拆成多个小的`reducers`，分别独立地操作`state tree`的不同部分，因为`reducer`只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的`reducer`来处理一些通用任务，如分页器。\n    \n\n## 数据流向\n\n严格的单向数据流是`Redux`架构的设计核心。\n\n这意味着应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。同时也鼓励做数据范式化，这样可以避免使用多个且独立的无法相互引用的重复数据。\n\n看看`React`和`Redux`流程图： ![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16fe5baac2224bdc8d27ed615cbaf05d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n举个最简单的例子：\n\n```js\n//创建一个最基本的store\nconst store =createStore(reducers);\n// subscribe() 返回一个函数用来注销监听器\nconst unsubscribe = store.subscribe(()=>console.log(store.getState()))\n// 发起一系列 action\nstore.dispatch(addTodo('Learn about actions'))\nstore.dispatch(addTodo('Learn about reducers'))\n```\n\n通过以上几句代码，我们已经实现了数据流从`dispatch(action)->reducer->subscribe->view`回调的整体流程(此处省略了`middleWare`的部分)，在这个例子中没有任何的`UI`层，`redux`也同样可以独立完成完整的数据流向。其中`subscribe`是对`state`变化更新的订阅功能，可以在回调函数中注册`view`渲染功能。\n\n## Redux 实现\n\n通过 SPA 项目里的状态管理我们了解到了`redux`和`redux`能解决哪些场景中遇到的问题。了解了`redux`解决了什么问题以及如何解决的，这样才能把握`redux`的设计思路。 `React`作为一个组件化开发框架，组件之间存在大量通信，而且组件之间通信可能跨域多层组件，或是多个组件之间共享同一数据，`React`有简单父子组件、非父子组件的通信不能满足我们的需求，所以我们需要有一个空间来存取和操作这些公用状态。而`redux`就为我们提供了一种管理公共状态的解决方案，接下来我们都围绕这个话题来展开。\n\n## Redux 核心 API 实现\n\n通过上面的数据流可以看出，`Redux`主要由三部分组成：`store`、`reducer`、`action`。`Redux`的核心就是`store`,它有`Redux`提供的`createStore`函数生成，该函数返回3个处理函数`getState`,`dispatch`,`subscribe`。\n\n## Store\n\n`Store`就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个`Store`。 接下来我们写`store`：\n\n```js\nexport default function createStore() {\n let state = {} // 公共状态\n const getState = () => {} // 存储的数据，状态树；\n const dispatch = () => {} // 分发action，并返回一个action，这是唯一能改变store中数据的方式；\n const subscribe = () => {} //注册一个监听者，store发生变化的时候被调用。\n return {dispatch,subscribe,getState}\n}\n```\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35df32ed3d2e4527a9899987118d9cac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) **getState()实现** 对象包含所有数据。如果想得到某个时点的数据，就要对`Store`生成快照。这种时点的数据集合，就叫做`State`。\n\n```js\n const getState = () => {\n   return state;\n }\n```\n\n**dispatch()的实现** 直接修改`state`,`state.num+'a'`,如修改`state`像这种情况，就会导致结果不是我们想要的，后果可能很严重，如果避免呢？ 如果可以随意修改`state`，会造成难以复现的`bug` ，我们需要实现有条件并且是具名修改的`store`数据，既然要分发`action`这里要传入一个`action`对象，另外这对象包括我们要修改的`state`和要操作的具名`actionType`,这里用`type`属性值的不同来对`state`做相应的修改，代码如下：\n\n```js\n const dispatch = (action) => {\n     switch (action.type) {\n    case 'ADD':\n      return {\n        ...state,\n        num: state.num + 1,\n      }\n    case 'MINUS':\n      return {\n        ...state,\n        num: state.num - 1,\n      }\n    case 'CHANGE_NUM':\n      return {\n        ...state,\n        num: state.num + action.val,\n      }\n    // 没有匹配到的方法 就返回默认的值\n    default:\n      return state\n  }\n } \n```\n\n从代码上看，这里并没有把`action`独立出来，接着往下看吧。 函数负责生成`State`。由于整个应用只有一个 `State`对象，包含所有数据，对于大型应用来说，这个`State`必然十分庞大，导致 `Reducer`函数也十分庞大。\n\n## reducer\n\n`reducer`是一个纯函数，它根据`action`和`initState`计算出新的`state`。\n\n```js\nreducer(action,initState)\n```\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92681ebee93c409aaa44cdeb10942cf1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) 强制使用`action`来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。最后，为了把`action`和`state`串起来，就有了`reducer`。 `reducer.js`:\n\n```js\nexport default function reducer(action, state) {\n  //通过传进来的 action.type 让管理者去匹配要做的事情\n  switch (action.type) {\n    case 'ADD':\n      return {\n        ...state,\n        num: state.num + 1,\n      }\n    case 'MINUS':\n      return {\n        ...state,\n        num: state.num - 1,\n      }\n    case 'CHANGE_NUM':\n      return {\n        ...state,\n        num: state.num + action.val,\n      }\n    // 没有匹配到的方法 就返回默认的值\n    default:\n      return state\n  }\n}\n```\n\n`test.js`测试结果：\n\n```js\nimport createStore from './redux'\nlet initState = {\n  num: 12,\n}\nconst store = createStore(reducer, initState)\nconsole.log(store.getState())\n```\n\n运行代码输出结果正常。\n\n**subscribe()的实现** 尽管这里能存储公用`state`,但是`store`的变化并不能直接更新视图，所以这里需要监听`store`的变化，这里就用到了一个很常用的设计模式——观察者模式。 言归正传，我们来实现下`subscriber`：\n\n```js\n/**\n * store实现\n *\n * @param {Function} reducer  管理状态更新者 接收：action,state 两参数\n * @param {Object} initState 初始化状态，如果没有num,会导致num默认是NaN\n * @returns 返回 subscribe, dispatch, getState \n * */\nconst createStore = (reducer, initState = { num: 10 }) => {\n  let state = initState\n  let subscribes = [] // 存放观察者\n  // 增加观察者\n  const subscribe = (fn) => {\n    subscribes.push(fn)\n  }\n  // 通知所有观察者  这里不再是传状态了，而是改传改变状态的命令（通过固定指令告诉管理者需要做什么）\n  const dispatch = (action) => {\n    state = reducer(action, state) \n    // state发生变化，调用（通知）所有方法（观察者）\n    subscribes.forEach(fn => fn())\n  }\n  // 这里需要添加这个获取state的方法\n  const getState = () => {\n    return state\n  }\n  return {\n    subscribe,\n    dispatch,\n    getState,\n  }\n}\nexport default createStore\n```\n\n`test.js`测试代码\n\n```javascript\nimport createStore from './redux'\nlet initState = {\n  num: 12,\n}\nconst store = createStore(reducer, initState)\nstore.subscribe(() => {\n  let state = store.getState()\n  console.log('收到通知：','state.num更新结果为'+state.num)\n})\nstore.dispatch({type:'ADD'}) \nstore.dispatch({type:'MINUS'}) \nstore.dispatch({type:\"CHANGENUM\", val:20}) // \n```\n\n执行结果正常：\n\n## action\n\n`Action`是把数据从应用（译者注：这里之所以不叫`view`是因为这些数据有可能是服务器响应，用户输入或其它非`view`的数据 ）传到 `store` 的有效载荷。它是 `store` 数据的唯一来源。一般来说你会通过 `store.dispatch()` 将 `action` 传到`store`。\n\n`State` 的变化，会导致`View` 的变化。但是，用户接触不到 `State`，只能接触到 `View`。所以，`State` 的变化必须是 `View` 导致的。`Action` 就是 `View` 发出的通知，表示 `State` 应该要发生变化了。\n\n`Action` 是一个对象。其中的`type`属性是必须的，表示 `Action` 的名称。其他属性可以自由设置，社区有一个规范可以参考。\n\n可以这样理解，`Action` 描述当前发生的事情。改变`State` 的唯一办法，就是使用 `Action`。它会运送数据到 `Store`。\n\n新建 `action.js`\n\n```js\nexport const ADD = 'ADD'\nexport const MINUS = 'MINUS'\nexport const CHANGE_NUM = 'CHANGE_NUM'\n/*\n * Action Creator 来生成action\n */\nexport function add(text) {\n  return { type: ADD, text }\n}\nexport function minus(index) {\n  return { type: MINUS, index }\n}\nexport function changeNum(filter) {\n  return { type: CHANGE_NUM, filter }\n}\n相应的reducer得改造下：\nimport { ADD,MINUS,CHANGE_NUM } from './action'\nexport default function reducer(action, state) {\n  //通过传进来的 action.type 让管理者去匹配要做的事情\n  switch (action.type) {\n    case ADD:\n      return {\n        ...state,\n        text: action.text,\n        num: state.num + 1,\n      }\n    case MINUS:\n      return {\n        ...state,\n        index: action.index,\n        num: state.num - 1,\n      }\n    case CHANGE_NUM:\n      return {\n        ...state,\n        val: action.val,\n        num: state.num + action.val,\n      }\n    // 没有匹配到的方法 就返回默认的值\n    default:\n      return state\n  }\n}\n```\n\ntest.js测试应用\n\n```js\nimport createStore from './redux'\nimport reducer from './reducer'\nimport { add,minus,changeNum } from './action'\nlet initState = {\n  num: 12,\n}\nconst store = createStore(reducer, initState)\nstore.subscribe(() => {\n  let state = store.getState()\n  console.log(state) \n  console.log('收到通知：','state.num更新结果为'+state.num)\n})\nstore.dispatch(add('num+1'))\nstore.dispatch(minus(1))\nstore.dispatch(changeNum(20))\n```\n\n到这我们基本就是实现了`redux`,虽然相对粗糙，并不用影响我们对其思路的理解。\n\n[在线源码](https://codesandbox.io/s/redux-and-react-redux-7l55p \"https://codesandbox.io/s/redux-and-react-redux-7l55p\")\n\n## 总结\n\n我们来梳理下`action`、`store`、`reducer`，`views`他们之间的交互流程，如下图： ![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c88514d5440467bba61f9dc5fac2085~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n`Redux` 本身和 `React` 没有关系，只是数据处理中心，那么他们是如何产生联系的呢，接下来就该 说到`react-redux`，下一篇就围绕`react-redux`来讲，以及它在`React`里的应用。\n\n## 参考文档：\n\n+   [Redux](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#why-should-i-use-redux \"https://redux.js.org/tutorials/essentials/part-1-overview-concepts#why-should-i-use-redux\")\n+   [React-redux](http://cn.redux.js.org/docs/react-redux/ \"http://cn.redux.js.org/docs/react-redux/\")"
    },
    {
      "id": "React中的forwardRef究竟该怎么用",
      "metadata": {
        "permalink": "/React中的forwardRef究竟该怎么用",
        "source": "@site/blog/React中的forwardRef究竟该怎么用.md",
        "title": "React中的forwardRef究竟该怎么用",
        "description": "请输入描述",
        "date": "2023-08-28T08:07:46.899Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 11.96,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "React中的forwardRef究竟该怎么用",
          "title": "React中的forwardRef究竟该怎么用",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "Redux原理解析与实现",
          "permalink": "/Redux原理解析与实现"
        },
        "nextItem": {
          "title": "Redux浅谈",
          "permalink": "/Redux浅谈"
        }
      },
      "content": "## React 中的 forwardRef\n\n![save_3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3f279771ed5493ea2554c9da0af50fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 前言\n\n最近在学`react`, 一直对`forwardRef`和`Context`这两个认识不太清楚，现在终于搞懂了，于是想写一篇文章记录一下。\n\n## React.forwardRef\n\n对于ref转发，官网是这样描述的\n\n> Ref 转发是一项将 [ref](https://react.docschina.org/docs/refs-and-the-dom.html \"https://react.docschina.org/docs/refs-and-the-dom.html\") 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。\n\n想详细了解的可以去看官方文档 [Refs 转发 – React (docschina.org)](https://react.docschina.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components \"https://react.docschina.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components\")\n\n现在让我们直奔主题吧！\n\n`React.forwardRef(render)`的返回值是`react`组件，接收的参数是一个 `render`函数，函数签名为`render(props, ref)`，第二个参数将其接受的 [ref](https://react.docschina.org/docs/refs-and-the-dom.html \"https://react.docschina.org/docs/refs-and-the-dom.html\") 属性**转发**到`render`返回的组件中。\n\n这项技术并不常见，但在以下两种场景中特别有用:\n\n+   转发 `ref` 到组件内部的`DOM` 节点上\n+   在高阶组件中转发`ref`\n\n## 转发 `ref`到组件内部的`DOM`节点\n\n比如我们想要将一个组件内部的某个元素暴露出去, 就可以这么做\n\n```jsx\n// App.js\nimport React from 'react';\nimport Foo from './component/Foo';\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.input = React.createRef(); // 1\n      // ↑5\n  }\n  \n  handleClick = (e) => {\n    const input = this.input.current;\n      // 6\n    console.log(input);\n    console.log(input.value);\n    input.focus();\n  }\n  \n  render() {\n    return (\n      <>\n        <button onClick={this.handleClick}>click to get value</button>\n                  {/*2*/}\n        <Foo ref={this.input}/>\n      </>\n    )\n  }\n}\n```\n\n```jsx\n// Foo.jsx\nimport React from 'react';\n\t\t\t             // 3\nconst Foo = React.forwardRef((props, myRef) => {\n  return (\n    <div>\n      <p>....一些其他节点</p>\t\t\t\t\t\t\t\t{/*4*/}\n      <input type=\"text\" defaultValue='ref 成功转发到 Foo 组件内部的 input节点上' ref={myRef}/>\n      <p>....一些其他节点</p>\n      <p>....一些其他节点</p>\n    </div>\n  );\n});\n\nexport default Foo;\n\n```\n\n仔细看代码中标记的数字，这是`ref`转发的流程:\n\n1.  创建了一个`ref`\n2.  将其挂载到 组件上这个组件是通过`React.forwardRef`创建出来的, 注意这里很关键，后面细说\n3.  组件`Foo`接收到了一个`ref`，于是将它转发到`DOM`节点`input`上\n4.  `ref`如愿的挂载到内部节点`input`上\n5.  现在`this.input.current`保存着对节点`input`的引用\n6.  点击按钮, 现在可以很轻松的获取`Foo`内部节点的`value`以及获取其焦点\n\n![image-20210715133621474.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95cb1b9007584ebcb6e133006169d475~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 细节补充\n\n之前说过，步骤2很关键，这是因为 `ref` 的值根据节点的类型而有所不同：\n\n1.  当 `ref` 属性用于 HTML 元素时，接收底层 DOM 元素作为其 `current` 属性。\n    \n2.  当 `ref` 属性用于自定义 class 组件时，`ref` 接收组件实例作为其 `current` 属性。\n    \n3.  **不能在函数组件上使用 `ref` 属性**，因为他们没有实例。\n    \n\n第一个很好理解，我们上面的例子已经体现了这一点, `ref` 最终被挂载到了 `input` 节点上, `input`是一个`HTML`元素，所以`current`中保留的是`DOM`元素。\n\n对于第二个，我们现在用另一个组件来演示\n\n```jsx\n// Bar.jsx\nimport React from 'react';\n\nexport default class Bar extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: '这是class组件, ref 只能挂载到实例上'\n    };\n  }\n  \n  componentDidMount() {\n    console.log(this);\n  }\n  render() {\n    return (\n      <div>\n        class 组件\n      </div>\n    );\n  }\n}\n```\n\n```jsx\n// App.js\nimport React from 'react';\nimport Bar from './component/Bar'\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.myRef = React.createRef(); // 创建 ref\n  }\n  \n  handleClick = (e) => {\n    const instance = this.myRef.current;\n    // 打印的是 Bar 实例\n    console.log(instance);\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick}>click to get instance</button>\n        {/*挂载到组件上，因为Bar是一个class组件，所以只能挂载到其实例上*/}\n        <Bar ref={this.myRef} />\n      </div>\n    );\n  }\n}\n```\n\n第一条打印是 Bar 组件挂载后生命周期函数打印的\n\n第二条打印是点击按钮后打印的，证明确实只是挂载到了组件实例上。后面的高阶组件中还会出现类似的问题。\n\n![image-20210715134441071.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5347795a0749579287c0fea1788df8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n对于第三个，不能在函数组件上使用 `ref` 属性，因为他们没有实例\n\n```jsx\n// Baz.jsx\nimport React from 'react';\n\nconst Baz = (props) => {\n  return (\n    <div>\n      啊？\n    </div>\n  );\n};\n\nexport default Baz;\n\n```\n\n```jsx\n// App.js 中, 省略掉了其他代码\n\n<Baz ref={this.myRef} />\n```\n\n这时就会报错了, 意思是不能在函数式组件上使用 `ref`, 尝试访问 `ref`会失败。\n\n![image-20210715135235910.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3283ac92423c4db28adb23c7f24b02a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n一般函数式组件都是用`React.forwardRef`包装一下然后返回出去的, 函数式组件本来就是一个`render`函数，不过在被`React.forwardRef`包装后就多了一个`ref`属性了。\n\n```jsx\n// 将我们的函数式组件改造成这个样子.\nconst Baz = React.forwardRef((props, ref) => {\n  return (\n    <div>\n      啊？\n    </div>\n  );\n})\n```\n\n此时的`ref`还没有被挂载，所以访问`ref.current`会得到`null`，不过总算不会报错了\n\n![image-20210715140135383.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd614d4e780d4076af82c7894af7b3c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n函数式组件只是将`ref`传递下去，`ref`最终只能被挂载到内部的某个**class组件或者HTML元素**上\n\n还有一点要说明一下，不能在函数组件上使用 `ref` 属性并不是不能在函数式组件内部使用 `ref`\n\n如下所示：\n\n```jsx\n// 还是 Baz.jsx\nimport React from 'react';\nconst myRef = React.createRef();\n\nconst Baz = (props) => {\n  function handleClick(e) {\n    const input = myRef.current;\n    console.log(input.value);\n  }\n  return (\n    <div>\n      <button onClick={handleClick}>click to get value</button>\n      <input ref={myRef} type=\"text\" defaultValue={'不能在函数组件上使用 ref 属性并不代表着不能在函数式组件内部使用 `ref`'}/>\n    </div>\n  );\n}\n\nexport default Baz;\n\n```\n\n![image-20210715141214954.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef632f4a4bb4443bc9a955b36ff21a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 在高阶组件中转发`ref`\n\n依然使用 之前的 Bar.jsx\n\n```jsx\n// Bar.jsx\nimport React from 'react';\n\nexport default class Bar extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: '这是Bar.jsx'\n    };\n  }\n  \n  componentDidMount() {\n    console.log(this);\n  }\n  render() {\n    return (\n      <div>\n        class 组件\n      </div>\n    );\n  }\n}\n```\n\n我们使用高阶组件，为`Bar`组件增加一个功能：每次`props`改变都打印其变化\n\n```jsx\n// logProps.js\nfunction logProps(WrappedComponent) {\n    \n  class LogProps extends React.Component {\n    componentDidUpdate(prevProps) {\n      console.log('Previous props: ', prevProps);\n      console.log('Current props: ', this.props);\n    }\n    render() {\n        // 高阶组件透传所有的 props 到其包裹的组件，所以渲染结果将是相同的\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n  return LogProps;\n}\n```\n\n但是高阶组件 **不! 会! 传! 递!** `ref`, 这是因为 `ref` 不是 `prop`属性。就像 `key` 一样，其被 React 进行了特殊处理。\n\n如果你对**被高阶组件包装后的组件**添加 `ref`，该 `ref` 将引用最外层的容器组件，而不是被包裹的组件。\n\n对于上面的例子，如果用了`ref`, 那么最终会挂载到 `<LogProps/>`组件上，而不是传入的被包裹的 `<WrappedComponent/>`组件上。\n\n> 其实这很好理解，自己在脑袋里模拟一下数据流就知道 ref 最后会被挂载到最外面的组件上，不过高阶组件中的这个透传的概念很容易将人带偏，误以为 ref 会跟着 props 一起透传下去， 其实是不会传递的。\n\n为了更好的在控制台观察究竟是挂载到哪个组件上，我们为这两个组件添加 `state`\n\n```jsx\n// Bar.jsx 中\nthis.state = {\n  message: '这是Bar.jsx'\n}\n\n// logProps.js 中返回的 LogProps组件\nthis.state = {\n  message: '这是LogProps'\n}\n```\n\n```jsx\n// App.js\nimport React from 'react';\nimport logProps from './component/logProps';\nimport Bar from './component/Bar'\n\nconst BarWithLogProps = logProps(Bar);\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'Roman',\n      age: 23,\n      hobby: 'video game'\n    }\n    this.myRef = React.createRef();\n  }\n  handleClick = (e) => {\n    this.setState({\n      name: 'fxy',\n      age: 32,\n      hobby: 'swim'\n    });\n    console.log(this.myRef.current);\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick} >click to change props</button>\n        <BarWithLogProps {...this.state} ref={this.myRef} />\n      </div>\n    );\n  }\n}\n```\n\n我们点击按钮，在控制台可以清楚的看到， `ref`确实是被挂载到外部组件 `LogProps`上。\n\n![image-20210715151515685.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6b51ade9a0143fbb406461207906026~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n`React.forwardRef`再次登场，我们可以使用 `React.forwardRef` API 明确地将 `ref` 转发到内部的 `<WrappedComponent/>` 组件\n\n最后我们将 `logProps.js`改造成这样\n\n```jsx\n// 最终形态\nimport React from 'react';\n\nexport default function logProps(WrappedComponent) {\n  \n  class LogProps extends React.Component {\n    // 2\n    constructor(props) {\n      super(props);\n      this.state = {\n        message: '这是LogProps'\n      }\n    }\n    componentDidUpdate(prevProps) {\n      console.log('Previous props: ', prevProps);\n      console.log('Current props: ', this.props);\n    }\n    render() {\n      // 3\n      const {customRef, ...props} = this.props;\n      // 3.5 return <WrappedComponent {...this.props}/>;\n      return <WrappedComponent {...props} ref={customRef} />;\n    }\n  }\n  // return LogProps;\n  return React.forwardRef((props, ref) => (\n    // 1\n    <LogProps {...props} customRef={ref} />\n  ))\n  \n}\n```\n\n1.  我们将 `LogProps`组件作为`render`函数的返回值，这样渲染结果还是不变，然后将传入的`ref`转发到 `LogProps`组件的自定义属性 `customRef`上。注意这里**一定要转发到自定义属性**，如果转发到 `ref`属性上最终还是会被挂载到 `LogProps`上，等于转了一圈又回到了原地...\n2.  所有的属性都被传递到`props`中\n3.  将 `props`中的 `customRef`提取出来，最终传递到`WrappedComponent`的`ref`属性上。\n\n最后`ref`被成功转发到被包裹的组件`WrappedComponent`上。\n\n点击按钮，现在来控制台看看\n\n![image-20210715154514906.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa02affc9bbd45a5b4b5210c3ec21549~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp) ref 被成功的挂载到目标组件上。\n\n细心的读者可能已经发现`logProps.js`转发`ref`还有另一种写法, 就是 3.5 那样，不用抽离 `customRef`，仍然将 `customRef` 作为`props` 透传下去, 不过这样就会导致一个问题： `customRef`作为 `props`传递，进入了 `WrappedComponent`组件内部，此时 `customRef`还没有作为`ref`属性挂载到任何 `class组件`或者 `DOM节点`上。\n\n如果这时访问`ref.current`会得到`null`\n\n![image-20210715160350304.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4f336c010d44ccb8f69e66deae57bf2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n不过这也更方便的让我们**转发`ref`到组件内部的`DOM`节点**\n\n```jsx\n// Bar.jsx\nrender() {\n  return (\n    <div ref={this.props.customRef}>\n      name: {this.props.name}\n      <br/>\n      age: {this.props.age}\n      <br/>\n      hobby: {this.props.hobby}\n    </div>\n  );\n}\n```\n\n![image-20210715160553235.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/685d225b86174124bfa7c6bdd19905f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n其实用最开始的写法让`customRef`作为`ref`属性挂载到组件上，在组件内部使用 `React.forwardRef`一样能将`ref`转发到组件内部的`DOM`节点上。\n\n## 最后\n\n没有最后啦，Context 后面再补吧😁，没想到写这个挺费时间的，我要赶紧学后面的了，大家加油！"
    },
    {
      "id": "Redux浅谈",
      "metadata": {
        "permalink": "/Redux浅谈",
        "source": "@site/blog/Redux浅谈.md",
        "title": "Redux浅谈",
        "description": "请输入描述",
        "date": "2023-08-28T08:06:21.432Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 13.94,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "Redux浅谈",
          "title": "Redux浅谈",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "React中的forwardRef究竟该怎么用",
          "permalink": "/React中的forwardRef究竟该怎么用"
        },
        "nextItem": {
          "title": "React高阶组件",
          "permalink": "/React高阶组件"
        }
      },
      "content": "#概述 随着应用程序单页面需求的越来越复杂，应用状态的管理也变得越来越混乱，而Redux的就是为解决这一问题而出现的。在一个大型的应用程序中，应用的状态不仅包括从服务器获取的数据，还包括本地创建的数据，以及反应本地UI状态的数据，而Redux正是为解决这一复杂问题而存在的。\n\nredux作为一种单向数据流的实现，配合react非常好用，尤其是在项目比较大，逻辑比较复杂的时候，单项数据流的思想能使数据的流向、变化都能得到清晰的控制，并且能很好的划分业务逻辑和视图逻辑。下图是redux的基本运作的流程。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/31/164edab5e41258c1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)\n\n如上图所示，该图展示了Redux框架数据的基本工作流程。简单来说，首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。\n\n同时，作为一款应用状态管理框架，为了让应用的状态管理不再错综复杂，使用Redux时应遵循三大基本原则，否则应用程序很容易出现难以察觉的问题。这三大原则包括： • **单一数据源** 整个应用的State被存储在一个状态树中，且只存在于唯一的Store中。 • **State是只读的** 对于Redux来说，任何时候都不能直接修改state，唯一改变state的方法就是通过触发action来间接的修改。而这一看似繁琐的状态修改方式实际上反映了Rudux状态管理流程的核心思想，并因此保证了大型应用中状态的有效管理。 • **应用状态的改变通过纯函数来完成** Redux使用纯函数方式来执行状态的修改，Action表明了修改状态值的意图，而真正执行状态修改的则是Reducer。且Reducer必须是一个纯函数，当Reducer接收到Action时，Action并不能直接修改State的值，而是通过创建一个新的状态对象来返回修改的状态。\n\n## redux的三大元素\n\n和Flux框架不同，Redux框架主要由Action、Reducer和Store三大元素组成。\n\n## Action\n\nAction是一个普通的JavaScript对象，其中的type属性是必须的，用来表示Action的名称，type一般被定义为普通的字符串常量。为了方便管理，一般通过action creator来创建action，action creator是一个返回action的函数。\n\n在Redux中，State的变化会导致View的变化，而State状态的改变是通过接触View来触发具体的Action动作的，根据View触发产生的Action动作的不同，就会产生不同的State结果。可以定义一个函数来生成不同的Action，这个函数就被称为action creator。例如：\n\n```auto\nconst ADD_TODO = '添加事件 TODO';\n\nfunction addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n\nconst action = addTodo('Learn Redux');\n\n```\n\n上面代码中，addTodo就是一个action creator。但当应用程序的规模越来越大时，建议使用单独的模块或文件来存放action。\n\n## Reducer\n\n当Store收到action以后，必须返回一个新的State才能触发View的变化，State计算的过程即被称为Reducer。Reducer本质上是一个函数，它接受Action和当前State作为参数，并返回一个新的State。格式如下：\n\n```auto\nconst reducer = function (state, action) {\n  // ...\n  return new_state;\n};\n\n```\n\n为了保持reducer函数的纯净，请不要在reducer中执行如下的一些操作： • 修改传入参数； • 执行有副作用的操作，如API请求和路由跳转； • 调用非纯函数，如 Date.now() 或 Math.random()\n\n对于Reducer来说，整个应用的初始状态就可以直接作为State的默认值。例如：\n\n```auto\nconst defaultState = 0;\nconst reducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case 'ADD':\n      return state + action.payload;\n    default: \n      return state;\n  }\n};\n//手动调用\nconst state = reducer(1, {\n  type: 'ADD',\n  payload: 2\n});\n\n```\n\n不过，在实际使用过程中，reducer函数并不需要像上面那样进行手动调用，Store的store.dispatch方法会触发Reducer的自动执行。为此，只需要在生成Store的时候将Reducer传入createStore方法即可。例如：\n\n```auto\nimport { createStore } from 'redux';\nconst store = createStore(reducer);\n\n```\n\n在上面的代码中，createStore函数接受Reducer作为参数，该函数返回一个新的Store，以后每当store.dispatch发送过来一个新的Action，就会自动调用Reducer得到新的State。\n\n##Store Store就是数据保存的地方，可以把它看成一个容器，整个应用中只能有一个Store。同时，Store还具有将Action和Reducers联系在一起的作用。Store具有以下的一些功能： • 维持应用的 state； • 提供getState()方法获取state； • 提供dispatch(action)方法更新state； • 通过subscribe(listener)注册监听器; • 通过subscribe(listener)返回的函数注销监听器。\n\n根据已有的Reducer来创建Store是一件非常容易的事情，例如Redux提供的createStore函数可以很方便的创建一个新的Store。\n\n```auto\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\n// 使用createStore函数创建Store\nlet store = createStore(todoApp)\n\n```\n\n其中，createStore函数的第二个参数是可选的，该参数用于设置state的初始状态。而这对于开发同构应用时非常有用的，可以让服务器端redux应用的state与客户端的state保持一致，并用于本地数据初始化。\n\n```auto\nlet store = createStore(todoApp, window.STATE_FROM_SERVER)\n```\n\nStore对象包含所有数据，如果想得到某个时刻的数据，则需要利用state来获取。例如：\n\n```auto\nimport { createStore } from 'redux';\nconst store = createStore(fn);\n//利用store.getState()获取state\nconst state = store.getState();\n\n```\n\nRedux规定，一个state只能对应一个view，只要state相同得到的view就相同，这也是Redux框架的重要特性之一。\n\n到此，关于Redux的运作流程就非常的清晰了，下面总结下Redux的运作流程。\n\n1.  当用户触摸界面时，调用store.dispatch(action)捕捉具体的action动作。\n2.  然后Redux的store自动调用reducer函数，store传递两个参数给reducer函数：当前state和收到的action。其中，reducer函数必须是一个纯函数，该函数会返回一个新的state。\n3.  根reducer会把多个子reducer的返回结果合并成最终的应用状态，在这一过程中，可以使用Redux提供的combineReducers方法。使用combineReducers方法时，action会传递给每个子的reducer进行处理，在子reducer处理后会将结果返回给根reducer合并成最终的应用状态。\n4.  store调用store.subscribe(listener)监听state的变化，state一旦发生改变就会触发store的更新，最终view会根据store数据的更新刷新界面。\n\n## Redux实现\n\n## 1，创建store\n\nstore就是redux的一个数据中心，简单的理解就是我们所有的数据都会存放在里面，然后在界面上使用时，从中取出对应的数据。因此首先我们要创建一个这样的store，可以通过redux提供的createStore方法来创建。\n\n```auto\nxport default function createStore(reducer, preloadedState, enhancer) {\n  ...\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n```\n\n可以看到createStore有三个参数，返回一个对象，里面有我们常用的方法，下面一一来看一下。\n\n### getState\n\ngetState用于获取当前的状态，格式如下：\n\n```auto\nfunction getState() {\n    return currentState\n  }\n```\n\nRedux内部通过currentState变量保存当前store，变量初始值即我们调用时传进来的preloadedState，getState()就是返回这个变量。\n\n### subscribe\n\n代码本身也不难，就是通过nextListeners数组保存所有的回调函数，外部调用subscribe时，会将传入的listener插入到nextListeners数组中，并返回unsubscribe函数，通过此函数可以删除nextListeners中对应的回调。以下是该函数的具体实现：\n\n```auto\nvar currentListeners = []\nvar nextListeners = currentListeners\n\nfunction ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()        //生成一个新的数组\n    }\n }\n\nfunction subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.')\n    }\n\n    var isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      var index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n    }\n }\n\n```\n\n可以发现，上面的源码使用currentListeners和nextListeners两个数组来保存，主要原因是在dispatch函数中会遍历nextListeners，这时候可能会客户可能会继续调用subscribe插入listener，为了保证遍历时nextListeners不变化，需要一个临时的数组保存。\n\n### dispatch\n\n当view dispatch一个action后，就会调用此action对应的reducer，下面是它的源码：\n\n```auto\nfunction dispatch(action) {  \n  ...\n  try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)  //调用reducer处理\n    } finally {\n      isDispatching = false\n    }\n\n    var listeners = currentListeners = nextListeners\n    for (var i = 0; i < listeners.length; i++) {                   \n      var listener = listeners[i]\n      listener()\n    }\n  ...\n}\n```\n\n从上面的源码可以发现，dispatch函数在调用了currentReducer以后，遍历nextListeners数组，回调所有通过subscribe注册的函数，这样在每次store数据更新，组件就能立即获取到最新的数据。\n\n### replaceReducer\n\nreplaceReducer是切换当前的reducer，虽然代码只有几行，但是在用到时功能非常强大，它能够实现代码热更新的功能，即在代码中根据不同的情况，对同一action调用不同的reducer，从而得到不同的数据。\n\n```auto\nfunction replaceReducer(nextReducer) {\n if (typeof nextReducer !== 'function') {\n    throw new Error('Expected the nextReducer to be a function.')\n  }\n\n  currentReducer = nextReducer\n  dispatch({ type: ActionTypes.REPLACE })\n  }\n```\n\n## bindActionCreators\n\nbindActionCreators方法的目的就是简化action的分发，我们在触发一个action时，最基本的调用是dispatch(action(param))。这样需要在每个调用的地方都写dispatch，非常麻烦。bindActionCreators就是将action封装了一层，返回一个封装过的对象，此后我们要出发action时直接调用action(param)就可以了。\n\n## react-redux\n\nredux作为一个通用的状态管理库，它不只针对react，还可以作用于其它的像vue等。因此react要想完美的应用redux，还需要封装一层，react-redux就是此作用。react-redux库相对简单些，它提供了一个react组件Provider和一个方法connect。下面是react-redux最简单的写法：\n\n```auto\nimport { Provider } from 'react-redux';     // 引入 react-redux\n\n……\nrender(\n    <Provider store={store}>\n        <Sample />\n    </Provider>,\n    document.getElementById('app'),\n);\n\n```\n\nconnect方法复杂点，它返回一个函数，此函数的功能是创建一个connect组件包在WrappedComponent组件外面，connect组件复制了WrappedComponent组件的所有属性，并通过redux的subscribe方法注册监听，当store数据变化后，connect就会更新state，然后通过mapStateToProps方法选取需要的state，如果此部分state更新了，connect的render方法就会返回新的组件。\n\n```auto\nexport default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n  ...\n  return function wrapWithConnect(WrappedComponent) {\n    ...\n  }\n}\n```\n\n本文不详细介绍React-Redux，可以访问下面的链接[React-Redux简介及应用](https://www.jianshu.com/p/6e0b6c519799 \"https://www.jianshu.com/p/6e0b6c519799\")。"
    },
    {
      "id": "React高阶组件",
      "metadata": {
        "permalink": "/React高阶组件",
        "source": "@site/blog/React高阶组件.md",
        "title": "React高阶组件",
        "description": "请输入描述",
        "date": "2023-08-28T08:04:12.051Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 40.45,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "React高阶组件",
          "title": "React高阶组件",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "Redux浅谈",
          "permalink": "/Redux浅谈"
        },
        "nextItem": {
          "title": "将React作为UI运行时",
          "permalink": "/将React作为UI运行时"
        }
      },
      "content": "## 一 前言\n\n`React`高阶组件(`HOC`)，对于很多`react`开发者来说并不陌生，它是灵活使用`react`组件的一种技巧，高阶组件本身不是组件，它是一个参数为组件，返回值也是一个组件的函数。高阶作用用于**强化组件，复用逻辑，提升渲染性能等**作用。高阶组件也并不是很难理解，其实接触过后还是蛮简单的，接下来我将按照，**高阶组件理解？**，**高阶组件具体怎么使用？应用场景**， **高阶组件实践(源码级别)** 为突破口，带大家详细了解一下高阶组件。本文篇幅比较长，建议收藏观看\n\n我们带着问题去开始今天的讨论：\n\n+   1 什么是高阶组件，它解决了什么问题？\n+   2 有几种高阶组件，它们优缺点是什么？\n+   3 如何写一个优秀高阶组件？\n+   4 `hoc`怎么处理静态属性，跨层级`ref`等问题？\n+   5 高阶组件怎么控制渲染，隔离渲染？\n+   6 高阶组件怎么监控原始组件的状态？\n+   ...\n\n> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n![NAOTU.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b05e1efc4e84808a0bb84c9cac4ab4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 二 全方位看高阶组件\n\n## 1 几种包装强化组件的方式\n\n### ① mixin模式\n\n**原型图**\n\n![C32587B9-D0FB-46CA-9AF8-FE2DF49021E5.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faee9aa3049e4eb388ed76db4a8b6e64~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 老版本的`react-mixins`\n\n在`react`初期提供一种组合方法。通过`React.createClass`,加入`mixins`属性，具体用法和`vue` 中`mixins`相似。具体实现如下。\n\n```js\nconst customMixin = {\n  componentDidMount(){\n    console.log( '------componentDidMount------' )\n  },\n  say(){\n    console.log(this.state.name)\n  }\n}\n\nconst APP = React.createClass({\n  mixins: [ customMixin ],\n  getInitialState(){\n    return {\n      name:'alien'\n    }\n  },\n  render(){\n    const { name  } = this.state\n    return <div> hello ,world , my name is { name } </div>\n  }\n})\n\n```\n\n这种`mixins`只能存在`createClass`中，后来`React.createClass`连同`mixins`这种模式被废弃了。`mixins`会带来一些负面的影响。\n\n+   1 mixin引入了隐式依赖关系。\n+   2 不同mixins之间可能会有先后顺序甚至代码冲突覆盖的问题\n+   3 mixin代码会导致滚雪球式的复杂性\n\n#### 衍生方式\n\n`createClass`的废弃，不代表`mixin`模式退出`react`舞台，在有状态组件`class`，我们可以通过**原型链继承**来实现`mixins`。\n\n```js\nconst customMixin = {  /* 自定义 mixins */\n  componentDidMount(){\n    console.log( '------componentDidMount------' )\n  },\n  say(){\n    console.log(this.state.name)\n  }\n}\n\nfunction componentClassMixins(Component,mixin){ /* 继承 */\n  for(let key in mixin){\n    Component.prototype[key] = mixin[key]\n  }\n}\n\nclass Index extends React.Component{\n  constructor(){\n    super()\n    this.state={  name:'alien' }\n  }\n  render(){\n    return <div> hello,world\n      <button onClick={ this.say.bind(this) } > to say </button>\n    </div>\n  }\n}\ncomponentClassMixins(Index,customMixin)\n```\n\n### ②extends继承模式\n\n**原型图**\n\n![9F743F44-D7FD-4F81-805B-80E8D5A358DB.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e95476ddca44d2a88f21d97828030da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n在`class`组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去`extends`我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。\n\n```js\nclass Base extends React.Component{\n  constructor(){\n    super()\n    this.state={\n      name:'alien'\n    }\n  }\n  say(){\n    console.log('base components')\n  }\n  render(){\n    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>\n  }\n}\nclass Index extends Base{\n  componentDidMount(){\n    console.log( this.state.name )\n  }\n  say(){ /* 会覆盖基类中的 say  */\n    console.log('extends components')\n  }\n}\nexport default Index\n```\n\n### ③HOC模式\n\n**原型图**\n\n![4F67D3DC-3B06-4B05-A006-B653D736855B.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3c20e2a97e4a26814a70161edc96b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n`HOC`是我们本章主要的讲的内容，具体用法，我们接下来会慢慢道来，我们先简单尝试一个`HOC`。\n\n```js\nfunction HOC(Component) {\n  return class wrapComponent extends React.Component{\n     constructor(){\n       super()\n       this.state={\n         name:'alien'\n       }\n     }\n     render=()=><Component { ...this.props } { ...this.state } />\n  }\n}\n\n@HOC\nclass Index extends React.Component{\n  say(){\n    const { name } = this.props\n    console.log(name)\n  }\n  render(){\n    return <div> hello,world <button onClick={ this.say.bind(this) } >点击</button>  </div>\n  }\n}\n```\n\n### ④自定义hooks模式\n\n**原型图**\n\n![1956EF23-7BFA-4003-9902-4D444B329290.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcaaa5ce7b5445fdab823bf385caf5e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n`hooks`的诞生，一大部分原因是解决**无状态组件没有`state`**和**逻辑难以复用**问题。`hooks`可以将一段逻辑封装起来，做到开箱即用，我这里就不多讲了，接下来会出`react-hooks`原理的文章，完成`react-hooks`三部曲。感兴趣的同学可以看笔者的另外二篇文章，里面详细介绍了`react-hooks`复用代码逻辑的原则和方案。\n\n传送门：\n\n[玩转react-hooks,自定义hooks设计模式及其实战](https://juejin.cn/post/6890738145671938062 \"https://juejin.cn/post/6890738145671938062\")\n\n[react-hooks如何使用？](https://juejin.cn/post/6864438643727433741 \"https://juejin.cn/post/6864438643727433741\")\n\n## 2 高阶组件产生初衷\n\n组件是把`prop`渲染成`UI`,而高阶组件是将组件转换成另外一个组件，我们更应该注意的是，经过包装后的组件，获得了那些强化,节省多少逻辑，或是解决了原有组件的那些缺陷，这就是高阶组件的意义。我们先来思考一下高阶组件究竟解决了什么问题🤔🤔🤔？\n\n**① 复用逻辑**：高阶组件更像是一个加工`react`组件的工厂，批量对原有组件进行**加工**，**包装**处理。我们可以根据业务需求定制化专属的`HOC`,这样可以解决复用逻辑。\n\n**② 强化props**：这个是`HOC`最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的`props`,然后混入新的`props`,来增强组件的功能。代表作`react-router`中的`withRouter`。\n\n**③ 赋能组件**：`HOC`有一项独特的特性，就是可以给被`HOC`包裹的业务组件，提供一些拓展功能，比如说**额外的生命周期，额外的事件**，但是这种`HOC`，可能需要和业务组件紧密结合。典型案例`react-keepalive-router`中的 `keepaliveLifeCycle`就是通过`HOC`方式，给业务组件增加了额外的生命周期。\n\n**④ 控制渲染**：劫持渲染是`hoc`一个特性，在`wrapComponent`包装组件中，可以对原来的组件，进行`条件渲染`，`节流渲染`，`懒加载`等功能，后面会详细讲解，典型代表做`react-redux`中`connect`和 `dva`中 `dynamic` 组件懒加载。\n\n我会针对高阶组件的初衷展开，详细介绍其原理已经用法。跟上我的思路，我们先来看一下，高阶组件**如何在我们的业务组件中使用的**。\n\n## 3 高阶组件使用和编写结构\n\n`HOC`使用指南是非常简单的，只需要将我们的组件进行包裹就可以了。\n\n### 使用：装饰器模式和函数包裹模式\n\n对于`class`声明的有状态组件，我们可以用装饰器模式，对类组件进行包装：\n\n```js\n@withStyles(styles)\n@withRouter\n@keepaliveLifeCycle\nclass Index extends React.Componen{\n    /* ... */\n}\n```\n\n**我们要注意一下包装顺序，越靠近`Index`组件的，就是越内层的`HOC`,离组件`Index`也就越近。**\n\n对于无状态组件(函数声明）我们可以这么写：\n\n```js\nfunction Index(){\n    /* .... */\n}\nexport default withStyles(styles)(withRouter( keepaliveLifeCycle(Index) )) \n```\n\n### 模型：嵌套HOC\n\n对于不需要传递参数的`HOC`，我们编写模型我们只需要嵌套一层就可以，比如`withRouter`,\n\n```js\nfunction withRouter(){\n    return class wrapComponent extends React.Component{\n        /* 编写逻辑 */\n    }\n}\n\n```\n\n对于需要参数的`HOC`，我们需要一层代理，如下：\n\n```js\nfunction connect (mapStateToProps){\n    /* 接受第一个参数 */\n    return function connectAdvance(wrapCompoent){\n        /* 接受组件 */\n        return class WrapComponent extends React.Component{  }\n    }\n}\n\n```\n\n我们看出两种`hoc`模型很简单，对于代理函数，可能有一层，可能有很多层，不过不要怕，无论多少层本质上都是一样的，我们只需要一层一层剥离开，分析结构，整个`hoc`结构和脉络就会清晰可见。吃透`hoc`也就易如反掌。\n\n## 4 两种不同的高阶组件\n\n常用的高阶组件有两种方式**正向的属性代理**和**反向的组件继承**，两者之前有一些共性和区别。接下具体介绍两者区别，在第三部分会详细介绍具体实现。\n\n### 正向属性代理\n\n所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。在`fiber tree` 上，先`mounted`代理组件，然后才是我们的业务组件。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。\n\n```js\nfunction HOC(WrapComponent){\n    return class Advance extends React.Component{\n       state={\n           name:'alien'\n       }\n       render(){\n           return <WrapComponent  { ...this.props } { ...this.state }  />\n       }\n    }\n}\n```\n\n#### 优点\n\n+   ① 正常属性代理可以和业务组件低耦合，零耦合，对于`条件渲染`和`props属性增强`,只负责控制子组件渲染和传递额外的`props`就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的`hoc`，目前开源的`HOC`基本都是通过这个模式实现的。\n+   ② 同样适用于`class`声明组件，和`function`声明的组件。\n+   ③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免`反向继承`带来一些副作用，比如生命周期的执行。\n+   ④ 可以嵌套使用，多个`hoc`是可以嵌套使用的，而且一般不会限制包装`HOC`的先后顺序。\n\n#### 缺点\n\n+   ① 一般无法直接获取业务组件的状态，如果想要获取，需要`ref`获取组件实例。\n    \n+   ② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。\n    \n\n**例子：**\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nIndex.say = function(){\n  console.log('my name is alien')\n}\nfunction HOC(Component) {\n  return class wrapComponent extends React.Component{\n     render(){\n       return <Component { ...this.props } { ...this.state } />\n     }\n  }\n}\nconst newIndex =  HOC(Index) \nconsole.log(newIndex.say)\n\n```\n\n**打印结果**\n\n![29B0DA43-A037-473C-AD76-6550A3849CE8.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c907c7605494955b4d5b8170f847a68~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### 反向继承\n\n反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须在去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必要要知道当前\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nfunction HOC(Component){\n    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */\n\n    }\n}\nexport default HOC(Index) \n```\n\n#### 优点\n\n+   ① 方便获取组件内部状态，比如`state`，`props` ,生命周期,绑定的事件函数等\n+   ② `es6`继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div> hello,world  </div>\n  }\n}\nIndex.say = function(){\n  console.log('my name is alien')\n}\nfunction HOC(Component) {\n  return class wrapComponent extends Component{\n  }\n}\nconst newIndex =  HOC(Index) \nconsole.log(newIndex.say)\n```\n\n**打印结果**\n\n![3618DB30-8D9F-445A-8A01-69076A0B1E1D.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2619fd18f75d47e7b7991858aac0b10c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 缺点\n\n+   ① 无状态组件无法使用。\n+   ② 和被包装的组件强耦合，需要知道被包装的组件的内部状态，具体是做什么？\n+   ③ 如果多个反向继承`hoc`嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个`componentDidMount`，当前`componentDidMount`会覆盖上一个`componentDidMount`。这样副作用串联起来，影响很大。\n\n## 三 如何编写高阶组件\n\n接下来我们来看看，如何编写一个高阶组件，你可以参考如下的情景，去编写属于自己的`HOC`。\n\n## 1 强化props\n\n### ① 混入props\n\n这个是高阶组件最常用的功能，承接上层的`props`,在混入自己的`props`，来强化组件。\n\n**有状态组件(属性代理)**\n\n```js\nfunction classHOC(WrapComponent){\n    return class  Idex extends React.Component{\n        state={\n            name:'alien'\n        }\n        componentDidMount(){\n           console.log('HOC')\n        }\n        render(){\n            return <WrapComponent { ...this.props }  { ...this.state }   />\n        }\n    }\n}\nfunction Index(props){\n  const { name } = props\n  useEffect(()=>{\n     console.log( 'index' )\n  },[])\n  return <div>\n    hello,world , my name is { name }\n  </div>\n}\n\nexport default classHOC(Index)\n```\n\n**有状态组件(属性代理)**\n\n同样也适用与无状态组件。\n\n```js\nfunction functionHoc(WrapComponent){\n    return function Index(props){\n        const [ state , setState ] = useState({ name :'alien'  })       \n        return  <WrapComponent { ...props }  { ...state }   />\n    }\n}\n```\n\n**效果**\n\n![A6FC09B4-EAA0-4A5A-BA3A-F7F2A8407C75.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24c4018d41048adbe335c1f5c22f0e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### ② 抽离state控制更新\n\n高阶组件可以将`HOC`的`state`的配合起来，控制业务组件的更新。这种用法在`react-redux`中`connect`高阶组件中用到过，用于处理来自`redux`中`state`更改，带来的订阅更新作用。\n\n我们将上述代码进行改造。\n\n```js\nfunction classHOC(WrapComponent){\n  return class  Idex extends React.Component{\n      constructor(){\n        super()\n        this.state={\n          name:'alien'\n        }\n      }\n      changeName(name){\n        this.setState({ name })\n      }\n      render(){\n          return <WrapComponent { ...this.props }  { ...this.state } changeName={this.changeName.bind(this)  }  />\n      }\n  }\n}\nfunction Index(props){\n  const [ value ,setValue ] = useState(null)\n  const { name ,changeName } = props\n  return <div>\n    <div>   hello,world , my name is { name }</div>\n    改变name <input onChange={ (e)=> setValue(e.target.value)  }  />\n    <button onClick={ ()=>  changeName(value) }  >确定</button>\n  </div>\n}\n\nexport default classHOC(Index)\n```\n\n**效果**\n\n![屏幕录制2021-03-13 下午6.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca30a6dd90340f59352146876ed9a37~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 2 控制渲染\n\n控制渲染是高阶组件的一个很重要的特性，上边说到的两种高阶组件，都能完成对组件渲染的控制。具体实现还是有区别的，我们一起来探索一下。\n\n### 2.1 条件渲染\n\n#### ① 基础 ：动态渲染\n\n对于属性代理的高阶组件，虽然不能在内部操控渲染状态，但是可以在外层控制当前组件是否渲染，这种情况应用于，**权限隔离**，**懒加载** ，**延时加载**等场景。\n\n**实现一个动态挂载组件的HOC**\n\n```js\nfunction renderHOC(WrapComponent){\n  return class Index  extends React.Component{\n      constructor(props){\n        super(props)\n        this.state={ visible:true }  \n      }\n      setVisible(){\n         this.setState({ visible:!this.state.visible })\n      }\n      render(){\n         const {  visible } = this.state \n         return <div className=\"box\"  >\n           <button onClick={ this.setVisible.bind(this) } > 挂载组件 </button>\n           { visible ? <WrapComponent { ...this.props } setVisible={ this.setVisible.bind(this) }   />  : <div className=\"icon\" ><SyncOutlined spin  className=\"theicon\"  /></div> }\n         </div>\n      }\n  }\n}\n\nclass Index extends React.Component{\n  render(){\n    const { setVisible } = this.props\n    return <div className=\"box\" >\n        <p>hello,my name is alien</p>\n        <img  src='https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&fm=26&gp=0.jpg'   /> \n        <button onClick={() => setVisible()}  > 卸载当前组件 </button>\n    </div>\n  }\n}\nexport default renderHOC(Index)\n```\n\n效果：\n\n![屏幕录制2021-03-13 下午9.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c41d9ee9fa491cb3ae44d9cee1f2b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### ② 进阶 ：分片渲染\n\n是不是感觉不是很过瘾，为了让大家加强对`H\bOC`条件渲染的理解，我再做一个**分片渲染+懒加载**功能。为了让大家明白，我也是绞尽脑汁啊😂😂😂。\n\n**进阶：实现一个懒加载功能的HOC，可以实现组件的分片渲染,用于分片渲染页面，不至于一次渲染大量组件造成白屏效果**\n\n```js\nconst renderQueue = []\nlet isFirstrender = false\n\nconst tryRender = ()=>{\n  const render = renderQueue.shift()\n  if(!render) return\n  setTimeout(()=>{\n    render() /* 执行下一段渲染 */\n  },300)\n} \n/* HOC */\nfunction renderHOC(WrapComponent){\n    return function Index(props){\n      const [ isRender , setRender ] = useState(false)\n      useEffect(()=>{\n        renderQueue.push(()=>{  /* 放入待渲染队列中 */\n          setRender(true)\n        })\n        if(!isFirstrender) {\n          tryRender() /**/\n          isFirstrender = true\n        }\n      },[])\n      return isRender ? <WrapComponent tryRender={tryRender}  { ...props }  /> : <div className='box' ><div className=\"icon\" ><SyncOutlined   spin /></div></div>\n    }\n}\n/* 业务组件 */\nclass Index extends React.Component{\n  componentDidMount(){\n    const { name , tryRender} = this.props\n    /* 上一部分渲染完毕，进行下一部分渲染 */\n    tryRender()\n    console.log( name+'渲染')\n  }\n  render(){\n    return <div>\n        <img src=\"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;fm=26&amp;gp=0.jpg\" />\n    </div>\n  }\n}\n/* 高阶组件包裹 */\nconst Item = renderHOC(Index)\n\nexport default () => {\n  return <React.Fragment>\n      <Item name=\"组件一\" />\n      <Item name=\"组件二\" />\n      <Item name=\"组件三\" />\n  </React.Fragment>\n}\n```\n\n**效果**\n\n![fenload.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d94687dda024392a37abec5e4756420~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n大致流程，初始化的时候，`HOC`中将渲染真正组件的渲染函数，放入`renderQueue`队列中，然后初始化渲染一次，接下来，每一个项目组件，完成 `didMounted` 状态后，会从队列中取出下一个渲染函数，渲染下一个组件, 一直到所有的渲染任务全部执行完毕，渲染队列清空，有效的进行分片的渲染，这种方式对海量数据展示，很奏效。\n\n用`HOC`实现了条件渲染-分片渲染的功能，实际条件渲染理解起来很容易，就是通过变量，控制是否挂载组件，从而满足项目本身需求，条件渲染可以演变成很多模式，我这里介绍了条件渲染的二种方式，希望大家能够理解精髓所在。\n\n#### ③ 进阶：异步组件(懒加载)\n\n不知道大家有没有用过`dva`,里面的`dynamic`就是应用`HOC`模式实现的组件异步加载，我这里简化了一下，提炼核心代码，如下：\n\n```js\n/* 路由懒加载HOC */\nexport default function AsyncRouter(loadRouter) {\n  return class Content extends React.Component {\n    state = {Component: null}\n    componentDidMount() {\n      if (this.state.Component) return\n      loadRouter()\n        .then(module => module.default)\n        .then(Component => this.setState({Component},\n         ))\n    }\n    render() {\n      const {Component} = this.state\n      return Component ? <Component {\n      ...this.props\n      }\n      /> : null\n    }\n  }\n}\n```\n\n使用\n\n```js\nconst Index = AsyncRouter(()=>import('../pages/index'))\n```\n\n`hoc`还可以配合其他`API`，做一下衍生的功能。如上配合`import`实现异步加载功能。`HOC`用起来非常灵活，\n\n#### ④ 反向继承 ： 渲染劫持\n\n**HOC反向继承模式，可以实现颗粒化的渲染劫持，也就是可以控制基类组件的`render`函数，还可以篡改props，或者是`children`，我们接下来看看，这种状态下，怎么使用高阶组件。**\n\n```js\n\nconst HOC = (WrapComponent) =>\n  class Index  extends WrapComponent {\n    render() {\n      if (this.props.visible) {\n        return super.render()\n      } else {\n        return <div>暂无数据</div>\n      }\n    }\n  }\n\n```\n\n#### ⑤ 反向继承：修改渲染树\n\n**修改渲染状态(劫持render替换子节点)**\n\n```js\nclass Index extends React.Component{\n  render(){\n    return <div>\n       <ul>\n         <li>react</li>\n         <li>vue</li>\n         <li>Angular</li>\n       </ul>\n    </div>\n  }\n}\n\nfunction HOC (Component){\n  return class Advance extends Component {\n    render() {\n      const element = super.render()\n      const otherProps = {\n        name:'alien'\n      }\n      /* 替换 Angular 元素节点 */\n      const appendElement = React.createElement('li' ,{} , `hello ,world , my name  is ${ otherProps.name }` )\n      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=>{\n           if(index === 2) return appendElement\n           return  child\n      }) \n      return  React.cloneElement(element, element.props, newchild)\n    }\n  }\n}\nexport  default HOC(Index)\n\n```\n\n**效果**\n\n![40D6BF30-9B4C-4EC9-B089-1E757DAC15DF.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8768ee8201e949d8a7c2f7c0ec72b1e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n我们用劫持渲染的方式，来操纵`super.render()`后的`React.element`元素，然后配合 `createElement` , `cloneElement` , `React.Children` 等 `api`,可以灵活操纵，真正的渲染`react.element`，可以说是偷天换日，不亦乐乎。\n\n### 2.2节流渲染\n\n`hoc`除了可以进行**条件渲染**，**渲染劫持**功能外，还可以进行节流渲染，也就是可以优化性能，具体怎么做，请跟上我的节奏往下看。\n\n#### ① 基础: 节流原理\n\n`hoc`可以配合`hooks`的`useMemo`等`API`配合使用，可以实现对业务组件的渲染控制，减少渲染次数，从而达到优化性能的效果。如下案例，我们期望当且仅当`num`改变的时候，渲染组件，但是不影响接收的`props`。我们应该这样写我们的`HOC`。\n\n```js\nfunction HOC (Component){\n     return function renderWrapComponent(props){\n       const { num } = props\n       const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ num ])\n       return RenderElement\n     }\n}\nclass Index extends React.Component{\n  render(){\n     console.log(`当前组件是否渲染`,this.props)\n     return <div>hello,world, my name is alien </div>\n  }\n}\nconst IndexHoc = HOC(Index)\n\nexport default ()=> {\n    const [ num ,setNumber ] = useState(0)\n    const [ num1 ,setNumber1 ] = useState(0)\n    const [ num2 ,setNumber2 ] = useState(0)\n    return <div>\n        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />\n        <button onClick={() => setNumber(num + 1) } >num++</button>\n        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>\n        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>\n    </div>\n}\n```\n\n**效果：**\n\n![rend1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed5c42a503645118da7fbdf1e0a9920~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n如图所示,当我们只有点击 `num++`时候，才重新渲染子组件，点击其他按钮，只是负责传递了`props`,达到了期望的效果。\n\n#### ② 进阶：定制化渲染流\n\n思考：🤔上述的案例只是介绍了原理，在实际项目中，是量化生产不了的，原因是，我们需要针对不同`props`变化，写不同的`HOC`组件，这样根本起不了`Hoc`真正的用途，也就是`HOC`产生的初衷。所以我们需要对上述`hoc`进行改造升级，是组件可以根据定制化方向，去渲染组件。也就是`Hoc`生成的时候，已经按照某种契约去执行渲染。\n\n```js\nfunction HOC (rule){\n     return function (Component){\n        return function renderWrapComponent(props){\n          const dep = rule(props)\n          const RenderElement = useMemo(() =>  <Component {...props}  /> ,[ dep ])\n          return RenderElement\n        }\n     }\n}\n/* 只有 props 中 num 变化 ，渲染组件  */\n@HOC( (props)=> props['num'])\nclass IndexHoc extends React.Component{\n  render(){\n     console.log(`组件一渲染`,this.props)\n     return <div> 组件一 ： hello,world </div>\n  }\n}\n\n/* 只有 props 中 num1 变化 ，渲染组件  */\n@HOC((props)=> props['num1'])\nclass IndexHoc1 extends React.Component{\n  render(){\n     console.log(`组件二渲染`,this.props)\n     return <div> 组件二 ： my name is alien </div>\n  }\n}\nexport default ()=> {\n    const [ num ,setNumber ] = useState(0)\n    const [ num1 ,setNumber1 ] = useState(0)\n    const [ num2 ,setNumber2 ] = useState(0)\n    return <div>\n        <IndexHoc  num={ num } num1={num1} num2={ num2 }  />\n        <IndexHoc1  num={ num } num1={num1} num2={ num2 }  />\n        <button onClick={() => setNumber(num + 1) } >num++</button>\n        <button onClick={() => setNumber1(num1 + 1) } >num1++</button>\n        <button onClick={() => setNumber2(num2 + 1) } >num2++</button>\n    </div>\n}\n```\n\n**效果**\n\n![hoc2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/957c16b333b547e3bf99b5f635c055b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n完美实现了效果。这用高阶组件模式，可以灵活控制`React`组件层面上的，**`props`数据流**和**更新流**，优秀的高阶组件有 `mobx` 中`observer` ,`inject` , `react-redux`中的`connect`,感兴趣的同学，可以抽时间研究一下。\n\n## 3 赋能组件\n\n高阶组件除了上述两种功能之外，还可以赋能组件，比如加一些**额外`生命周期`**，**劫持事件**，**监控日志**等等。\n\n### 3.1 劫持原型链-劫持生命周期，事件函数\n\n#### ① 属性代理实现\n\n```js\nfunction HOC (Component){\n  const proDidMount = Component.prototype.componentDidMount \n  Component.prototype.componentDidMount = function(){\n     console.log('劫持生命周期：componentDidMount')\n     proDidMount.call(this)\n  }\n  return class wrapComponent extends React.Component{\n      render(){\n        return <Component {...this.props}  />\n      }\n  }\n}\n@HOC\nclass Index extends React.Component{\n   componentDidMount(){\n     console.log('———didMounted———')\n   }\n   render(){\n     return <div>hello,world</div>\n   }\n}\n```\n\n**效果**\n\n![A04A37C8-71CF-4DFD-BD59-E741DCC35EF4.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe21724cf8141a491cc3fab2dea7b46~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### ② 反向继承实现\n\n反向继承，因为在继承原有组件的基础上，可以对原有组件的**生命周期**或**事件**进行劫持，甚至是替换。\n\n```js\nfunction HOC (Component){\n  const didMount = Component.prototype.componentDidMount\n  return class wrapComponent extends Component{\n      componentDidMount(){\n        console.log('------劫持生命周期------')\n        if (didMount) {\n           didMount.apply(this) /* 注意 `this` 指向问题。 */\n        }\n      }\n      render(){\n        return super.render()\n      }\n  }\n}\n\n@HOC\nclass Index extends React.Component{\n   componentDidMount(){\n     console.log('———didMounted———')\n   }\n   render(){\n     return <div>hello,world</div>\n   }\n}\n```\n\n### 3.2 事件监控\n\n`HOC`还可以对原有组件进行监控。比如对一些`事件监控`，`错误监控`，`事件监听`等一系列操作。\n\n#### ① 组件内的事件监听\n\n接下来，我们做一个`HOC`,只对组件内的点击事件做一个监听效果。\n\n```js\n\nfunction ClickHoc (Component){\n  return  function Wrap(props){\n    const dom = useRef(null)\n    useEffect(()=>{\n     const handerClick = () => console.log('发生点击事件') \n     dom.current.addEventListener('click',handerClick)\n     return () => dom.current.removeEventListener('click',handerClick)\n    },[])\n    return  <div ref={dom}  ><Component  {...props} /></div>\n  }\n}\n\n@ClickHoc\nclass Index extends React.Component{\n   render(){\n     return <div  className='index'  >\n       <p>hello，world</p>\n       <button>组件内部点击</button>\n    </div>\n   }\n}\nexport default ()=>{\n  return <div className='box'  >\n     <Index />\n     <button>组件外部点击</button>\n  </div>\n}\n```\n\n**效果**\n\n![click.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e80fb646d654536af836b7d038fd62b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n### 3 ref助力操控组件实例\n\n对于属性代理我们虽然不能直接获取组件内的状态，但是我们可以通过`ref`获取组件实例,获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：`class`声明的有状态组件才有实例，`function`声明的无状态组件不存在实例。\n\n#### ① 属性代理-添加额外生命周期\n\n我们可以针对某一种情况, 给组件增加额外的生命周期，我做了一个简单的`demo`，监听`number`改变，如果`number`改变，就自动触发组件的监听函数`handerNumberChange`。 具体写法如下\n\n```js\nfunction Hoc(Component){\n  return class WrapComponent extends React.Component{\n      constructor(){\n        super()\n        this.node = null\n      }\n      UNSAFE_componentWillReceiveProps(nextprops){\n          if(nextprops.number !== this.props.number ){\n            this.node.handerNumberChange  &&  this.node.handerNumberChange.call(this.node)\n          }\n      }\n      render(){\n        return <Component {...this.props} ref={(node) => this.node = node }  />\n      }\n  }\n}\n@Hoc\nclass Index extends React.Component{\n  handerNumberChange(){\n      /* 监听 number 改变 */\n  }\n  render(){\n    return <div>hello,world</div>\n  }\n}\n```\n\n这种写法有点不尽人意，大家不要着急，在第四部分，源码实战中，我会介绍一种更好的场景。方便大家理解`Hoc`对原有组件的赋能。\n\n## 4 总结\n\n上面我分别按照`hoc`主要功能，**强化props** ， **控制渲染** ，**赋能组件** 三个方向对`HOC`编写做了一个详细介绍，和应用场景的介绍，目的**让大家在理解高阶组件的时候，更明白什么时候会用到？,怎么样去写？\\`** 里面涵盖的知识点我总一个总结。\n\n对于属性代理HOC，我们可以：\n\n+   强化props & 抽离state。\n+   条件渲染，控制渲染，分片渲染，懒加载。\n+   劫持事件和生命周期\n+   ref控制组件实例\n+   添加事件监听器，日志\n\n对于反向代理的HOC,我们可以：\n\n+   劫持渲染，操纵渲染树\n+   控制/替换生命周期，直接获取组件状态，绑定事件。\n\n每个应用场景，我都举了例子🌰🌰，大家可以结合例子深入了解一下其原理和用途。\n\n## 四 高阶组件源码级实践\n\n`hoc`的应用场景有很多，也有很多好的开源项目，供我们学习和参考，接下来我真对三个方向上的功能用途，分别从源码角度解析`HOC`的用途。\n\n## 1 强化prop- withRoute\n\n用过`withRoute`的同学，都明白其用途，`withRoute`用途就是，对于没有被`Route`包裹的组件，给添加`history`对象等和路由相关的状态，方便我们在任意组件中，都能够获取路由状态，进行路由跳转，这个`HOC`目的很清楚，就是强化`props`,把`Router`相关的状态都混入到`props`中，我们看看具体怎么实现的。\n\n```js\n\nfunction withRouter(Component) {\n  const displayName = `withRouter(${Component.displayName || Component.name})`;\n  const C = props => {\n      /*  获取 */\n    const { wrappedComponentRef, ...remainingProps } = props;\n    return (\n      <RouterContext.Consumer>\n        {context => {\n          return (\n            <Component\n              {...remainingProps}\n              {...context}\n              ref={wrappedComponentRef}\n            />\n          );\n        }}\n      </RouterContext.Consumer>\n    );\n  };\n\n  C.displayName = displayName;\n  C.WrappedComponent = Component;\n  /* 继承静态属性 */\n  return hoistStatics(C, Component);\n}\n\nexport default withRouter\n```\n\n`withRoute`的流程实际很简单，就是先从`props`分离出`ref`和`props`,然后从存放整个`route`对象上下文`RouterContext`取出`route`对象,然后混入到原始组件的`props`中，最后用`hoistStatics`继承静态属性。至于`hoistStatics`我们稍后会讲到。\n\n## 2 控制渲染案例 connect\n\n由于`connect`源码比较长和难以理解，所以我们提取精髓，精简精简再精简, 总结的核心功能如下,`connect`的作用也有`合并props`，但是更重要的是接受`state`，来控制更新组件。下面这个代码中，为了方便大家理解，我都给简化了。希望大家能够理解`hoc`如何**派发**和**控制**更新流的。\n\n```js\nimport store from './redux/store'\nimport { ReactReduxContext } from './Context'\nimport { useContext } from 'react'\nfunction connect(mapStateToProps){\n   /* 第一层： 接收订阅state函数 */\n    return function wrapWithConnect (WrappedComponent){\n        /* 第二层：接收原始组件 */\n        function ConnectFunction(props){\n            const [ , forceUpdate ] = useState(0)\n            const { reactReduxForwardedRef ,...wrapperProps } = props\n            \n            /* 取出Context */\n            const { store } = useContext(ReactReduxContext)\n\n            /* 强化props：合并 store state 和 props  */\n            const trueComponentProps = useMemo(()=>{\n                  /* 只有props或者订阅的state变化，才返回合并后的props */\n                 return selectorFactory(mapStateToProps(store.getState()),wrapperProps) \n            },[ store , wrapperProps ])\n\n            /* 只有 trueComponentProps 改变时候,更新组件。  */\n            const renderedWrappedComponent = useMemo(\n              () => (\n                <WrappedComponent\n                  {...trueComponentProps}\n                  ref={reactReduxForwardedRef}\n                />\n              ),\n              [reactReduxForwardedRef, WrappedComponent, trueComponentProps]\n            )\n            useEffect(()=>{\n              /* 订阅更新 */\n               const checkUpdate = () => forceUpdate(new Date().getTime())\n               store.subscribe( checkUpdate )\n            },[ store ])\n            return renderedWrappedComponent\n        }\n        /* React.memo 包裹  */\n        const Connect = React.memo(ConnectFunction)\n\n        /* 处理hoc,获取ref问题 */  \n        if(forwardRef){\n          const forwarded = React.forwardRef(function forwardConnectRef( props,ref) {\n            return <Connect {...props} reactReduxForwardedRef={ref} reactReduxForwardedRef={ref} />\n          })\n          return hoistStatics(forwarded, WrappedComponent)\n        } \n        /* 继承静态属性 */\n        return hoistStatics(Connect,WrappedComponent)\n    } \n}\nexport default Index\n```\n\n`connect` 涉及到的功能点还真不少呢，首先第一层接受订阅函数，第二层接收原始组件，然后用`forwardRef`处理`ref`,用`hoistStatics` 处理静态属性的继承，在包装组件内部，合并`props`,`useMemo`缓存原始组件，只有合并后的`props`发生变化，才更新组件，然后在`useEffect`内部通过`store.subscribe()`订阅更新。这里省略了`Subscription`概念，真正的`connect`中有一个`Subscription`专门负责订阅消息。\n\n## 3 赋能组件-缓存生命周期 keepaliveLifeCycle\n\n之前笔者写了一个`react`缓存页面的开源库`react-keepalive-router`，可以实现`vue`中 `keepalive` + `router`功能，最初的版本没有缓存周期的，但是后来热心读者，期望在被缓存的路由组件中加入缓存周期，类似`activated`这种的，后来经过我的分析打算用`HOC`来实现此功能。\n\n于是乎 `react-keepalive-router`加入了全新的页面组件生命周期 `actived` 和 `unActived`, `actived` 作为缓存路由组件激活时候用，初始化的时候会默认执行一次 , `unActived` 作为路由组件缓存完成后调用。但是生命周期需要用一个 `HOC` 组件`keepaliveLifeCycle` 包裹。\n\n使用\n\n```js\nimport React   from 'react'\nimport { keepaliveLifeCycle } from 'react-keepalive-router'\n\n@keepaliveLifeCycle\nclass index extends React.Component<any,any>{\n\n    state={\n        activedNumber:0,\n        unActivedNumber:0\n    }\n    actived(){\n        this.setState({\n            activedNumber:this.state.activedNumber + 1\n        })\n    }\n    unActived(){\n        this.setState({\n            unActivedNumber:this.state.unActivedNumber + 1\n        })\n    }\n    render(){\n        const { activedNumber , unActivedNumber } = this.state\n        return <div  style={{ marginTop :'50px' }}  >\n           <div> 页面 actived 次数： {activedNumber} </div>\n           <div> 页面 unActived 次数：{unActivedNumber} </div>\n        </div>\n    }\n}\nexport default index\n```\n\n**效果：**\n\n![lifecycle.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c534d245d59b40518de8a035fa9b6c75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n**原理**\n\n```js\nimport {lifeCycles} from '../core/keeper'\nimport hoistNonReactStatic from 'hoist-non-react-statics'\nfunction keepaliveLifeCycle(Component) {\n   class Hoc extends React.Component {\n    cur = null\n    handerLifeCycle = type => {\n      if (!this.cur) return\n      const lifeCycleFunc = this.cur[type]\n      isFuntion(lifeCycleFunc) && lifeCycleFunc.call(this.cur)\n    }\n    componentDidMount() { \n      const {cacheId} = this.props\n      cacheId && (lifeCycles[cacheId] = this.handerLifeCycle)\n    }\n    componentWillUnmount() {\n      const {cacheId} = this.props\n      delete lifeCycles[cacheId]\n    }\n     render=() => <Component {...this.props} ref={cur => (this.cur = cur)}/>\n  }\n  return hoistNonReactStatic(Hoc,Component)\n}\n```\n\n`keepaliveLifeCycle` 的原理很简单，就是通过`ref`或获取 `class` 组件的实例,在 `hoc` 初始化时候**进行生命周期的绑定**, 在 `hoc` 销毁阶段，对生命周期进行解绑, 然后交给`keeper`统一调度，`keeper`通过调用实例下面的生命周期函数，来实现缓存生命周期功能的。\n\n## 五 高阶组件的注意事项\n\n## 1 谨慎修改原型链\n\n```js\nfunction HOC (Component){\n  const proDidMount = Component.prototype.componentDidMount \n  Component.prototype.componentDidMount = function(){\n     console.log('劫持生命周期：componentDidMount')\n     proDidMount.call(this)\n  }\n  return  Component\n}\n```\n\n这样做会产生一些不良后果。比如如果你再用另一个同样会修改 `componentDidMount` 的 `HOC` 增强它，那么前面的 `HOC` 就会失效！同时，这个 `HOC` 也无法应用于没有生命周期的函数组件。\n\n## 2 继承静态属性\n\n在用属性代理的方式编写`HOC`的时候，要注意的是就是，静态属性丢失的问题，前面提到了，如果不做处理，静态方法就会全部丢失。\n\n### 手动继承\n\n我们可以手动将原始组件的静态方法`copy`到 `hoc`组件上来，但前提是必须准确知道应该拷贝哪些方法。\n\n```js\nfunction HOC(Component) {\n  class WrappedComponent extends React.Component {\n      /*...*/\n  }\n  // 必须准确知道应该拷贝哪些方法 \n  WrappedComponent.staticMethod = Component.staticMethod\n  return WrappedComponent\n}\n```\n\n### 引入第三方库\n\n这样每个静态方法都绑定会很累，尤其对于开源的`hoc`，**对原生组件的静态方法是未知的**,我们可以使用 `hoist-non-react-statics` 自动拷贝所有的静态方法:\n\n```js\nimport hoistNonReactStatic from 'hoist-non-react-statics'\nfunction HOC(Component) {\n  class WrappedComponent extends React.Component {\n      /*...*/\n  }\n  hoistNonReactStatic(WrappedComponent,Component)\n  return WrappedComponent\n}\n```\n\n## 3 跨层级捕获ref\n\n高阶组件的约定是将所有 `props` 传递给被包装组件，但这对于 `refs` 并不适用。那是因为 `ref` 实际上并不是一个 `prop` - 就像 `key` 一样，它是由 `React` 专门处理的。如果将 `ref` 添加到 `HOC` 的返回组件中，则 `ref` 引用指向容器组件，而不是被包装组件。我们可以通过`forwardRef`来解决这个问题。\n\n```js\n/**\n * \n * @param {*} Component 原始组件\n * @param {*} isRef  是否开启ref模式\n */\nfunction HOC(Component,isRef){\n  class Wrap extends React.Component{\n     render(){\n        const { forwardedRef ,...otherprops  } = this.props\n        return <Component ref={forwardedRef}  {...otherprops}  />\n     }\n  }\n    if(isRef){\n      return  React.forwardRef((props,ref)=> <Wrap forwardedRef={ref} {...props} /> )\n    }\n    return Wrap\n}\n\nclass Index extends React.Component{\n  componentDidMount(){\n      console.log(666)\n  }\n  render(){\n    return <div>hello,world</div>\n  }\n}\n\nconst HocIndex =  HOC(Index,true)\n\nexport default ()=>{\n  const node = useRef(null)\n  useEffect(()=>{\n     /* 就可以跨层级，捕获到 Index 组件的实例了 */ \n    console.log(node.current.componentDidMount)\n  },[])\n  return <div><HocIndex ref={node}  /></div>\n}\n```\n\n**打印结果：**\n\n![forwardRef.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb292247ca1470bb1cb6498616284c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n如上就解决了,`HOC`跨层级捕获`ref`的问题。\n\n## 4 render中不要声明HOC\n\n🙅错误写法：\n\n```js\nclass Index extends React.Component{\n  render(){\n     const WrapHome = HOC(Home)\n     return <WrapHome />\n  }\n}\n```\n\n如果这么写，会造成一个极大的问题，因为每一次`HOC`都会返回一个新的`WrapHome`,`react diff`会判定两次**不是同一个组件**，那么每次`Index` 组件 `render`触发，`WrapHome`，会重新挂载，状态会**全都丢失**。如果想要动态绑定`HOC`,请参考如下方式。\n\n🙆正确写法：\n\n```js\nconst WrapHome = HOC(Home)\nclass index extends React.Component{\n  render(){\n     return <WrapHome />\n  }\n}\n```\n\n## 六 总结\n\n本文从高阶组件功能为切入点，介绍二种不同的高阶组件如何编写，应用场景，以及实践。涵盖了大部分耳熟能详的开源高阶组件的应用场景，如果你觉得这篇文章对你有启发，最好还是按照文章中的`demo`，跟着敲一遍，加深印象，知道什么场景用高阶组件，怎么用高阶组件。\n\n`实践是检验真理的唯一标准`，希望大家能把高阶组件`码`起来，用起来。\n\n最后 ， 送人玫瑰，手留余香，觉得有收获的朋友可以给笔者**点赞，关注**一波 ，陆续更新前端超硬核文章。\n\n\n\n**开源项目系列**\n\n+   [「react缓存页面」从需求到开源（我是怎么样让产品小姐姐刮目相看的）](https://juejin.cn/post/6922340460136513549 \"https://juejin.cn/post/6922340460136513549\") `250+` 赞 👍\n\n## 参考文献\n\n[react中文文档](https://reactjs.org/ \"https://reactjs.org/\")"
    },
    {
      "id": "将React作为UI运行时",
      "metadata": {
        "permalink": "/将React作为UI运行时",
        "source": "@site/blog/将React作为UI运行时.md",
        "title": "将React作为UI运行时",
        "description": "请输入描述",
        "date": "2023-08-28T08:02:51.620Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 56.635,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "将React作为UI运行时",
          "title": "将React作为UI运行时",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "React高阶组件",
          "permalink": "/React高阶组件"
        },
        "nextItem": {
          "title": "React：事件机制原理",
          "permalink": "/React：事件机制原理"
        }
      },
      "content": "大多数教程把 React 称作是一个 UI 库。这是有道理的，因为 React 就是一个 UI 库。正如官网上的标语所说的那样。\n\n[![React homepage screenshot: ](https://overreacted.io/static/0429fcb4a2f2022852afc698ff8968f1/0b533/react.png)](https://overreacted.io/static/0429fcb4a2f2022852afc698ff8968f1/0b533/react.png)\n\n我曾经写过关于构建[用户界面](https://overreacted.io/zh-hans/the-elements-of-ui-engineering/)会遇到的难题一文。但是本篇文章将以一种不同的方式来讲述 React — 因为它更像是一种[编程运行时](https://en.wikipedia.org/wiki/Runtime_system)。\n\n**本篇文章不会教你任何有关如何创建用户界面的技巧。** 但是它可能会帮助你更深入地理解 React 编程模型。\n\n* * *\n\n**注意：如果你还在学习 React ，请移步到[官方文档](https://reactjs.org/docs/getting-started.html#learn-react)进行学习**\n\n⚠️\n\n**本篇文章将会非常深入 — 所以并不适合初学者阅读。** 在本篇文章中，我会从最佳原则的角度尽可能地阐述 React 编程模型。我不会解释如何使用它 — 而是讲解它的原理。\n\n文章面向有经验的程序员和那些使用过其他 UI 库但在项目中权衡利弊后最终选择了 React 的人，我希望它会对你有所帮助！\n\n**许多人成功使用了 React 多年却从未考虑过下面我将要讲述的主题。** 这肯定是从程序员的角度来看待 React ，而不是以[设计者](http://mrmrs.cc/writing/developing-ui/)的角度。但我并不认为站在两个不同的角度来重新认识 React 会有什么坏处。\n\n话不多说，让我们开始深入理解 React 吧！\n\n* * *\n\n## [](#%E5%AE%BF%E4%B8%BB%E6%A0%91)宿主树\n\n一些程序输出数字。另一些程序输出诗词。不同的语言和它们的运行时通常会对特定的一组用例进行优化，而 React 也不例外。\n\nReact 程序通常会输出**一棵会随时间变化的树。** 它有可能是一棵 [DOM 树](https://www.npmjs.com/package/react-dom) ，[iOS 视图层](https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/View%20Hierarchy.html) ，[PDF 原语](https://react-pdf.org/) ，又或是 [JSON 对象](https://reactjs.org/docs/test-renderer.html) 。然而，通常我们希望用它来展示 UI 。我们称它为“宿主树”，因为它往往是 React 之外宿主环境中的一部分 — 就像 DOM 或 iOS 。宿主树通常有[它](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)[自己](https://developer.apple.com/documentation/uikit/uiview/1622616-addsubview)的命令式 API 。而 React 就是它上面的那一层。\n\n所以到底 React 有什么用呢？非常抽象地，它可以帮助你编写可预测的，并且能够操控复杂的宿主树进而响应像用户交互、网络响应、定时器等外部事件的应用程序。\n\n当专业的工具可以施加特定的约束且能从中获益时，它比一般的工具要好。React 就是这样的典范，并且它坚持两个原则：\n\n+   **稳定性。** 宿主树是相对稳定的，大多数情况的更新并不会从根本上改变其整体结构。如果应用程序每秒都会将其所有可交互的元素重新排列为完全不同的组合，那将会变得难以使用。那个按钮去哪了？为什么我的屏幕在跳舞？\n+   **通用性。** 宿主树可以被拆分为外观和行为一致的 UI 模式（例如按钮、列表和头像）而不是随机的形状。\n\n**这些原则恰好适用于大多数 UI 。** 然而，当输出没有稳定的“模式”时 React 并不适用。例如，React 也许可以帮助你编写一个 Twitter 客户端，但对于一个 [3D 管道屏幕保护程序](https://www.youtube.com/watch?v=Uzx9ArZ7MUU) 并不会起太大作用。\n\n## [](#%E5%AE%BF%E4%B8%BB%E5%AE%9E%E4%BE%8B)宿主实例\n\n宿主树由节点组成，我们称之为“宿主实例”。\n\n在 DOM 环境中，宿主实例就是我们通常所说的 DOM 节点 — 就像当你调用 `document.createElement('div')` 时获得的对象。在 iOS 中，宿主实例可以是从 JavaScript 到原生视图唯一标识的值。\n\n宿主实例有它们自己的属性（例如 `domNode.className` 或者 `view.tintColor` ）。它们也有可能将其他的宿主实例作为子项。\n\n（这和 React 没有任何联系 — 因为我在讲述宿主环境。）\n\n通常会有原生的 API 用于操控这些宿主实例。例如，在 DOM 环境中会提供像 `appendChild`、`removeChild`、`setAttribute` 等一系列的 API 。在 React 应用中，通常你不会调用这些 API ，因为那是 React 的工作。\n\n## [](#%E6%B8%B2%E6%9F%93%E5%99%A8)渲染器\n\n渲染器教会 React 如何与特定的宿主环境通信以及如何管理它的宿主实例。React DOM、React Native 甚至 [Ink](https://mobile.twitter.com/vadimdemedes/status/1089344289102942211) 都可以称作 React 渲染器。你也可以[创建自己的 React 渲染器](https://github.com/facebook/react/tree/master/packages/react-reconciler) 。\n\nReact 渲染器能以下面两种模式之一进行工作。\n\n绝大多数渲染器都被用作“突变”模式。这种模式正是 DOM 的工作方式：我们可以创建一个节点，设置它的属性，在之后往里面增加或者删除子节点。宿主实例是完全可变的。\n\n但 React 也能以“不变”模式工作。这种模式适用于那些并不提供像 `appendChild` 的 API 而是克隆双亲树并始终替换掉顶级子树的宿主环境。在宿主树级别上的不可变性使得多线程变得更加容易。[React Fabric](https://facebook.github.io/react-native/blog/2018/06/14/state-of-react-native-2018) 就利用了这一模式。\n\n作为 React 的使用者，你永远不需要考虑这些模式。我只想强调 React 不仅仅只是从一种模式转换到另一种模式的适配器。它的用处在于以一种更好的方式操控宿主实例而不用在意那些低级视图 API 范例。\n\n## [](#react-%E5%85%83%E7%B4%A0)React 元素\n\n在宿主环境中，一个宿主实例（例如 DOM 节点）是最小的构建单元。而在 React 中，最小的构建单元是 React 元素。\n\nReact 元素是一个普通的 JavaScript 对象。它用来描述一个宿主实例。\n\n```jsx\n// JSX 是用来描述这些对象的语法糖。\n// <button className=\"blue\" />\n{\n  type: 'button',\n  props: { className: 'blue' }\n}\n```\n\nReact 元素是轻量级的因为没有宿主实例与它绑定在一起。同样的，它只是对你想要在屏幕上看到的内容的描述。\n\n就像宿主实例一样，React 元素也能形成一棵树：\n\n```jsx\n// JSX 是用来描述这些对象的语法糖。\n// <dialog>\n//   <button className=\"blue\" />\n//   <button className=\"red\" />\n// </dialog>\n{\n  type: 'dialog',\n  props: {\n    children: [{\n      type: 'button',\n      props: { className: 'blue' }\n    }, {\n      type: 'button',\n      props: { className: 'red' }\n    }]\n  }\n}\n```\n\n*(注意：我省略了一些对此解释不重要的[属性](https://overreacted.io/zh-hans/why-do-react-elements-have-typeof-property/))*\n\n但是，请记住 **React 元素并不是永远存在的** 。它们总是在重建和删除之间不断循环着。\n\nReact 元素具有不可变性。例如，你不能改变 React 元素中的子元素或者属性。如果你想要在稍后渲染一些不同的东西，你需要从头创建新的 React 元素树来描述它。\n\n我喜欢将 React 元素比作电影中放映的每一帧。它们捕捉 UI 在特定的时间点应该是什么样子。它们永远不会再改变。\n\n## [](#%E5%85%A5%E5%8F%A3)入口\n\n每一个 React 渲染器都有一个“入口”。正是那个特定的 API 让我们告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去。\n\n例如，React DOM 的入口就是 `ReactDOM.render` ：\n\n```jsx\nReactDOM.render(\n  // { type: 'button', props: { className: 'blue' } }\n  <button className=\"blue\" />,\n  document.getElementById('container')\n);\n```\n\n当我们调用 `ReactDOM.render(reactElement, domContainer)` 时，我们的意思是：**“亲爱的 React ，将我的 `reactElement` 映射到 `domContaienr` 的宿主树上去吧。”**\n\nReact 会查看 `reactElement.type` （在我们的例子中是 `button` ）然后告诉 React DOM 渲染器创建对应的宿主实例并设置正确的属性：\n\n```jsx\n// 在 ReactDOM 渲染器内部（简化版）\nfunction createHostInstance(reactElement) {\n  let domNode = document.createElement(reactElement.type);  domNode.className = reactElement.props.className;  return domNode;\n}\n```\n\n在我们的例子中，React 会这样做：\n\n```jsx\nlet domNode = document.createElement('button');domNode.className = 'blue';\ndomContainer.appendChild(domNode);\n```\n\n如果 React 元素在 `reactElement.props.children` 中含有子元素，React 会在第一次渲染中递归地为它们创建宿主实例。\n\n## [](#%E5%8D%8F%E8%B0%83)协调\n\n如果我们用同一个 container 调用 `ReactDOM.render()` 两次会发生什么呢？\n\n```jsx\nReactDOM.render(\n  <button className=\"blue\" />,  document.getElementById('container')\n);\n\n// ... 之后 ...\n\n// 应该替换掉 button 宿主实例吗？\n// 还是在已有的 button 上更新属性？\nReactDOM.render(\n  <button className=\"red\" />,  document.getElementById('container')\n);\n```\n\n同样的，React 的工作是将 React 元素树映射到宿主树上去。确定该对宿主实例做什么来响应新的信息有时候叫做[协调](https://reactjs.org/docs/reconciliation.html) 。\n\n有两种方法可以解决它。简化版的 React 会丢弃已经存在的树然后从头开始创建它：\n\n```jsx\nlet domContainer = document.getElementById('container');\n// 清除掉原来的树\ndomContainer.innerHTML = '';\n// 创建新的宿主实例树\nlet domNode = document.createElement('button');\ndomNode.className = 'red';\ndomContainer.appendChild(domNode);\n```\n\n但是在 DOM 环境下，这样的做法效率低下而且会丢失像 focus、selection、scroll 等许多状态。相反，我们希望 React 这样做：\n\n```jsx\nlet domNode = domContainer.firstChild;\n// 更新已有的宿主实例\ndomNode.className = 'red';\n```\n\n换句话说，React 需要决定何时更新一个已有的宿主实例来匹配新的 React 元素，何时该重新创建新的宿主实例。\n\n这就引出了一个识别问题。React 元素可能每次都不相同，到底什么时候才该从概念上引用同一个宿主实例呢？\n\n在我们的例子中，它很简单。我们之前渲染了 `<button>` 作为第一个（也是唯一）的子元素，接下来我们想要在同一个地方再次渲染 `<button>` 。在宿主实例中我们已经有了一个 `<button>` 为什么还要重新创建呢？让我们重用它。\n\n这与 React 如何思考并解决这类问题已经很接近了。\n\n**如果相同的元素类型在同一个地方先后出现两次，React 会重用已有的宿主实例。**\n\n这里有一个例子，其中的注释大致解释了 React 是如何工作的：\n\n```jsx\n// let domNode = document.createElement('button');\n// domNode.className = 'blue';\n// domContainer.appendChild(domNode);\nReactDOM.render(\n  <button className=\"blue\" />,\n  document.getElementById('container')\n);\n\n// 能重用宿主实例吗？能！(button → button)// domNode.className = 'red';ReactDOM.render(\n  <button className=\"red\" />,\n  document.getElementById('container')\n);\n\n// 能重用宿主实例吗？不能！(button → p)// domContainer.removeChild(domNode);\n// domNode = document.createElement('p');\n// domNode.textContent = 'Hello';\n// domContainer.appendChild(domNode);\nReactDOM.render(\n  <p>Hello</p>,\n  document.getElementById('container')\n);\n\n// 能重用宿主实例吗？能！(p → p)// domNode.textContent = 'Goodbye';ReactDOM.render(\n  <p>Goodbye</p>,\n  document.getElementById('container')\n);\n```\n\n同样的启发式方法也适用于子树。例如，当我们在 `<dialog>` 中新增两个 `<button>` ，React 会先决定是否要重用 `<dialog>` ，然后为每一个子元素重复这个决定步骤。\n\n## [](#%E6%9D%A1%E4%BB%B6)条件\n\n如果 React 在渲染更新前后只重用那些元素类型匹配的宿主实例，那当遇到包含条件语句的内容时又该如何渲染呢？\n\n假设我们只想首先展示一个输入框，但之后要在它之前渲染一条信息：\n\n```jsx\n// 第一次渲染\nReactDOM.render(\n  <dialog>\n    <input />\n  </dialog>,\n  domContainer\n);\n\n// 下一次渲染\nReactDOM.render(\n  <dialog>\n    <p>I was just added here!</p>    <input />\n  </dialog>,\n  domContainer\n);\n```\n\n在这个例子中，`<input>` 宿主实例会被重新创建。React 会遍历整个元素树，并将其与先前的版本进行比较：\n\n+   `dialog → dialog` ：能重用宿主实例吗？**能 — 因为类型是匹配的。**\n    \n    +   `input → p` ：能重用宿主实例吗？**不能，类型改变了！** 需要删除已有的 `input` 然后重新创建一个 `p` 宿主实例。\n    +   `(nothing) → input` ：需要重新创建一个 `input` 宿主实例。\n\n因此，React 会像这样执行更新：\n\n```jsx\nlet oldInputNode = dialogNode.firstChild;dialogNode.removeChild(oldInputNode);\nlet pNode = document.createElement('p');\npNode.textContent = 'I was just added here!';\ndialogNode.appendChild(pNode);\n\nlet newInputNode = document.createElement('input');dialogNode.appendChild(newInputNode);\n```\n\n这样的做法并不科学因为事实上 `<input>` 并没有被 `<p>` 所替代 — 它只是移动了位置而已。我们不希望因为重建 DOM 而丢失了 selection、focus 等状态以及其中的内容。\n\n虽然这个问题很容易解决（在下面我会马上讲到），但这个问题在 React 应用中并不常见。而当我们探讨为什么会这样时却很有意思。\n\n事实上，你很少会直接调用 `ReactDOM.render` 。相反，在 React 应用中程序往往会被拆分成这样的函数：\n\n```jsx\nfunction Form({ showMessage }) {\n  let message = null;\n  if (showMessage) {\n    message = <p>I was just added here!</p>;\n  }\n  return (\n    <dialog>\n      {message}\n      <input />\n    </dialog>\n  );\n}\n```\n\n这个例子并不会遇到刚刚我们所描述的问题。让我们用对象注释而不是 JSX 也许可以更好地理解其中的原因。来看一下 `dialog` 中的子元素树：\n\n```jsx\nfunction Form({ showMessage }) {\n  let message = null;\n  if (showMessage) {\n    message = {\n      type: 'p',\n      props: { children: 'I was just added here!' }\n    };\n  }\n  return {\n    type: 'dialog',\n    props: {\n      children: [        message,        { type: 'input', props: {} }      ]    }\n  };\n}\n```\n\n**不管 `showMessage` 是 `true` 还是 `false` ，在渲染的过程中 `<input>` 总是在第二个孩子的位置且不会改变。**\n\n如果 `showMessage` 从 `false` 改变为 `true` ，React 会遍历整个元素树，并与之前的版本进行比较：\n\n+   `dialog → dialog` ：能够重用宿主实例吗？**能 — 因为类型匹配。**\n    \n    +   `(null) → p` ：需要插入一个新的 `p` 宿主实例。\n    +   `input → input` ：能够重用宿主实例吗？**能 — 因为类型匹配。**\n\n之后 React 大致会像这样执行代码：\n\n```jsx\nlet inputNode = dialogNode.firstChild;\nlet pNode = document.createElement('p');\npNode.textContent = 'I was just added here!';\ndialogNode.insertBefore(pNode, inputNode);\n```\n\n这样一来输入框中的状态就不会丢失了。\n\n## [](#%E5%88%97%E8%A1%A8)列表\n\n比较树中同一位置的元素类型对于是否该重用还是重建相应的宿主实例往往已经足够。\n\n但这只适用于当子元素是静止的并且不会重排序的情况。在上面的例子中，即使 `message` 不存在，我们仍然知道输入框在消息之后，并且再没有其他的子元素。\n\n而当遇到动态列表时，我们不能确定其中的顺序总是一成不变的。\n\n```jsx\nfunction ShoppingList({ list }) {\n  return (\n    <form>\n      {list.map(item => (\n        <p>\n          You bought {item.name}\n          <br />\n          Enter how many do you want: <input />\n        </p>\n      ))}\n    </form>\n  )\n}\n```\n\n如果我们的商品列表被重新排序了，React 只会看到所有的 `p` 以及里面的 `input` 拥有相同的类型，并不知道该如何移动它们。（在 React 看来，虽然这些商品本身改变了，但是它们的顺序并没有改变。）\n\n所以 React 会对这十个商品进行类似如下的重排序：\n\n```jsx\nfor (let i = 0; i < 10; i++) {\n  let pNode = formNode.childNodes[i];\n  let textNode = pNode.firstChild;\n  textNode.textContent = 'You bought ' + items[i].name;\n}\n```\n\nReact 只会对其中的每个元素进行更新而不是将其重新排序。这样做会造成性能上的问题和潜在的 bug 。例如，当商品列表的顺序改变时，原本在第一个输入框的内容仍然会存在于现在的第一个输入框中 — 尽管事实上在商品列表里它应该代表着其他的商品！\n\n**这就是为什么每次当输出中包含元素数组时，React 都会让你指定一个叫做 `key` 的属性：**\n\n```jsx\nfunction ShoppingList({ list }) {\n  return (\n    <form>\n      {list.map(item => (\n        <p key={item.productId}>          You bought {item.name}\n          <br />\n          Enter how many do you want: <input />\n        </p>\n      ))}\n    </form>\n  )\n}\n```\n\n`key` 给予 React 判断子元素是否真正相同的能力，即使在渲染前后它在父元素中的位置不是相同的。\n\n当 React 在 `<form>` 中发现 `<p key=\"42\">` ，它就会检查之前版本中的 `<form>` 是否同样含有 `<p key=\"42\">` 。即使 `<form>` 中的子元素们改变位置后，这个方法同样有效。在渲染前后当 key 仍然相同时，React 会重用先前的宿主实例，然后重新排序其兄弟元素。\n\n需要注意的是 `key` 只与特定的父亲 React 元素相关联，比如 `<form>` 。React 并不会去匹配父元素不同但 key 相同的子元素。（React 并没有惯用的支持对在不重新创建元素的情况下让宿主实例在不同的父元素之间移动。）\n\n给 `key` 赋予什么值最好呢？最好的答案就是：**什么时候你会说一个元素不会改变即使它在父元素中的顺序被改变？** 例如，在我们的商品列表中，商品本身的 ID 是区别于其他商品的唯一标识，那么它就最适合作为 `key` 。\n\n## [](#%E7%BB%84%E4%BB%B6)组件\n\n我们已经知道函数会返回 React 元素：\n\n```jsx\nfunction Form({ showMessage }) {\n  let message = null;\n  if (showMessage) {\n    message = <p>I was just added here!</p>;\n  }\n  return (\n    <dialog>\n      {message}\n      <input />\n    </dialog>\n  );\n}\n```\n\n这些函数被叫做组件。它们让我们可以打造自己的“工具箱”，例如按钮、头像、评论框等等。组件就像 React 的面包和黄油。\n\n组件接受一个参数 — 对象哈希。它包含“props”（“属性”的简称）。在这里 `showMessage` 就是一个 prop 。它们就像是具名参数一样。\n\n## [](#%E7%BA%AF%E5%87%80)纯净\n\nReact 组件中对于 props 应该是纯净的。\n\n```jsx\nfunction Button(props) {\n  // 🔴 没有作用\n  props.isActive = true;\n}\n```\n\n通常来说，突变在 React 中不是惯用的。（我们会在之后讲解如何用更惯用的方式来更新 UI 以响应事件。）\n\n不过，局部的突变是绝对允许的：\n\n```jsx\nfunction FriendList({ friends }) {\n  let items = [];  for (let i = 0; i < friends.length; i++) {\n    let friend = friends[i];\n    items.push(      <Friend key={friend.id} friend={friend} />\n    );\n  }\n  return <section>{items}</section>;\n}\n```\n\n当我们在函数组件内部创建 `items` 时不管怎样改变它都行，只要这些突变发生在将其作为最后的渲染结果之前。所以并不需要重写你的代码来避免局部突变。\n\n同样地，惰性初始化是被允许的即使它不是完全“纯净”的：\n\n```jsx\nfunction ExpenseForm() {\n  // 只要不影响其他组件这是被允许的：\n  SuperCalculator.initializeIfNotReady();\n\n  // 继续渲染......\n}\n```\n\n只要调用组件多次是安全的，并且不会影响其他组件的渲染，React 并不关心你的代码是否像严格的函数式编程一样百分百纯净。在 React 中，[幂等性](https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation)比纯净性更加重要。\n\n也就是说，在 React 组件中不允许有用户可以直接看到的副作用。换句话说，仅调用函数式组件时不应该在屏幕上产生任何变化。\n\n## [](#%E9%80%92%E5%BD%92)递归\n\n我们该如何在组件中使用组件？组件属于函数因此我们可以直接进行调用：\n\n```jsx\nlet reactElement = Form({ showMessage: true });\nReactDOM.render(reactElement, domContainer);\n```\n\n然而，在 React 运行时中这并不是惯用的使用组件的方式。\n\n相反，使用组件惯用的方式与我们已经了解的机制相同 — 即 React 元素。**这意味着不需要你直接调用组件函数，React 会在之后为你做这件事情：**\n\n```jsx\n// { type: Form, props: { showMessage: true } }\nlet reactElement = <Form showMessage={true} />;\nReactDOM.render(reactElement, domContainer);\n```\n\n然后在 React 内部，你的组件会这样被调用：\n\n```jsx\n// React 内部的某个地方\nlet type = reactElement.type; // Form\nlet props = reactElement.props; // { showMessage: true }\nlet result = type(props); // 无论 Form 会返回什么\n```\n\n组件函数名称按照规定需要大写。当 JSX 转换时看见 `<Form>` 而不是 `<form>` ，它让对象 `type` 本身成为标识符而不是字符串：\n\n```jsx\nconsole.log(<form />.type); // 'form' 字符串\nconsole.log(<Form />.type); // Form 函数\n```\n\n我们并没有全局的注册机制 — 字面上当我们输入 `<Form>` 时代表着 `Form` 。如果 `Form` 在局部作用域中并不存在，你会发现一个 JavaScript 错误，就像平常你使用错误的变量名称一样。\n\n**因此，当元素类型是一个函数的时候 React 会做什么呢？它会调用你的组件，然后询问组件想要渲染什么元素。**\n\n这个步骤会递归式地执行下去，更详细的描述在[这里](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html) 。总的来说，它会像这样执行：\n\n+   **你：** `ReactDOM.render(<App />, domContainer)`\n+   **React：** `App` ，你想要渲染什么？\n    \n    +   `App` ：我要渲染包含 `<Content>` 的 `<Layout>` 。\n+   **React：** `<Layout>` ，你要渲染什么？\n    \n    +   `Layout` ：我要在 `<div>` 中渲染我的子元素。我的子元素是 `<Content>` 所以我猜它应该渲染到 `<div>` 中去。\n+   **React：** `<Content>` ，你要渲染什么？\n    \n    +   `<Content>` ：我要在 `<article>` 中渲染一些文本和 `<Footer>` 。\n+   **React：** `<Footer>` ，你要渲染什么？\n    \n    +   `<Footer>` ：我要渲染含有文本的 `<footer>` 。\n+   **React：** 好的，让我们开始吧：\n\n```jsx\n// 最终的 DOM 结构\n<div>\n  <article>\n    Some text\n    <footer>some more text</footer>\n  </article>\n</div>\n```\n\n这就是为什么我们说协调是递归式的。当 React 遍历整个元素树时，可能会遇到元素的 `type` 是一个组件。React 会调用它然后继续沿着返回的 React 元素下行。最终我们会调用完所有的组件，然后 React 就会知道该如何改变宿主树。\n\n在之前已经讨论过的相同的协调准则，在这一样适用。如果在同一位置的 `type` 改变了（由索引和可选的 `key` 决定），React 会删除其中的宿主实例并将其重建。\n\n## [](#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)控制反转\n\n你也许会好奇：为什么我们不直接调用组件？为什么要编写 `<Form />` 而不是 `Form()` ？\n\n**React 能够做的更好如果它“知晓”你的组件而不是在你递归调用它们之后生成的 React 元素树。**\n\n```jsx\n// 🔴 React 并不知道 Layout 和 Article 的存在。\n// 因为你在调用它们。\nReactDOM.render(\n  Layout({ children: Article() }),\n  domContainer\n)\n\n// ✅ React知道 Layout 和 Article 的存在。\n// React 来调用它们。\nReactDOM.render(\n  <Layout><Article /></Layout>,\n  domContainer\n)\n```\n\n这是一个关于[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)的经典案例。通过让 React 调用我们的组件，我们会获得一些有趣的属性：\n\n+   **组件不仅仅只是函数。** React 能够用在树中与组件本身紧密相连的局部状态等特性来增强组件功能。优秀的运行时提供了与当前问题相匹配的基本抽象。就像我们已经提到过的，React 专门针对于那些渲染 UI 树并且能够响应交互的应用。如果你直接调用了组件，你就只能自己来构建这些特性了。\n+   **组件类型参与协调。** 通过 React 来调用你的组件，能让它了解更多关于元素树的结构。例如，当你从渲染 `<Feed>` 页面转到 `Profile` 页面，React 不会尝试重用其中的宿主实例 — 就像你用 `<p>` 替换掉 `<button>` 一样。所有的状态都会丢失 — 对于渲染完全不同的视图时，通常来说这是一件好事。你不会想要在 `<PasswordForm>` 和 `<MessengerChat>` 之间保留输入框的状态尽管 `<input>` 的位置意外地“排列”在它们之间。\n+   **React 能够推迟协调。** 如果让 React 控制调用你的组件，它能做很多有趣的事情。例如，它可以让浏览器在组件调用之间做一些工作，这样重渲染大体量的组件树时就[不会阻塞主线程](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)。想要手动编排这个过程而不依赖 React 的话将会十分困难。\n+   **更好的可调试性。** 如果组件是库中所重视的一等公民，我们就可以构建[丰富的开发者工具](https://github.com/facebook/react-devtools)，用于开发中的自省。\n\n让 React 调用你的组件函数还有最后一个好处就是惰性求值。让我们看看它是什么意思。\n\n## [](#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC)惰性求值\n\n当我们在 JavaScript 中调用函数时，参数往往在函数调用之前被执行。\n\n```jsx\n// (2) 它会作为第二个计算\neat(\n  // (1) 它会首先计算\n  prepareMeal()\n);\n```\n\n这通常是 JavaScript 开发者所期望的因为 JavaScript 函数可能有隐含的副作用。如果我们调用了一个函数，但直到它的结果不知怎地被“使用”后该函数仍没有执行，这会让我们感到十分诧异。\n\n但是，React 组件是[相对](#%E7%BA%AF%E5%87%80)纯净的。如果我们知道它的结果不会在屏幕上出现，则完全没有必要执行它。\n\n考虑下面这个含有 `<Comments>` 的 `<Page>` 组件：\n\n```jsx\nfunction Story({ currentUser }) {\n  // return {\n  //   type: Page,\n  //   props: {\n  //     user: currentUser,\n  //     children: { type: Comments, props: {} }\n  //   }\n  // }\n  return (\n    <Page user={currentUser}>\n      <Comments />    </Page>\n  );\n}\n```\n\n`<Page>` 组件能够在 `<Layout>` 中渲染传递给它的子项：\n\n```jsx\nfunction Page({ currentUser, children }) {\n  return (\n    <Layout>\n      {children}    </Layout>\n  );\n}\n```\n\n*(在 JSX 中 `<A><B /></A>` 和 `<A children={<B />} />`相同。)*\n\n但是要是存在提前返回的情况呢？\n\n```jsx\nfunction Page({ currentUser, children }) {\n  if (!currentUser.isLoggedIn) {    return <h1>Please login</h1>;  }  return (\n    <Layout>\n      {children}\n    </Layout>\n  );\n}\n```\n\n如果我们像函数一样调用 `Comments()` ，不管 `Page` 是否想渲染它们都会被立即执行：\n\n```jsx\n// {\n//   type: Page,\n//   props: {\n//     children: Comments() // 总是调用！//   }\n// }\n<Page>\n  {Comments()}</Page>\n```\n\n但是如果我们传递的是一个 React 元素，我们不需要自己执行 `Comments` ：\n\n```jsx\n// {\n//   type: Page,\n//   props: {\n//     children: { type: Comments }//   }\n// }\n<Page>\n  <Comments /></Page>\n```\n\n让 React 来决定何时以及是否调用组件。如果我们的的 `Page` 组件忽略自身的 `children` prop 且相反地渲染了 `<h1>Please login</h1>` ，React 不会尝试去调用 `Comments` 函数。重点是什么？\n\n这很好，因为它既可以让我们避免不必要的渲染也能使我们的代码变得不那么脆弱。（当用户退出登录时，我们并不在乎 `Comments` 是否被丢弃 — 因为它从没有被调用过。）\n\n## [](#%E7%8A%B6%E6%80%81)状态\n\n我们先前提到过关于[协调](#%E5%8D%8F%E8%B0%83)和在树中元素概念上的“位置”是如何让 React 知晓是该重用宿主实例还是该重建它。宿主实例能够拥有所有相关的局部状态：focus、selection、input 等等。我们想要在渲染更新概念上相同的 UI 时保留这些状态。我们也想可预测性地摧毁它们，当我们在概念上渲染的是完全不同的东西时（例如从 `<SignupForm>` 转换到 `<MessengerChat>`）。\n\n**局部状态是如此有用，以至于 React 让你的组件也能拥有它。** 组件仍然是函数但是 React 用对构建 UI 有好处的许多特性增强了它。在树中每个组件所绑定的局部状态就是这些特性之一。\n\n我们把这些特性叫做 Hooks 。例如，`useState` 就是一个 Hook 。\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>      <button onClick={() => setCount(count + 1)}>        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n它返回一对值：当前的状态和更新该状态的函数。\n\n数组的[解构语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring)让我们可以给状态变量自定义名称。例如，我在这里称它们为 `count` 和 `setCount` ，但是它们也可以被称作 `banana` 和 `setBanana` 。在这些文字之下，我们会用 `setState` 来替代第二个值无论它在具体的例子中被称作什么。\n\n*(你能在 [React 文档](https://reactjs.org/docs/hooks-intro.html) 中学习到更多关于 `useState` 和 其他 Hooks 的知识。)*\n\n## [](#%E4%B8%80%E8%87%B4%E6%80%A7)一致性\n\n即使我们想将协调过程本身分割成[非阻塞](https://www.youtube.com/watch?v=mDdgfyRB5kg)的工作块，我们仍然需要在同步的循环中对真实的宿主实例进行操作。这样我们才能保证用户不会看见半更新状态的 UI ，浏览器也不会对用户不应看到的中间状态进行不必要的布局和样式的重新计算。\n\n这也是为什么 React 将所有的工作分成了“渲染阶段”和“提交阶段”的原因。*渲染阶段* 是当 React 调用你的组件然后进行协调的时段。在此阶段进行干涉是安全的且在[未来](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)这个阶段将会变成异步的。*提交阶段* 就是 React 操作宿主树的时候。而这个阶段永远是同步的。\n\n## [](#%E7%BC%93%E5%AD%98)缓存\n\n当父组件通过 `setState` 准备更新时，React 默认会协调整个子树。因为 React 并不知道在父组件中的更新是否会影响到其子代，所以 React 默认保持一致性。这听起来会有很大的性能消耗但事实上对于小型和中型的子树来说，这并不是问题。\n\n当树的深度和广度达到一定程度时，你可以让 React 去[缓存](https://en.wikipedia.org/wiki/Memoization)子树并且重用先前的渲染结果当 prop 在浅比较之后是相同时：\n\n```jsx\nfunction Row({ item }) {\n  // ...\n}\n\nexport default React.memo(Row);\n```\n\n现在，在父组件 `<Table>` 中调用 `setState` 时如果 `<Row>` 中的 `item` 与先前渲染的结果是相同的，React 就会直接跳过协调的过程。\n\n你可以通过 [`useMemo()` Hook](https://reactjs.org/docs/hooks-reference.html#usememo) 获得单个表达式级别的细粒度缓存。该缓存于其相关的组件紧密联系在一起，并且将与局部状态一起被销毁。它只会保留最后一次计算的结果。\n\n默认情况下，React 不会故意缓存组件。许多组件在更新的过程中总是会接收到不同的 props ，所以对它们进行缓存只会造成净亏损。\n\n## [](#%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%9E%8B)原始模型\n\n令人讽刺地是，React 并没有使用“反应式”的系统来支持细粒度的更新。换句话说，任何在顶层的更新只会触发协调而不是局部更新那些受影响的组件。\n\n这样的设计是有意而为之的。对于 web 应用来说[交互时间](https://calibreapp.com/blog/time-to-interactive/)是一个关键指标，而通过遍历整个模型去设置细粒度的监听器只会浪费宝贵的时间。此外，在很多应用中交互往往会导致或小（按钮悬停）或大（页面转换）的更新，因此细粒度的订阅只会浪费内存资源。\n\nReact 的设计原则之一就是它可以处理原始数据。如果你拥有从网络请求中获得的一组 JavaScript 对象，你可以将其直接交给组件而无需进行预处理。没有关于可以访问哪些属性的问题，或者当结构有所变化时造成的意外的性能缺损。React 渲染是 O(*视图大小*) 而不是 O(*模型大小*) ，并且你可以通过 [windowing](https://react-window.now.sh/#/examples/list/fixed-size) 显著地减少视图大小。\n\n有那么一些应用细粒度订阅对它们来说是有用的 — 例如股票代码。这是一个极少见的例子，因为“所有的东西都需要在同一时间内持续更新”。虽然命令式的方法能够优化此类代码，但 React 并不适用于这种情况。同样的，如果你想要解决该问题，你就得在 React 之上自己实现细粒度的订阅。\n\n**注意，即使细粒度订阅和“反应式”系统也无法解决一些常见的性能问题。** 例如，渲染一棵很深的树（在每次页面转换的时候发生）而不阻塞浏览器。改变跟踪并不会让它变得更快 — 这样只会让其变得更慢因为我们执行了额外的订阅工作。另一个问题是我们需要等待返回的数据在渲染视图之前。在 React 中，我们用[并发渲染](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html)来解决这些问题。\n\n## [](#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0)批量更新\n\n一些组件也许想要更新状态来响应同一事件。下面这个例子是假设的，但是却说明了一个常见的模式：\n\n```jsx\nfunction Parent() {\n  let [count, setCount] = useState(0);\n  return (\n    <div onClick={() => setCount(count + 1)}>      Parent clicked {count} times\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  let [count, setCount] = useState(0);\n  return (\n    <button onClick={() => setCount(count + 1)}>      Child clicked {count} times\n    </button>\n  );\n}\n```\n\n当事件被触发时，子组件的 `onClick` 首先被触发（同时触发了它的 `setState` ）。然后父组件在它自己的 `onClick` 中调用 `setState` 。\n\n如果 React 立即重渲染组件以响应 `setState` 调用，最终我们会重渲染子组件两次：\n\n```jsx\n*** 进入 React 浏览器 click 事件处理过程 ***\nChild (onClick)\n  - setState\n  - re-render Child // 😞 不必要的重渲染Parent (onClick)\n  - setState\n  - re-render Parent\n  - re-render Child*** 结束 React 浏览器 click 事件处理过程 ***\n```\n\n第一次 `Child` 组件渲染是浪费的。并且我们也不会让 React 跳过 `Child` 的第二次渲染因为 `Parent` 可能会传递不同的数据由于其自身的状态更新。\n\n**这就是为什么 React 会在组件内所有事件触发完成后再进行批量更新的原因：**\n\n```jsx\n*** 进入 React 浏览器 click 事件处理过程 ***\nChild (onClick)\n  - setState\nParent (onClick)\n  - setState\n*** Processing state updates                     ***\n  - re-render Parent\n  - re-render Child\n*** 结束 React 浏览器 click 事件处理过程  ***\n```\n\n组件内调用 `setState` 并不会立即执行重渲染。相反，React 会先触发所有的事件处理器，然后再触发一次重渲染以进行所谓的批量更新。\n\n批量更新虽然有用但可能会让你感到惊讶如果你的代码这样写：\n\n```jsx\n  const [count, setCounter] = useState(0);\n\n  function increment() {\n    setCounter(count + 1);\n  }\n\n  function handleClick() {\n    increment();\n    increment();\n    increment();\n  }\n```\n\n如果我们将 `count` 初始值设为 `0` ，上面的代码只会代表三次 `setCount(1)` 调用。为了解决这个问题，我们给 `setState` 提供了一个 “updater” 函数作为参数：\n\n```jsx\n  const [count, setCounter] = useState(0);\n\n  function increment() {\n    setCounter(c => c + 1);\n  }\n\n  function handleClick() {\n    increment();\n    increment();\n    increment();\n  }\n```\n\nReact 会将 updater 函数放入队列中，并在之后按顺序执行它们，最终 `count` 会被设置成 `3` 并作为一次重渲染的结果。\n\n当状态逻辑变得更加复杂而不仅仅只是少数的 `setState` 调用时，我建议你使用 [`useReducer` Hook](https://reactjs.org/docs/hooks-reference.html#usereducer) 来描述你的局部状态。它就像 “updater” 的升级模式在这里你可以给每一次更新命名：\n\n```jsx\n  const [counter, dispatch] = useReducer((state, action) => {\n    if (action === 'increment') {\n      return state + 1;\n    } else {\n      return state;\n    }\n  }, 0);\n\n  function handleClick() {\n    dispatch('increment');\n    dispatch('increment');\n    dispatch('increment');\n  }\n```\n\n`action` 字段可以是任意值，尽管对象是常用的选择。\n\n## [](#%E8%B0%83%E7%94%A8%E6%A0%91)调用树\n\n编程语言的运行时往往有[调用栈](https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4) 。当函数 `a()` 调用 `b()` ，`b()` 又调用 `c()` 时，在 JavaScript 引擎中会有像 `[a, b, c]` 这样的数据结构来“跟踪”当前的位置以及接下来要执行的代码。一旦 `c` 函数执行完毕，它的调用栈帧就消失了！因为它不再被需要了。我们返回到函数 `b` 中。当我们结束函数 `a` 的执行时，调用栈就被清空。\n\n当然，React 以 JavaScript 运行当然也遵循 JavaScript 的规则。但是我们可以想象在 React 内部有自己的调用栈用来记忆我们当前正在渲染的组件，例如 `[App, Page, Layout, Article /* 此刻的位置 */]` 。\n\nReact 与通常意义上的编程语言进行时不同因为它针对于渲染 UI 树，这些树需要保持“活性”，这样才能使我们与其进行交互。在第一次 `ReactDOM.render()` 出现之前，DOM 操作并不会执行。\n\n这也许是对隐喻的延伸，但我喜欢把 React 组件当作 “调用树” 而不是 “调用栈” 。当我们调用完 `Article` 组件，它的 React “调用树” 帧并没有被摧毁。我们需要将局部状态保存以便映射到宿主实例的[某个地方](https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7)。\n\n这些“调用树”帧会随它们的局部状态和宿主实例一起被摧毁，但是只会在[协调](#%E5%8D%8F%E8%B0%83)规则认为这是必要的时候执行。如果你曾经读过 React 源码，你就会知道这些帧其实就是 [Fibers](https://en.wikipedia.org/wiki/Fiber_(computer_science)) 。\n\nFibers 是局部状态真正存在的地方。当状态被更新后，React 将其下面的 Fibers 标记为需要进行协调，之后便会调用这些组件。\n\n## [](#%E4%B8%8A%E4%B8%8B%E6%96%87)上下文\n\n在 React 中，我们将数据作为 props 传递给其他组件。有些时候，大多数组件需要相同的东西 — 例如，当前选中的可视主题。将它一层层地传递会变得十分麻烦。\n\n在 React 中，我们通过 [Context](https://reactjs.org/docs/context.html) 解决这个问题。它就像组件的[动态范围](http://wiki.c2.com/?DynamicScoping) ，能让你从顶层传递数据，并让每个子组件在底部能够读取该值，当值变化时还能够进行重新渲染：\n\n```jsx\nconst ThemeContext = React.createContext(\n  'light' // 默认值作为后备\n);\n\nfunction DarkApp() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <MyComponents />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction SomeDeeplyNestedChild() {\n  // 取决于其子组件在哪里被渲染\n  const theme = useContext(ThemeContext);\n  // ...\n}\n```\n\n当 `SomeDeeplyNestedChild` 渲染时， `useContext(ThemeContext)` 会寻找树中最近的 `<ThemeContext.Provider>` ，并且使用它的 `value` 。\n\n(事实上，React 维护了一个上下文栈当其渲染时。)\n\n如果没有 `ThemeContext.Provider` 存在，`useContext(ThemeContext)` 调用的结果就会被调用 `createContext()` 时传递的默认值所取代。在上面的例子中，这个值为 `'light'` 。\n\n## [](#%E5%89%AF%E4%BD%9C%E7%94%A8)副作用\n\n我们在之前提到过 React 组件在渲染过程中不应该有可观察到的副作用。但是有些时候副作用确实必要的。我们也许需要进行管理 focus 状态、用 canvas 画图、订阅数据源等操作。\n\n在 React 中，这些都可以通过声明 effect 来完成：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {    document.title = `You clicked ${count} times`;  });\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n如果可能，React 会推迟执行 effect 直到浏览器重新绘制屏幕。这是有好处的因为像订阅数据源这样的代码并不会影响[交互时间](https://calibreapp.com/blog/time-to-interactive/)和[首次绘制时间](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint) 。\n\n（有一个[极少使用](https://reactjs.org/docs/hooks-reference.html#uselayouteffect)的 Hook 能够让你选择退出这种行为并进行一些同步的工作。请尽量避免使用它。）\n\neffect 不只执行一次。当组件第一次展示给用户以及之后的每次更新时它都会被执行。在 effect 中能触及当前的 props 和 state，例如上文例子中的 `count` 。\n\neffect 可能需要被清理，例如订阅数据源的例子。在订阅之后将其清理，effect 能够返回一个函数：\n\n```jsx\n  useEffect(() => {\n    DataSource.addSubscription(handleChange);\n    return () => DataSource.removeSubscription(handleChange);\n  });\n```\n\nReact 会在下次调用该 effect 之前执行这个返回的函数，当然是在组件被摧毁之前。\n\n有些时候，在每次渲染中都重新调用 effect 是不符合实际需要的。 你可以告诉 React 如果相应的变量不会改变则跳过此次调用：\n\n```jsx\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]);\n```\n\n但是，这往往会成为过早地优化并会造成一些问题如果你不熟悉 JavaScript 中的闭包是如何工作的话。\n\n例如，下面的这段代码是有 bug 的：\n\n```jsx\n  useEffect(() => {\n    DataSource.addSubscription(handleChange);\n    return () => DataSource.removeSubscription(handleChange);\n  }, []);\n```\n\n它含有 bug 因为 `[]` 代表着“不再重新执行这个 effect 。”但是这个 effect 中的 `handleChange` 是被定义在外面的。`handleChange` 也许会引用任何的 props 或 state ：\n\n```jsx\n  function handleChange() {\n    console.log(count);\n  }\n```\n\n如果我们不再让这个 effect 重新调用，`handleChange` 始终会是第一次渲染时的版本，而其中的 `count` 也永远只会是 `0` 。\n\n为了解决这个问题，请保证你声明了特定的依赖数组，它包含**所有**可以改变的东西，即使是函数也不例外：\n\n```jsx\n  useEffect(() => {\n    DataSource.addSubscription(handleChange);\n    return () => DataSource.removeSubscription(handleChange);\n  }, [handleChange]);\n```\n\n取决于你的代码，在每次渲染后 `handleChange` 都会不同因此你可能仍然会看到不必要的重订阅。 [`useCallback`](https://reactjs.org/docs/hooks-reference.html#usecallback) 能够帮你解决这个问题。或者，你可以直接让它重订阅。例如浏览器中的 `addEventListener` API 非常快，但为了在组件中避免使用它可能会带来更多的问题而不是其真正的价值。\n\n*(你能在 [React 文档](https://reactjs.org/docs/hooks-effect.html) 中学到更多关于 `useEffect` 和其他 Hooks 的知识。)*\n\n## [](#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%92%A9%E5%AD%90)自定义钩子\n\n由于 `useState` 和 `useEffect` 是函数调用，因此我们可以将其组合成自己的 Hooks ：\n\n```jsx\nfunction MyResponsiveComponent() {\n  const width = useWindowWidth(); // 我们自己的 Hook  return (\n    <p>Window width is {width}</p>\n  );\n}\n\nfunction useWindowWidth() {  const [width, setWidth] = useState(window.innerWidth);\n  useEffect(() => {\n    const handleResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  });\n  return width;\n}\n```\n\n自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。\n\n*(你能在 [React 文档](https://reactjs.org/docs/hooks-custom.html) 中学习更多关于构建自己的 Hooks 的内容。)*\n\n## [](#%E9%9D%99%E6%80%81%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F)静态使用顺序\n\n你可以把 `useState` 想象成一个可以定义“React 状态变量”的语法。它并不是真正的语法，当然，我们仍在用 JavaScript 编写应用。但是我们将 React 作为一个运行时环境来看待，因为 React 用 JavaScript 来描绘整个 UI 树，它的特性往往更接近于语言层面。\n\n假设 `use` 是语法，将其使用在组件函数顶层也就说得通了：\n\n```jsx\n// 😉 注意：并不是真的语法\ncomponent Example(props) {\n  const [count, setCount] = use State(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n当它被放在条件语句中或者组件外时又代表什么呢？\n\n```jsx\n// 😉 注意：并不是真的语法\n\n// 它是谁的...局部状态？\nconst [count, setCount] = use State(0);\n\ncomponent Example() {\n  if (condition) {\n    // 要是 condition 是 false 时会发生什么呢？\n    const [count, setCount] = use State(0);\n  }\n\n  function handleClick() {\n    // 要是离开了组件函数会发生什么？\n    // 这和一般的变量又有什么区别呢？\n    const [count, setCount] = use State(0);\n  }\n```\n\nReact 状态和在树中与其相关的组件紧密联系在一起。如果 `use` 是真正的语法当它在组件函数的顶层调用时也能说的通：\n\n```jsx\n// 😉 注意：并不是真的语法\ncomponent Example(props) {\n  // 只在这里有效\n  const [count, setCount] = use State(0);\n\n  if (condition) {\n    // 这会是一个语法错误\n    const [count, setCount] = use State(0);\n  }\n```\n\n这和 `import` 声明只在模块顶层有用是一样的道理。\n\n**当然，`use` 并不是真正的语法。** （它不会带来很多好处，并且会带来很多摩擦。）\n\n然而，React 的确期望所有的 Hooks 调用只发生在组件的顶部并且不在条件语句中。这些 Hooks 的[规则](https://reactjs.org/docs/hooks-rules.html)能够被 [linter plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) 所规范。有很多关于这种设计选择的激烈争论，但在实践中我并没有看到它让人困惑。我还写了关于为什么通常提出的替代方案[不起作用](https://overreacted.io/why-do-hooks-rely-on-call-order/)的文章。\n\nHooks 的内部实现其实是[链表](https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph) 。当你调用 `useState` 的时候，我们将指针移到下一项。当我们退出组件的[“调用树”帧](#%E8%B0%83%E7%94%A8%E6%A0%91)时，会缓存该结果的列表直到下次渲染开始。\n\n[这篇文章](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)简要介绍了 Hooks 内部是如何工作的。数组也许是比链表更好解释其原理的模型：\n\n```jsx\n// 伪代码\nlet hooks, i;\nfunction useState() {\n  i++;\n  if (hooks[i]) {\n    // 再次渲染时\n    return hooks[i];\n  }\n  // 第一次渲染\n  hooks.push(...);\n}\n\n// 准备渲染\ni = -1;\nhooks = fiber.hooks || [];\n// 调用组件\nYourComponent();\n// 缓存 Hooks 的状态\nfiber.hooks = hooks;\n```\n\n*(如果你对它感兴趣，真正的代码在[这里](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js) 。)*\n\n这大致就是每个 `useState()` 如何获得正确状态的方式。就像我们[之前](#%E5%8D%8F%E8%B0%83)所知道的，“匹配”对 React 来说并不是什么新的知识 — 这与协调依赖于在渲染前后元素是否匹配是同样的道理。\n\n## [](#%E6%9C%AA%E6%8F%90%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86)未提及的知识\n\n我们已经触及到 React 运行时环境中几乎所有重要的方面。如果你读完了本篇文章，你可能已经比 90% 的开发者更了解 React ！这一点也没有错！\n\n当然有一些地方我并没有提及到 — 主要是因为我们对它们也不太清楚。React 目前对多道渲染并没有太好的支持，即当父组件的渲染需要子组件提供信息时。[错误处理 API](https://reactjs.org/docs/error-boundaries.html) 目前也还没有 Hooks 的版本。这两个问题可能会被一起解决。并发模式在目前看来并不稳定，也有很多关于 Suspense 该如何适应当前版本的有趣问题。也许我会在它们要完成的时候再来讨论，并且 Suspense 已经准备好比 [lazy loading](https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense) 能够做的更多。\n\n**我认为 React API 的成功之处在于，即使在没有考虑过上面这些大多数主题的情况下，你也能轻松使用它并且可以走的很远。** 在大多数情况下，像协调这样好的默认特性启发式地为我们做了正确的事情。在你忘记添加 `key` 这样的属性时，React 能够好心提醒你。"
    },
    {
      "id": "React：事件机制原理",
      "metadata": {
        "permalink": "/React：事件机制原理",
        "source": "@site/blog/React：事件机制原理.md",
        "title": "React：事件机制原理",
        "description": "请输入描述",
        "date": "2023-08-28T07:56:32.005Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 8.055,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "React：事件机制原理",
          "title": "React：事件机制原理",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "将React作为UI运行时",
          "permalink": "/将React作为UI运行时"
        },
        "nextItem": {
          "title": "useEffect完整指南",
          "permalink": "/useEffect完整指南"
        }
      },
      "content": "## 1.序言\n\nReact 有一套自己的事件系统，其事件叫做合成事件。为什么 React 要自定义一套事件系统？React 事件是如何注册和触发的？React 事件与原生 DOM 事件有什么区别？带着这些问题，让我们一起来探究 React 事件机制的原理。为了便于理解，此篇分析将尽可能用图解代替贴 React 源代码进行解析。\n\n\n## 2.DOM事件流\n\n首先，在正式讲解 React 事件之前，有必要了解一下 DOM 事件流，其包含三个流程：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n\nW3C协会早在1988年就开始了DOM标准的制定，W3C DOM标准可以分为 DOM1、DOM2、DOM3 三个版本。\n\n从 DOM2 开始，DOM 的事件传播分三个阶段进行：事件捕获阶段、处于目标阶段和事件冒泡阶段。\n\n\n（1）事件捕获阶段、处于目标阶段和事件冒泡阶段\n\n如果点击 p元素，那么 DOM 事件流如下图：\n\n（1）事件捕获阶段：事件对象通过目标节点的祖先 Window 传播到目标的父节点。\n\n（2）处于目标阶段：事件对象到达事件目标节点。如果阻止事件冒泡，那么该事件对象将在此阶段完成后停止传播。\n\n（3）事件冒泡阶段：事件对象以相反的顺序从目标节点的父项开始传播，从目标节点的父项开始到 Window 结束。\n\n\n（2）addEventListener 方法\n\nDOM 的事件流中同时包含了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。\n\n\naddEventListener() 方法用于为特定元素绑定一个事件处理函数。addEventListener 有三个参数：\n\nelement.addEventListener(event, function, useCapture)\n\n\n\n另外，如果一个元素（element）针对同一个事件类型（event），多次绑定同一个事件处理函数（function），那么重复的实例会被抛弃。当然如果第三个参数capture值不一致，此时就算重复定义，也不会被抛弃掉。\n\n\n## 3.React 事件概述\n\nReact 根据W3C 规范来定义自己的事件系统，其事件被称之为合成事件 (SyntheticEvent)。而其自定义事件系统的动机主要包含以下几个方面：\n\n（1）抹平不同浏览器之间的兼容性差异。最主要的动机。\n\n（2）事件\"合成\"，即事件自定义。事件合成既可以处理兼容性问题，也可以用来自定义事件（例如 React 的 onChange 事件）。\n\n（3）提供一个抽象跨平台事件机制。类似 VirtualDOM 抽象了跨平台的渲染方式，合成事件（SyntheticEvent）提供一个抽象的跨平台事件机制。\n\n（4）可以做更多优化。例如利用事件委托机制，几乎所有事件的触发都代理到了 document，而不是 DOM 节点本身，简化了 DOM 事件处理逻辑，减少了内存开销。（React 自身模拟了一套事件冒泡的机制）\n\n（5）可以干预事件的分发。V16引入 Fiber 架构，React 可以通过干预事件的分发以优化用户的交互体验。\n\n\n注：「几乎」所有事件都代理到了 document，说明有例外，比如audio、video标签的一些媒体事件（如 onplay、onpause 等），是 document 所不具有，这些事件只能够在这些标签上进行事件进行代理，但依旧用统一的入口分发函数（dispatchEvent）进行绑定。\n\n\n## 4.事件注册\n\nReact 的事件注册过程主要做了两件事：document 上注册、存储事件回调。\n\n（1）document 上注册\n\n在 React 组件挂载阶段，根据组件内的声明的事件类型（onclick、onchange 等），在 document 上注册事件（使用addEventListener），并指定统一的回调函数 dispatchEvent。换句话说，document 上不管注册的是什么事件，都具有统一的回调函数 dispatchEvent。也正是因为这一事件委托机制，具有同样的回调函数 dispatchEvent，所以对于同一种事件类型，不论在 document 上注册了几次，最终也只会保留一个有效实例，这能减少内存开销。\n\n\n由于 React 的事件委托机制，会指定统一的回调函数 dispatchEvent，所以最终只会在 document 上保留一个 click 事件，类似document.addEventListener('click', dispatchEvent)，从这里也可以看出 React 的事件是在 DOM 事件流的冒泡阶段被触发执行。\n\n\n（2）存储事件回调\n\nReact 为了在触发事件时可以查找到对应的回调去执行，会把组件内的所有事件统一地存放到一个对象中（listenerBank）。而存储方式如上图，首先会根据事件类型分类存储，例如 click 事件相关的统一存储在一个对象中，回调函数的存储采用键值对（key/value）的方式存储在对象中，key 是组件的唯一标识 id，value 对应的就是事件的回调函数。\n\n## 5.事件分发\n\n事件分发也就是事件触发。React 的事件触发只会发生在 DOM 事件流的冒泡阶段，因为在 document 上注册时就默认是在冒泡阶段被触发执行。\n其大致流程如下：\n触发事件，开始 DOM 事件流，先后经过三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段\n当事件冒泡到 document 时，触发统一的事件分发函数 ReactEventListener.dispatchEvent\n根据原生事件对象（nativeEvent）找到当前节点（即事件触发节点）对应的 ReactDOMComponent 对象\n事件的合成\n根据当前事件类型生成对应的合成对象\n封装原生事件对象和冒泡机制\n查找当前元素以及它所有父级\n在 listenerBank 中查找事件回调函数并合成到 events 中\n批量执行合成事件（events）内的回调函数\n如果没有阻止冒泡，会将继续进行 DOM 事件流的冒泡（从 document 到 window），否则结束事件触发\n\n\n注：上图中阻止冒泡是指调用stopImmediatePropagation 方法阻止冒泡，如果是调用stopPropagation阻止冒泡，document 上如果还注册了同类型其他的事件，也将会被触发执行，但会正常阻断 window 上事件触发。了解两者之间的详细区别"
    },
    {
      "id": "useEffect完整指南",
      "metadata": {
        "permalink": "/useEffect完整指南",
        "source": "@site/blog/useEffect完整指南.md",
        "title": "useEffect完整指南",
        "description": "请输入描述",
        "date": "2023-08-28T07:55:50.967Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 76.49,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "useEffect完整指南",
          "title": "useEffect完整指南",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "React：事件机制原理",
          "permalink": "/React：事件机制原理"
        },
        "nextItem": {
          "title": "这可能是最通俗的ReactFiber",
          "permalink": "/这可能是最通俗的ReactFiber"
        }
      },
      "content": "你用[Hooks](https://reactjs.org/docs/hooks-intro.html)写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的API很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些 [custom Hooks](https://reactjs.org/docs/hooks-custom.html)去抽离重复的逻辑（精简掉了300行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。\n\n但有时候当你使用`useEffect`你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像class的生命周期…但真的是这样吗？你发觉自己在问类似下面的这些问题：\n\n+   🤔 如何用`useEffect`模拟`componentDidMount`生命周期？\n+   🤔 如何正确地在`useEffect`里请求数据？`[]`又是什么？\n+   🤔 我应该把函数当做effect的依赖吗？\n+   🤔 为什么有时候会出现无限重复请求的问题？\n+   🤔 为什么有时候在effect里拿到的是旧的state或prop？\n\n当我刚开始使用Hooks的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些“啊哈”的开窍时刻，我想把这些分享给你。**这篇文章会深入讲解帮你明白上面问题的答案。**\n\n在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会`useEffect`。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。\n\n**当我不再透过熟悉的class生命周期方法去窥视`useEffect` 这个Hook的时候，我才得以融会贯通。**\n\n> “忘记你已经学到的。” — Yoda\n\n[![Yoda sniffing the air. Caption: “I smell bacon.”](https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/fce5f/yoda.jpg)](https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/fce5f/yoda.jpg)\n\n* * *\n\n**这篇文章会假设你对[`useEffect`](https://reactjs.org/docs/hooks-effect.html) API有一定程度的了解。**\n\n**这篇文章真的很长。它更像一本mini书，这也是我更喜欢的形式。如果你很匆忙或者并不是太关心本文主题的话，你也可以直接看下面的摘要。**\n\n**如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像2013年React刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。**\n\n* * *\n\n## [](#%E6%91%98%E8%A6%81)摘要\n\n如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。\n\n如果你打算阅读整篇文章，你完全可以跳过这部分。我会在文章末尾带上摘要的链接。\n\n**🤔 Question: 如何用`useEffect`模拟`componentDidMount`生命周期？**\n\n虽然可以使用`useEffect(fn, [])`，但它们并不完全相等。和`componentDidMount`不一样，`useEffect`会*捕获* props和state。所以即便在回调函数里，你拿到的还是初始的props和state。如果你想得到“最新”的值，你可以使用ref。不过，通常会有更简单的实现方式，所以你并不一定要用ref。记住，effects的心智模型和`componentDidMount`以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要“think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。\n\n**🤔 Question: 如何正确地在`useEffect`里请求数据？`[]`又是什么？**\n\n[这篇文章](https://www.robinwieruch.de/react-hooks-fetch-data/) 是很好的入门，介绍了如何在`useEffect`里做数据请求。请务必读完它！它没有我的这篇这么长。`[]`表示effect没有使用任何React数据流里的值，因此该effect仅被调用一次是安全的。`[]`同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是`useReducer` 和 `useCallback`）来移除这些effect依赖，而不是错误地忽略它们。\n\n**🤔 Question: 我应该把函数当做effect的依赖吗？**\n\n一般建议把不依赖props和state的函数提到你的组件外面，并且把那些仅被effect使用的函数放到effect里面。如果这样做了以后，你的effect还是需要用到组件内的函数（包括通过props传进来的函数），可以在定义它们的地方用`useCallback`包一层。为什么要这样做呢？因为这些函数可以访问到props和state，因此它们会参与到数据流中。我们官网的FAQ有[更详细的答案](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)。\n\n**🤔 Question: 为什么有时候会出现无限重复请求的问题？**\n\n这个通常发生于你在effect里做数据请求并且没有设置effect依赖参数的情况。没有设置依赖，effect会在每次渲染后执行一次，然后在effect中更新了状态引起渲染并再次触发effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用`[]`）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到effect里，或者提到组件外面，或者用`useCallback`包一层。`useMemo` 可以做类似的事情以避免重复生成对象。\n\n**🤔 为什么有时候在effect里拿到的是旧的state或prop呢？**\n\nEffect拿到的总是定义它的那次渲染中的props和state。这能够[避免一些bugs](https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/)，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的ref保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的props和state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个[lint 规则](https://github.com/facebook/react/issues/14920)来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网FAQ中的[这个回答。](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function)\n\n* * *\n\n我希望这个摘要对你有所帮助！要不，我们开始正文。\n\n* * *\n\n## [](#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84-props-and-state)每一次渲染都有它自己的 Props and State\n\n在我们讨论effects之前，我们需要先讨论一下渲染（rendering）。\n\n我们来看一个计数器组件Counter，注意高亮的那一行：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n高亮的代码究竟是什么意思呢？`count` 会“监听”状态的变化并自动更新吗？这么想可能是学习React的时候有用的第一直觉，但它并不是[精确的心智模型](https://overreacted.io/react-as-a-ui-runtime/)。\n\n**上面例子中，`count`仅是一个数字而已。**它不是神奇的“data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：\n\n```jsx\nconst count = 42;\n// ...\n<p>You clicked {count} times</p>\n// ...\n```\n\n我们的组件第一次渲染的时候，从`useState()`拿到`count`的初始值`0`。当我们调用`setCount(1)`，React会再次渲染组件，这一次`count`是`1`。如此等等：\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()  // ...\n  <p>You clicked {count} times</p>\n  // ...\n}\n```\n\n**当我们更新状态的时候，React会重新渲染组件。每一次渲染都能拿到独立的`count` 状态，这个状态值是函数中的一个常量。**\n\n所以下面的这行代码没有做任何特殊的数据绑定：\n\n```jsx\n<p>You clicked {count} times</p>\n```\n\n**它仅仅只是在渲染输出中插入了count这个数字。**这个数字由React提供。当`setCount`的时候，React会带着一个不同的`count`值再次调用组件。然后，React会更新DOM以保持和渲染输出一致。\n\n这里关键的点在于任意一次渲染中的`count`常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的`count`值独立于其他渲染。\n\n*（关于这个过程更深入的探讨可以查看我的另一篇文章 [React as a UI Runtime](https://overreacted.io/react-as-a-ui-runtime/)。）*\n\n## [](#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0)每一次渲染都有它自己的事件处理函数\n\n到目前为止一切都还好。那么事件处理函数呢？\n\n看下面的这个例子。它在三秒后会alert点击次数`count`：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleAlertClick() {    setTimeout(() => {      alert('You clicked on: ' + count);    }, 3000);  }\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <button onClick={handleAlertClick}>        Show alert      </button>    </div>\n  );\n}\n```\n\n如果我按照下面的步骤去操作：\n\n+   **点击增加**counter到3\n+   **点击一下** “Show alert”\n+   **点击增加** counter到5并且在定时器回调触发前完成\n\n![Counter demo](https://overreacted.io/46c55d5f1f749462b7a173f1e748e41e/counter.gif)\n\n你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。\n\n* * *\n\n*剧透预警*\n\n* * *\n\n来自己 [试试吧！](https://codesandbox.io/s/w2wxl3yo0l)\n\n如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在state中保存了当前接收者的ID，以及一个发送按钮。 [这篇文章](https://overreacted.io/how-are-function-components-different-from-classes)深入探索了个中缘由。正确的答案就是3。\n\nalert会“捕获”我点击按钮时候的状态。\n\n*（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出“最小阻力路径”是非常重要的。）*\n\n* * *\n\n但它究竟是如何工作的呢？\n\n我们发现`count`在每一次函数调用中都是一个常量值。值得强调的是 — **我们的组件函数每次渲染都会被调用，但是每一次调用中`count`值都是常量，并且它被赋予了当前渲染中的状态值。**\n\n这并不是React特有的，普通的函数也有类似的行为：\n\n```jsx\nfunction sayHi(person) {\n  const name = person.name;  setTimeout(() => {\n    alert('Hello, ' + name);\n  }, 3000);\n}\n\nlet someone = {name: 'Dan'};\nsayHi(someone);\n\nsomeone = {name: 'Yuzhi'};\nsayHi(someone);\n\nsomeone = {name: 'Dominic'};\nsayHi(someone);\n```\n\n在 [这个例子](https://codesandbox.io/s/mm6ww11lk8)中, 外层的`someone`会被赋值很多次（就像在React中，*当前*的组件状态会改变一样）。**然后，在`sayHi`函数中，局部常量`name`会和某次调用中的`person`关联。**因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的`name`。\n\n这就解释了我们的事件处理函数如何捕获了点击时候的`count`值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的`count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  const count = 0; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  const count = 1; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  const count = 2; // Returned by useState()  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n```\n\n所以实际上，每一次渲染都有一个“新版本”的`handleAlertClick`。每一个版本的`handleAlertClick`“记住” 了它自己的 `count`：\n\n```jsx\n// During first render\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 0);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 0 inside  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 1);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 1 inside  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      alert('You clicked on: ' + 2);    }, 3000);\n  }\n  // ...\n  <button onClick={handleAlertClick} /> // The one with 2 inside  // ...\n}\n```\n\n这就是为什么[在这个demo中](https://codesandbox.io/s/w2wxl3yo0l)中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中`counter`的状态值。\n\n**在任意一次渲染中，props和state是始终保持不变的。**如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的`count`值。\n\n*备注：上面我将具体的`count`值直接内联到了`handleAlertClick`函数中。这种心智上的替换是安全的因为`count` 值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改state这个前提下。通过调用`setSomething(newObj)`的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的state不会被污染。*\n\n## [](#%E6%AF%8F%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84effects)每次渲染都有它自己的Effects\n\n这篇文章是关于effects的，但目前我们居然还没有讨论effects！ 言归正传，由上面的分析得出一个结果，effects其实并没有什么两样。\n\n让我们回到[官网文档](https://reactjs.org/docs/hooks-effect.html)中的这个例子：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {    document.title = `You clicked ${count} times`;  });\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n**抛一个问题给你：effect是如何读取到最新的`count` 状态值的呢？**\n\n也许，是某种“data binding”或“watching”机制使得`count`能够在effect函数内更新？也或许`count`是一个可变的值，React会在我们组件内部修改它以使我们的effect函数总能拿到最新的值？\n\n都不是。\n\n我们已经知道`count`是某个特定渲染中的常量。事件处理函数“看到”的是属于它那次特定渲染中的`count`状态值。对于effects也同样如此：\n\n**并不是`count`的值在“不变”的effect中发生了改变，而是*effect 函数本身*在每一次渲染中都不相同。**\n\n每一个effect版本“看到”的`count`值都来自于它属于的那次渲染：\n\n```jsx\n// During first render\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect function from first render    () => {      document.title = `You clicked ${0} times`;    }  );\n  // ...\n}\n\n// After a click, our function is called again\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect function from second render    () => {      document.title = `You clicked ${1} times`;    }  );\n  // ...\n}\n\n// After another click, our function is called again\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect function from third render    () => {      document.title = `You clicked ${2} times`;    }  );\n  // ..\n}\n```\n\nReact会记住你提供的effect函数，并且会在每次更改作用于DOM并让浏览器绘制屏幕后去调用它。\n\n所以虽然我们说的是一个 *effect*（这里指更新document的title），但其实每次渲染都是一个*不同的函数* — 并且每个effect函数“看到”的props和state都来自于它属于的那次特定渲染。\n\n**概念上，你可以想象effects是渲染结果的一部分。**\n\n严格地说，它们并不是（为了[允许Hook的组合](https://overreacted.io/why-do-hooks-rely-on-call-order/)并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect函数*属于*某个特定的渲染，就像事件处理函数一样。\n\n* * *\n\n为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：\n\n+   **React:** 给我状态为 `0`时候的UI。\n+   **你的组件:**\n    \n    +   给你需要渲染的内容: `<p>You clicked 0 times</p>`。\n    +   记得在渲染完了之后调用这个effect: `() => { document.title = 'You clicked 0 times' }`。\n+   **React:** 没问题。开始更新UI，喂浏览器，我要给DOM添加一些东西。\n+   **浏览器:** 酷，我已经把它绘制到屏幕上了。\n+   **React:** 好的， 我现在开始运行给我的effect\n    \n    +   运行 `() => { document.title = 'You clicked 0 times' }`。\n\n* * *\n\n现在我们回顾一下我们点击之后发生了什么：\n\n+   **你的组件:** 喂 React, 把我的状态设置为`1`。\n+   **React:** 给我状态为 `1`时候的UI。\n+   **你的组件:**\n    \n    +   给你需要渲染的内容: `<p>You clicked 1 times</p>`。\n    +   记得在渲染完了之后调用这个effect： `() => { document.title = 'You clicked 1 times' }`。\n+   **React:** 没问题。开始更新UI，喂浏览器，我修改了DOM。\n+   **Browser:** 酷，我已经将更改绘制到屏幕上了。\n+   **React:** 好的， 我现在开始运行属于这次渲染的effect\n    \n    +   运行 `() => { document.title = 'You clicked 1 times' }`。\n\n* * *\n\n## [](#%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E9%83%BD%E6%9C%89%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%89%80%E6%9C%89)每一次渲染都有它自己的…所有\n\n**我们现在知道effects会在每次渲染后运行，并且概念上它是组件输出的一部分，可以“看到”属于某次特定渲染的props和state。**\n\n我们来做一个思想实验，思考下面的代码：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {    setTimeout(() => {      console.log(`You clicked ${count} times`);    }, 3000);  });\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n如果我点击了很多次并且在effect里设置了延时，打印出来的结果会是什么呢？\n\n* * *\n\n*剧透预警*\n\n* * *\n\n你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的`count`值。你可以[自己试一试](https://codesandbox.io/s/lyx20m1ol)：\n\n![1, 2, 3, 4, 5 顺序打印](https://overreacted.io/a5727d333c270e05942f508707265378/timeout_counter.gif)\n\n你可能会想：“它当然应该是这样的。否则还会怎么样呢？”\n\n不过，class中的`this.state`并不是这样运作的。你可能会想当然以为下面的[class 实现](https://codesandbox.io/s/kkymzwjqz3)和上面是相等的：\n\n```jsx\n  componentDidUpdate() {\n    setTimeout(() => {\n      console.log(`You clicked ${this.state.count} times`);\n    }, 3000);\n  }\n```\n\n然而，`this.state.count`总是指向*最新*的count值，而不是属于某次特定渲染的值。所以你会看到每次打印输出都是`5`：\n\n![5, 5, 5, 5, 5 打印输出](https://overreacted.io/264b329edc111a1973003bdf2bcacd65/timeout_counter_class.gif)\n\n我觉得Hooks这么依赖Javascript闭包是挺讽刺的一件事。有时候组件的class实现方式会受闭包相关的苦（[the canonical wrong-value-in-a-timeout confusion](https://wsvincent.com/javascript-closure-settimeout-for-loop/)），但其实这个例子中真正的混乱来源是可变数据（React 修改了class中的`this.state`使其指向最新状态），并不是闭包本身的错。\n\n**当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量。**正如我们所讨论的，props和state在某个特定渲染中是不会改变的。顺便说一下，我们可以[使用闭包](https://codesandbox.io/s/w7vjo07055)修复上面的class版本…\n\n## [](#%E9%80%86%E6%BD%AE%E8%80%8C%E5%8A%A8)逆潮而动\n\n到目前为止，我们可以明确地喊出下面重要的事实：**每一个**组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。\n\n所以下面的两个例子是相等的：\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);    }, 1000);\n  });\n  // ...\n}\n```\n\n```jsx\nfunction Example(props) {\n  const counter = props.counter;  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);    }, 1000);\n  });\n  // ...\n}\n```\n\n**在组件内什么时候去读取props或者state是无关紧要的。**因为它们不会改变。在单次渲染的范围内，props和state始终保持不变。（解构赋值的props使得这一点更明显。）\n\n当然，有时候你可能*想*在effect的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用refs，[这篇文章](https://overreacted.io/how-are-function-components-different-from-classes/)的最后一部分介绍了相关内容。\n\n需要注意的是当你想要从*过去*渲染中的函数里读取*未来*的props和state，你是在逆潮而动。虽然它并没有*错*（有时候可能也需要这样做），但它因为打破了默认范式会使代码显得不够“干净”。这是我们有意为之的，因为它能帮助突出哪些代码是脆弱的，是需要依赖时间次序的。在class中，如果发生这种情况就没那么显而易见了。\n\n下面这个[计数器版本](https://codesandbox.io/s/rm7z22qnlp) 模拟了class中的行为：\n\n```jsx\nfunction Example() {\n  const [count, setCount] = useState(0);\n  const latestCount = useRef(count);\n  useEffect(() => {\n    // Set the mutable latest value    latestCount.current = count;    setTimeout(() => {\n      // Read the mutable latest value      console.log(`You clicked ${latestCount.current} times`);    }, 3000);\n  });\n  // ...\n```\n\n![5, 5, 5, 5, 5 打印输出](https://overreacted.io/78f7948263dd13b023498b23cb99f4fc/timeout_counter_refs.gif)\n\n在React中去直接修改值看上去有点怪异。然而，在class组件中React正是这样去修改`this.state`的。不像捕获的props和state，你没法保证在任意一个回调函数中读取的`latestCount.current`是不变的。根据定义，你可以随时修改它。这就是为什么它不是默认行为，而是需要你主动选择这样做。\n\n## [](#%E9%82%A3effect%E4%B8%AD%E7%9A%84%E6%B8%85%E7%90%86%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F)那Effect中的清理又是怎样的呢？\n\n像 [文档中解释的](https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup), 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用（effect)，比如取消订阅。\n\n思考下面的代码:\n\n```jsx\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);\n    };\n  });\n```\n\n假设第一次渲染的时候`props`是`{id: 10}`，第二次渲染的时候是`{id: 20}`。你*可能*会认为发生了下面的这些事：\n\n+   React 清除了 `{id: 10}`的effect。\n+   React 渲染`{id: 20}`的UI。\n+   React 运行`{id: 20}`的effect。\n\n(事实并不是这样。)\n\n如果依赖这种心智模型，你可能会认为清除过程“看到”的是旧的props因为它是在重新渲染之前运行的，新的effect“看到”的是新的props因为它是在重新渲染之后运行的。这种心智模型直接来源于class组件的生命周期。不过**它并不精确**。让我们来一探究竟。\n\nReact只会在[浏览器绘制](https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f)后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。Effect的清除同样被延迟了。**上一次的effect会在重新渲染后被清除：**\n\n+   **React 渲染`{id: 20}`的UI。**\n+   浏览器绘制。我们在屏幕上看到`{id: 20}`的UI。\n+   **React 清除`{id: 10}`的effect。**\n+   React 运行`{id: 20}`的effect。\n\n你可能会好奇：如果清除上一次的effect发生在props变成`{id: 20}`之后，那它为什么还能“看到”旧的`{id: 10}`？\n\n你曾经来过这里… 🤔\n\n![Deja vu (cat scene from the Matrix movie)](https://overreacted.io/5fe238cf03a21dfa32af624124fcdcff/deja_vu.gif)\n\n引用上半部分得到的结论:\n\n> 组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获定义它们的那次渲染中的props和state。\n\n现在答案显而易见。effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值：\n\n```jsx\n// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(\n    // Effect from first render\n    () => {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n      // Cleanup for effect from first render      return () => {        ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);      };    }\n  );\n  // ...\n}\n\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(\n    // Effect from second render\n    () => {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n      // Cleanup for effect from second render\n      return () => {\n        ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);\n      };\n    }\n  );\n  // ...\n}\n```\n\n王国会崛起转而复归尘土，太阳会脱落外层变为白矮星，最后的文明也迟早会结束。但是第一次渲染中effect的清除函数只能看到`{id: 10}`这个props。\n\n这正是为什么React能做到在绘制后立即处理effects — 并且默认情况下使你的应用运行更流畅。如果你的代码需要依然可以访问到老的props。\n\n## [](#%E5%90%8C%E6%AD%A5%EF%BC%8C-%E8%80%8C%E9%9D%9E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)同步， 而非生命周期\n\n我最喜欢React的一点是它统一描述了初始渲染和之后的更新。这降低了你程序的[熵](https://overreacted.io/the-bug-o-notation/)。\n\n比如我有个组件像下面这样：\n\n```jsx\nfunction Greeting({ name }) {\n  return (\n    <h1 className=\"Greeting\">\n      Hello, {name}\n    </h1>\n  );\n}\n```\n\n我先渲染`<Greeting name=\"Dan\" />`然后渲染`<Greeting name=\"Yuzhi\" />`，和我直接渲染`<Greeting name=\"Yuzhi\" />`并没有什么区别。在这两种情况中，我最后看到的都是“Hello, Yuzhi”。\n\n人们总是说：“重要的是旅行过程，而不是目的地”。在React世界中，恰好相反。**重要的是目的，而不是过程。**这就是JQuery代码中 `$.addClass` 或 `$.removeClass`这样的调用（过程）和React代码中声明CSS类名*应该是什么*（目的）之间的区别。\n\n**React会根据我们当前的props和state同步到DOM。**“mount”和“update”之于渲染并没有什么区别。\n\n你应该以相同的方式去思考effects。**`useEffect`使你能够根据props和state*同步*React tree之外的东西。**\n\n```jsx\nfunction Greeting({ name }) {\n  useEffect(() => {    document.title = 'Hello, ' + name;  });  return (\n    <h1 className=\"Greeting\">\n      Hello, {name}\n    </h1>\n  );\n}\n```\n\n这就是和大家熟知的*mount/update/unmount*心智模型之间细微的区别。理解和内化这种区别是非常重要的。**如果你试图写一个effect会根据是否第一次渲染而表现不一致，你正在逆潮而动。**如果我们的结果依赖于过程而不是目的，我们会在同步中犯错。\n\n先渲染属性A，B再渲染C，和立即渲染C并没有什么区别。虽然他们可能短暂地会有点不同（比如请求数据时），但最终的结果是一样的。\n\n不过话说回来，在*每一次*渲染后都去运行所有的effects可能并不高效。（并且在某些场景下，它可能会导致无限循环。）\n\n所以我们该怎么解决这个问题？\n\n## [](#%E5%91%8A%E8%AF%89react%E5%8E%BB%E6%AF%94%E5%AF%B9%E4%BD%A0%E7%9A%84effects)告诉React去比对你的Effects\n\n其实我们已经从React处理DOM的方式中学习到了解决办法。React只会更新DOM真正发生改变的部分，而不是每次渲染都大动干戈。\n\n当你把\n\n```jsx\n<h1 className=\"Greeting\">\n  Hello, Dan\n</h1>\n```\n\n更新到\n\n```jsx\n<h1 className=\"Greeting\">\n  Hello, Yuzhi\n</h1>\n```\n\nReact 能够看到两个对象:\n\n```jsx\nconst oldProps = {className: 'Greeting', children: 'Hello, Dan'};\nconst newProps = {className: 'Greeting', children: 'Hello, Yuzhi'};\n```\n\n它会检测每一个props，并且发现`children`发生改变需要更新DOM，但`className`并没有。所以它只需要这样做：\n\n```jsx\ndomNode.innerText = 'Hello, Yuzhi';\n// No need to touch domNode.className\n```\n\n**我们也可以用类似的方式处理effects吗？如果能够在不需要的时候避免调用effect就太好了。**\n\n举个例子，我们的组件可能因为状态变更而重新渲染：\n\n```jsx\nfunction Greeting({ name }) {\n  const [counter, setCounter] = useState(0);\n\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  });\n\n  return (\n    <h1 className=\"Greeting\">\n      Hello, {name}\n      <button onClick={() => setCounter(counter + 1)}>        Increment      </button>    </h1>\n  );\n}\n```\n\n但是我们的effect并没有使用`counter`这个状态。**我们的effect只会同步`name`属性给`document.title`，但`name`并没有变。**在每一次counter改变后重新给`document.title`赋值并不是理想的做法。\n\n好了，那React可以…区分effects的不同吗？\n\n```jsx\nlet oldEffect = () => { document.title = 'Hello, Dan'; };\nlet newEffect = () => { document.title = 'Hello, Dan'; };\n// Can React see these functions do the same thing?\n```\n\n并不能。React并不能猜测到函数做了什么如果不先调用的话。（源码中并没有包含特殊的值，它仅仅是引用了`name`属性。）\n\n这是为什么你如果想要避免effects不必要的重复调用，你可以提供给`useEffect`一个依赖数组参数(deps)：\n\n```jsx\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]); // Our deps\n```\n\n**这好比你告诉React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的`name`，别无其他。”**\n\n如果当前渲染中的这些依赖项和上一次运行这个effect的时候值一样，因为没有什么需要同步React会自动跳过这次effect：\n\n```jsx\nconst oldEffect = () => { document.title = 'Hello, Dan'; };\nconst oldDeps = ['Dan'];\n\nconst newEffect = () => { document.title = 'Hello, Dan'; };\nconst newDeps = ['Dan'];\n\n// React can't peek inside of functions, but it can compare deps.\n// Since all deps are the same, it doesn’t need to run the new effect.\n```\n\n即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过effect的运行。要同步所有！\n\n## [](#%E5%85%B3%E4%BA%8E%E4%BE%9D%E8%B5%96%E9%A1%B9%E4%B8%8D%E8%A6%81%E5%AF%B9react%E6%92%92%E8%B0%8E)关于依赖项不要对React撒谎\n\n关于依赖项对React撒谎会有不好的结果。直觉上，这很好理解，但我曾看到几乎所有依赖class心智模型使用`useEffect`的人都试图违反这个规则。（我刚开始也这么干了！）\n\n```jsx\nfunction SearchResults() {\n  async function fetchData() {\n    // ...\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay? Not always -- and there's a better way to write it.\n\n  // ...\n}\n```\n\n*(官网的 [Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies) 解释了应该怎么做。 我们在[下面](#moving-functions-inside-effects)会重新回顾这个例子。)*\n\n“但我只是想在挂载的时候运行它！”，你可能会说。现在只需要记住：如果你设置了依赖项，**effect中用到的所有组件内的值都要包含在依赖中。**这包括props，state，函数 — 组件内的任何东西。\n\n有时候你是这样做了，但可能会引起一个问题。比如，你可能会遇到无限请求的问题，或者socket被频繁创建的问题。**解决问题的方法不是移除依赖项。**我们会很快了解具体的解决方案。\n\n不过在我们深入解决方案之前，我们先尝试更好地理解问题。\n\n## [](#%E5%A6%82%E6%9E%9C%E8%AE%BE%E7%BD%AE%E4%BA%86%E9%94%99%E8%AF%AF%E7%9A%84%E4%BE%9D%E8%B5%96%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%E5%91%A2%EF%BC%9F)如果设置了错误的依赖会怎么样呢？\n\n如果依赖项包含了所有effect中使用到的值，React就能知道何时需要运行它：\n\n```jsx\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, [name]);\n```\n\n![effects更新示例图](https://overreacted.io/fae247cd068eedbd4b62ba50592d2b3d/deps-compare-correct.gif)\n\n*(依赖发生了变更，所以会重新运行effect。)*\n\n但是如果我们将`[]`设为effect的依赖，新的effect函数不会运行：\n\n```jsx\n  useEffect(() => {\n    document.title = 'Hello, ' + name;\n  }, []); // Wrong: name is missing in deps\n```\n\n![effects更新示例图](https://overreacted.io/25f75db3f9f57ffe1426912093577445/deps-compare-wrong.gif)\n\n*(依赖没有变，所以不会再次运行effect。)*\n\n在这个例子中，问题看起来显而易见。但在某些情况下如果你脑子里“跳出”class组件的解决办法，你的直觉很可能会欺骗你。\n\n举个例子，我们来写一个每秒递增的计数器。在Class组件中，我们的直觉是：“开启一次定时器，清除也是一次”。这里有一个[例子](https://codesandbox.io/s/n5mjzjy9kl)说明怎么实现它。当我们理所当然地把它用`useEffect`的方式翻译，直觉上我们会设置依赖为`[]`。“我只想运行一次effect”，对吗？\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n  return <h1>{count}</h1>;\n}\n```\n\n然而，这个例子[只会递增一次](https://codesandbox.io/s/91n5z8jo7r)。*天了噜。*\n\n如果你的心智模型是“只有当我想重新触发effect的时候才需要去设置依赖”，这个例子可能会让你产生存在危机。你想要触发一次因为它是定时器 — 但为什么会有问题？\n\n如果你知道依赖是我们给React的暗示，告诉它effect所有需要使用的渲染中的值，你就不会吃惊了。effect中使用了`count`但我们撒谎说它没有依赖。如果我们这样做迟早会出幺蛾子。\n\n在第一次渲染中，`count`是`0`。因此，`setCount(count + 1)`在第一次渲染中等价于`setCount(0 + 1)`。**既然我们设置了`[]`依赖，effect不会再重新运行，它后面每一秒都会调用`setCount(0 + 1)` ：**\n\n```jsx\n// First render, state is 0\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect from first render\n    () => {\n      const id = setInterval(() => {\n        setCount(0 + 1); // Always setCount(1)      }, 1000);\n      return () => clearInterval(id);\n    },\n    [] // Never re-runs  );\n  // ...\n}\n\n// Every next render, state is 1\nfunction Counter() {\n  // ...\n  useEffect(\n    // This effect is always ignored because    // we lied to React about empty deps.    () => {\n      const id = setInterval(() => {\n        setCount(1 + 1);\n      }, 1000);\n      return () => clearInterval(id);\n    },\n    []\n  );\n  // ...\n}\n```\n\n我们对React撒谎说我们的effect不依赖组件内的任何值，可实际上我们的effect有依赖！\n\n我们的effect依赖`count` - 它是组件内的值（不过在effect外面定义）：\n\n```jsx\n  const count = // ...\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n```\n\n因此，设置`[]`为依赖会引入一个bug。React会对比依赖，并且跳过后面的effect：\n\n![定时器闭包示例图](https://overreacted.io/29e53bd0c9b7d2ac70d3cd924886b030/interval-wrong.gif)\n\n*(依赖没有变，所以不会再次运行effect。)*\n\n类似于这样的问题是很难被想到的。因此，我鼓励你将诚实地告知effect依赖作为一条硬性规则，并且要列出所以依赖。（我们提供了一个[lint规则](https://github.com/facebook/react/issues/14920)如果你想在你的团队内做硬性规定。）\n\n## [](#%E4%B8%A4%E7%A7%8D%E8%AF%9A%E5%AE%9E%E5%91%8A%E7%9F%A5%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95)两种诚实告知依赖的方法\n\n有两种诚实告知依赖的策略。你应该从第一种开始，然后在需要的时候应用第二种。\n\n**第一种策略是在依赖中包含所有effect中用到的组件内的值。**让我们在依赖中包含`count`：\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n\n现在依赖数组正确了。虽然它可能不是*太理想*但确实解决了上面的问题。现在，每次`count`修改都会重新运行effect，并且定时器中的`setCount(count + 1)`会正确引用某次渲染中的 `count`值：\n\n```jsx\n// First render, state is 0\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect from first render\n    () => {\n      const id = setInterval(() => {\n        setCount(0 + 1); // setCount(count + 1)      }, 1000);\n      return () => clearInterval(id);\n    },\n    [0] // [count]  );\n  // ...\n}\n\n// Second render, state is 1\nfunction Counter() {\n  // ...\n  useEffect(\n    // Effect from second render\n    () => {\n      const id = setInterval(() => {\n        setCount(1 + 1); // setCount(count + 1)      }, 1000);\n      return () => clearInterval(id);\n    },\n    [1] // [count]  );\n  // ...\n}\n```\n\n这能[解决问题](https://codesandbox.io/s/0x0mnlyq8l)但是我们的定时器会在每一次`count`改变后清除和重新设定。这应该不是我们想要的结果：\n\n![定时器重复订阅示例图](https://overreacted.io/5734271ddfa94d2d65ac6160515e0069/interval-rightish.gif)\n\n*(依赖发生了变更，所以会重新运行effect。)*\n\n* * *\n\n**第二种策略是修改effect内部的代码以确保它包含的值只会在需要的时候发生变更。**我们不想告知错误的依赖 - 我们只是修改effect使得依赖更少。\n\n让我们来看一些移除依赖的常用技巧。\n\n* * *\n\n## [](#%E8%AE%A9effects%E8%87%AA%E7%BB%99%E8%87%AA%E8%B6%B3)让Effects自给自足\n\n我们想去掉effect的`count`依赖。\n\n```jsx\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);    }, 1000);\n    return () => clearInterval(id);\n  }, [count]);\n```\n\n为了实现这个目的，我们需要问自己一个问题：**我们为什么要用`count`？**可以看到我们只在`setCount`调用中用到了`count`。在这个场景中，我们其实并不需要在effect中使用`count`。当我们想要根据前一个状态更新状态的时候，我们可以使用`setState`的[函数形式](https://reactjs.org/docs/hooks-reference.html#functional-updates)：\n\n```jsx\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + 1);    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n```\n\n我喜欢把类似这种情况称为“错误的依赖”。是的，因为我们在effect中写了`setCount(count + 1)`所以`count`是一个必需的依赖。但是，我们真正想要的是把`count`转换为`count+1`，然后返回给React。可是React其实已经知道当前的`count`。**我们需要告知React的仅仅是去递增状态 - 不管它现在具体是什么值。**\n\n这正是`setCount(c => c + 1)`做的事情。你可以认为它是在给React“发送指令”告知如何更新状态。这种“更新形式”在其他情况下也有帮助，比如你需要[批量更新](https://overreacted.io/react-as-a-ui-runtime/#batching)。\n\n**注意我们做到了移除依赖，并且没有撒谎。我们的effect不再读取渲染中的`count`值。**\n\n![运行良好的定时器示例图](https://overreacted.io/f128ad20c28317ed27a3cb68197fc906/interval-right.gif)\n\n*(依赖没有变，所以不会再次运行effect。)*\n\n你可以自己 [试试](https://codesandbox.io/s/q3181xz1pj)。\n\n尽管effect只运行了一次，第一次渲染中的定时器回调函数可以完美地在每次触发的时候给React发送`c => c + 1`更新指令。它不再需要知道当前的`count`值。因为React已经知道了。\n\n## [](#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%9B%B4%E6%96%B0-%E5%92%8C-google-docs)函数式更新 和 Google Docs\n\n还记得我们说过同步才是理解effects的心智模型吗？同步的一个有趣地方在于你通常想要把同步的“信息”和状态解耦。举个例子，当你在Google Docs编辑文档的时候，Google并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。\n\n虽然我们effect的情况不尽相同，但可以应用类似的思想。**只在effects中传递最小的信息会很有帮助。**类似于`setCount(c => c + 1)`这样的更新形式比`setCount(count + 1)`传递了更少的信息，因为它不再被当前的count值“污染”。它只是表达了一种行为（“递增”）。“Thinking in React”也讨论了[如何找到最小状态](https://reactjs.org/docs/thinking-in-react.html#step-3-identify-the-minimal-but-complete-representation-of-ui-state)。原则是类似的，只不过现在关注的是如何更新。\n\n表达*意图*（而不是结果）和Google Docs[如何处理](https://medium.com/@srijancse/how-real-time-collaborative-editing-work-operational-transformation-ac4902d75682)共同编辑异曲同工。虽然这个类比略微延伸了一点，函数式更新在React中扮演了类似的角色。它们确保能以批量地和可预测的方式来处理各种源头（事件处理函数，effect中的订阅，等等）的状态更新。\n\n**然而，即使是`setCount(c => c + 1)`也并不完美。**它看起来有点怪，并且非常受限于它能做的事。举个例子，如果我们有两个互相依赖的状态，或者我们想基于一个prop来计算下一次的state，它并不能做到。幸运的是， `setCount(c => c + 1)`有一个更强大的姐妹模式，它的名字叫`useReducer`。\n\n## [](#%E8%A7%A3%E8%80%A6%E6%9D%A5%E8%87%AAactions%E7%9A%84%E6%9B%B4%E6%96%B0)解耦来自Actions的更新\n\n我们来修改上面的例子让它包含两个状态：`count` 和 `step`。我们的定时器会每次在count上增加一个`step`值：\n\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(1);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => setStep(Number(e.target.value))} />\n    </>\n  );\n}\n```\n\n(这里是[demo](https://codesandbox.io/s/zxn70rnkx).)\n\n注意**我们没有撒谎**。既然我们在effect里使用了`step`，我们就把它加到依赖里。所以这也是为什么代码能运行正确。\n\n这个例子目前的行为是修改`step`会重启定时器 - 因为它是依赖项之一。在大多数场景下，这正是你所需要的。清除上一次的effect然后重新运行新的effect并没有任何错。除非我们有很好的理由，我们不应该改变这个默认行为。\n\n不过，假如我们不想在`step`改变后重启定时器，我们该如何从effect中移除对`step`的依赖呢？\n\n**当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用`useReducer`去替换它们。**\n\n当你写类似`setSomething(something => ...)`这种代码的时候，也许就是考虑使用reducer的契机。reducer可以让你**把组件内发生了什么(actions)和状态如何响应并更新分开表述。**\n\n我们用一个`dispatch`依赖去替换effect的`step`依赖：\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);const { count, step } = state;\n\nuseEffect(() => {\n  const id = setInterval(() => {\n    dispatch({ type: 'tick' }); // Instead of setCount(c => c + step);  }, 1000);\n  return () => clearInterval(id);\n}, [dispatch]);\n```\n\n(查看 [demo](https://codesandbox.io/s/xzr480k0np)。)\n\n你可能会问：“这怎么就更好了？”答案是**React会保证`dispatch`在组件的声明周期内保持不变。所以上面例子中不再需要重新订阅定时器。**\n\n我们解决了问题!\n\n*（你可以从依赖中去除`dispatch`, `setState`, 和`useRef`包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。）*\n\n相比于直接在effect里面读取状态，它dispatch了一个*action*来描述发生了什么。这使得我们的effect和`step`状态解耦。我们的effect不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由reducer去统一处理:\n\n```jsx\nconst initialState = {\n  count: 0,\n  step: 1,\n};\n\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === 'tick') {    return { count: count + step, step };  } else if (action.type === 'step') {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n```\n\n(这里是[demo](https://codesandbox.io/s/xzr480k0np) 如果你之前错过了。)\n\n## [](#%E4%B8%BA%E4%BB%80%E4%B9%88usereducer%E6%98%AFhooks%E7%9A%84%E4%BD%9C%E5%BC%8A%E6%A8%A1%E5%BC%8F)为什么useReducer是Hooks的作弊模式\n\n我们已经学习到如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。**但假如我们需要依赖*props*去计算下一个状态呢？**举个例子，也许我们的API是`<Counter step={1} />`。确定的是，在这种情况下，我们没法避免依赖`props.step` 。是吗？\n\n实际上， 我们可以避免！我们可以把*reducer*函数放到组件内去读取props：\n\n```jsx\nfunction Counter({ step }) {  const [count, dispatch] = useReducer(reducer, 0);\n\n  function reducer(state, action) {\n    if (action.type === 'tick') {\n      return state + step;    } else {\n      throw new Error();\n    }\n  }\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n```\n\n这种模式会使一些优化失效，所以你应该避免滥用它，不过如果你需要你完全可以在reducer里面访问props。（这里是[demo](https://codesandbox.io/s/7ypm405o8q)。）\n\n**即使是在这个例子中，React也保证`dispatch`在每次渲染中都是一样的。** 所以你可以在依赖中去掉它。它不会引起effect不必要的重复执行。\n\n你可能会疑惑：这怎么可能？在之前渲染中调用的reducer怎么“知道”新的props？答案是当你`dispatch`的时候，React只是记住了action - 它会在下一次渲染中再次调用reducer。在那个时候，新的props就可以被访问到，而且reducer调用也不是在effect里。\n\n**这就是为什么我倾向认为`useReducer`是Hooks的“作弊模式”。它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的effect调用。**\n\n## [](#%E6%8A%8A%E5%87%BD%E6%95%B0%E7%A7%BB%E5%88%B0effects%E9%87%8C)把函数移到Effects里\n\n一个典型的误解是认为函数不应该成为依赖。举个例子，下面的代码看上去可以运行正常：\n\n```jsx\nfunction SearchResults() {\n  const [data, setData] = useState({ hits: [] });\n\n  async function fetchData() {\n    const result = await axios(\n      'https://hn.algolia.com/api/v1/search?query=react',\n    );\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []); // Is this okay?\n  // ...\n```\n\n*([这个例子](https://codesandbox.io/s/8j4ykjyv0) 改编自Robin Wieruch这篇很棒的文章 — [点击查看](https://www.robinwieruch.de/react-hooks-fetch-data/)！)*\n\n需要明确的是，上面的代码可以正常工作。**但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行。**\n\n想象一下我们的代码做下面这样的分离，并且每一个函数的体量是现在的五倍：\n\n```jsx\nfunction SearchResults() {\n  // Imagine this function is long\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=react';\n  }\n\n  // Imagine this function is also long\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n```\n\n然后我们在某些函数内使用了某些state或者prop：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // Imagine this function is also long\n  function getFetchUrl() {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;  }\n\n  // Imagine this function is also long\n  async function fetchData() {\n    const result = await axios(getFetchUrl());\n    setData(result.data);\n  }\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  // ...\n}\n```\n\n如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的effects的依赖，我们的effects就不会同步props和state带来的变更。这当然不是我们想要的。\n\n幸运的是，对于这个问题有一个简单的解决方案。**如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：**\n\n```jsx\nfunction SearchResults() {\n  // ...\n  useEffect(() => {\n    // We moved these functions inside!    function getFetchUrl() {      return 'https://hn.algolia.com/api/v1/search?query=react';    }    async function fetchData() {      const result = await axios(getFetchUrl());      setData(result.data);    }\n    fetchData();\n  }, []); // ✅ Deps are OK\n  // ...\n}\n```\n\n([这里是demo](https://codesandbox.io/s/04kp3jwwql).)\n\n这么做有什么好处呢？我们不再需要去考虑这些“间接依赖”。我们的依赖数组也不再撒谎：**在我们的effect中确实没有再使用组件范围内的任何东西。**\n\n如果我们后面修改 `getFetchUrl`去使用`query`状态，我们更可能会意识到我们正在effect里面编辑它 - 因此，我们需要把`query`添加到effect的依赖里：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  useEffect(() => {\n    function getFetchUrl() {\n      return 'https://hn.algolia.com/api/v1/search?query=' + query;    }\n\n    async function fetchData() {\n      const result = await axios(getFetchUrl());\n      setData(result.data);\n    }\n\n    fetchData();\n  }, [query]); // ✅ Deps are OK\n  // ...\n}\n```\n\n(这里是[demo](https://codesandbox.io/s/pwm32zx7z7).)\n\n添加这个依赖，我们不仅仅是在“取悦React”。在query改变后去重新请求数据是合理的。`useEffect`的设计意图就是要强迫你关注数据流的改变，然后决定我们的effects该如何和它同步 - 而不是忽视它直到我们的用户遇到了bug。\n\n感谢`eslint-plugin-react-hooks` 插件的`exhaustive-deps`lint规则，它会在你[编码的时候就分析effects](https://github.com/facebook/react/issues/14920)并且提供可能遗漏依赖的建议。换句话说，机器会告诉你组件中哪些数据流变更没有被正确地处理。\n\n![Lint 规则 gif](https://overreacted.io/04a90dcbacb01105d634964880ebed19/exhaustive-deps.gif)\n\n非常棒。\n\n## [](#%E4%BD%86%E6%88%91%E4%B8%8D%E8%83%BD%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%94%BE%E5%88%B0effect%E9%87%8C)但我不能把这个函数放到Effect里\n\n有时候你可能不想把函数移入effect里。比如，组件内有几个effect使用了相同的函数，你不想在每个effect里复制黏贴一遍这个逻辑。也或许这个函数是一个prop。\n\n在这种情况下你应该忽略对函数的依赖吗？我不这么认为。再次强调，**effects不应该对它的依赖撒谎。**通常我们还有更好的解决办法。一个常见的误解是，“函数从来不会改变”。但是这篇文章你读到现在，你知道这显然不是事实。实际上，在组件内定义的函数每一次渲染都在变。\n\n**函数每次渲染都会改变这个事实本身就是个问题。** 比如有两个effects会调用 `getFetchUrl`:\n\n```jsx\nfunction SearchResults() {\n  function getFetchUrl(query) {\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}\n```\n\n在这个例子中，你可能不想把`getFetchUrl` 移到effects中，因为你想复用逻辑。\n\n另一方面，如果你对依赖很“诚实”，你可能会掉到陷阱里。我们的两个effects都依赖`getFetchUrl`，**而它每次渲染都不同**，所以我们的依赖数组会变得无用：\n\n```jsx\nfunction SearchResults() {\n  // 🔴 Re-triggers all effects on every render  function getFetchUrl(query) {    return 'https://hn.algolia.com/api/v1/search?query=' + query;  }\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // 🚧 Deps are correct but they change too often\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // 🚧 Deps are correct but they change too often\n\n  // ...\n}\n```\n\n一个可能的解决办法是把`getFetchUrl`从依赖中去掉。但是，我不认为这是好的解决方式。这会使我们后面对数据流的改变很难被发现从而忘记去处理。这会导致类似于上面“定时器不更新值”的问题。\n\n相反的，我们有两个更简单的解决办法。\n\n**第一个， 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在effects中使用：**\n\n```jsx\n// ✅ Not affected by the data flowfunction getFetchUrl(query) {  return 'https://hn.algolia.com/api/v1/search?query=' + query;}\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于props或state。\n\n或者， 你也可以把它包装成 [`useCallback` Hook](https://reactjs.org/docs/hooks-reference.html#usecallback):\n\n```jsx\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same  const getFetchUrl = useCallback((query) => {    return 'https://hn.algolia.com/api/v1/search?query=' + query;  }, []);  // ✅ Callback deps are OK\n  useEffect(() => {\n    const url = getFetchUrl('react');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl('redux');\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n`useCallback`本质上是添加了一层依赖检查。它以另一种方式解决了问题 - **我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。**\n\n我们来看看为什么这种方式是有用的。之前，我们的例子中展示了两种搜索结果（查询条件分别为`'react'`和`'redux'`）。但如果我们想添加一个输入框允许你输入任意的查询条件(`query`)。不同于传递`query`参数的方式，现在`getFetchUrl`会从状态中读取。\n\n我们很快发现它遗漏了`query`依赖：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n  const getFetchUrl = useCallback(() => { // No query argument\n    return 'https://hn.algolia.com/api/v1/search?query=' + query;\n  }, []); // 🔴 Missing dep: query  // ...\n}\n```\n\n如果我把`query`添加到`useCallback` 的依赖中，任何调用了`getFetchUrl`的effect在`query`改变后都会重新运行：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes  const getFetchUrl = useCallback(() => {    return 'https://hn.algolia.com/api/v1/search?query=' + query;  }, [query]);  // ✅ Callback deps are OK\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n我们要感谢`useCallback`，因为如果`query` 保持不变，`getFetchUrl`也会保持不变，我们的effect也不会重新运行。但是如果`query`修改了，`getFetchUrl`也会随之改变，因此会重新请求数据。这就像你在Excel里修改了一个单元格的值，另一个使用它的单元格会自动重新计算一样。\n\n这正是拥抱数据流和同步思维的结果。**对于通过属性从父组件传入的函数这个方法也适用：**\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState('react');\n\n  // ✅ Preserves identity until query changes  const fetchData = useCallback(() => {    const url = 'https://hn.algolia.com/api/v1/search?query=' + query;    // ... Fetch data and return it ...  }, [query]);  // ✅ Callback deps are OK\n  return <Child fetchData={fetchData} />\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n因为`fetchData`只有在`Parent`的`query`状态变更时才会改变，所以我们的`Child`只会在需要的时候才去重新请求数据。\n\n## [](#%E5%87%BD%E6%95%B0%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%90%97%EF%BC%9F)函数是数据流的一部分吗？\n\n有趣的是，这种模式在class组件中行不通，并且这种行不通恰到好处地揭示了effect和生命周期范式之间的区别。考虑下面的转换：\n\n```jsx\nclass Parent extends Component {\n  state = {\n    query: 'react'\n  };\n  fetchData = () => {    const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;    // ... Fetch data and do something ...  };  render() {\n    return <Child fetchData={this.fetchData} />;\n  }\n}\n\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {    this.props.fetchData();  }  render() {\n    // ...\n  }\n}\n```\n\n你可能会想：“少来了Dan，我们都知道`useEffect` 就像`componentDidMount` 和 `componentDidUpdate`的结合，你不能老是破坏这一条！”**好吧，就算加了`componentDidUpdate`照样无用：**\n\n```jsx\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {    // 🔴 This condition will never be true    if (this.props.fetchData !== prevProps.fetchData) {      this.props.fetchData();    }  }  render() {\n    // ...\n  }\n}\n```\n\n当然如此，`fetchData`是一个class方法！（或者你也可以说是class属性 - 但这不能改变什么。）它不会因为状态的改变而不同，所以`this.props.fetchData`和 `prevProps.fetchData`始终相等，因此不会重新请求。那我们删掉条件判断怎么样？\n\n```jsx\n  componentDidUpdate(prevProps) {\n    this.props.fetchData();\n  }\n```\n\n等等，这样会在每次渲染后都去请求。(添加一个加载动画可能是一种有趣的发现这种情况的方式。)也许我们可以绑定一个特定的query?\n\n```jsx\n  render() {\n    return <Child fetchData={this.fetchData.bind(this, this.state.query)} />;\n  }\n```\n\n但这样一来，`this.props.fetchData !== prevProps.fetchData` 表达式永远是`true`，即使`query`并未改变。这会导致我们总是去请求。\n\n想要解决这个class组件中的难题，唯一现实可行的办法是硬着头皮把`query`本身传入 `Child` 组件。 `Child` 虽然实际并没有直接*使用*这个`query`的值，但能在它改变的时候触发一次重新请求：\n\n```jsx\nclass Parent extends Component {\n  state = {\n    query: 'react'\n  };\n  fetchData = () => {\n    const url = 'https://hn.algolia.com/api/v1/search?query=' + this.state.query;\n    // ... Fetch data and do something ...\n  };\n  render() {\n    return <Child fetchData={this.fetchData} query={this.state.query} />;  }\n}\n\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.query !== prevProps.query) {      this.props.fetchData();    }  }\n  render() {\n    // ...\n  }\n}\n```\n\n在使用React的class组件这么多年后，我已经如此习惯于把不必要的props传递下去并且破坏父组件的封装以至于我在一周之前才意识到我为什么一定要这样做。\n\n**在class组件中，函数属性本身并不是数据流的一部分。**组件的方法中包含了可变的`this`变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做“diff”。我们无法知道传入的`this.props.fetchData` 是否依赖状态，并且不知道它依赖的状态是否改变了。\n\n**使用`useCallback`，函数完全可以参与到数据流中。**我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。感谢周到的`useCallback`，属性比如`props.fetchData`的改变也会自动传递下去。\n\n类似的，[`useMemo`](https://reactjs.org/docs/hooks-reference.html#usememo)可以让我们对复杂对象做类似的事情。\n\n```jsx\nfunction ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState('pink');\n  const style = useMemo(() => ({ color }), [color]);\n  return <Child style={style} />;\n}\n```\n\n**我想强调的是，到处使用`useCallback`是件挺笨拙的事。**当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，`useCallback` 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。但总的来说Hooks本身能更好地[避免传递回调函数](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)。\n\n在上面的例子中，我更倾向于把`fetchData`放在我的effect里（它可以抽离成一个自定义Hook）或者是从顶层引入。我想让effects保持简单，而在里面调用回调会让事情变得复杂。（“如果某个`props.onComplete`回调改变了而请求还在进行中会怎么样？”）你可以[模拟class的行为](#swimming-against-the-tide)但那样并不能解决竞态的问题。\n\n## [](#%E8%AF%B4%E8%AF%B4%E7%AB%9E%E6%80%81)说说竞态\n\n下面是一个典型的在class组件里发请求的例子：\n\n```jsx\nclass Article extends Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n```\n\n你很可能已经知道，上面的代码埋伏了一些问题。它并没有处理更新的情况。所以第二个你能够在网上找到的经典例子是下面这样的：\n\n```jsx\nclass Article extends Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {    if (prevProps.id !== this.props.id) {      this.fetchData(this.props.id);    }  }  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n```\n\n这显然好多了！但依旧有问题。有问题的原因是请求结果返回的顺序不能保证一致。比如我先请求 `{id: 10}`，然后更新到`{id: 20}`，但`{id: 20}`的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值。\n\n这被叫做竞态，这在混合了`async` / `await`（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props和state可能会在async函数调用过程中发生改变）。\n\nEffects并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个`async` 函数给effect。（我们会改善这个警告来更好地解释你可能会遇到的这些问题。）\n\n如果你使用的异步方式支持取消，那太棒了。你可以直接在清除函数中取消异步请求。\n\n或者，最简单的权宜之计是用一个布尔值来跟踪它：\n\n```jsx\nfunction Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() => {\n    let didCancel = false;\n    async function fetchData() {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {        setArticle(article);\n      }\n    }\n\n    fetchData();\n\n    return () => {      didCancel = true;    };  }, [id]);\n\n  // ...\n}\n```\n\n[这篇文章](https://www.robinwieruch.de/react-hooks-fetch-data/)讨论了更多关于如何处理错误和加载状态，以及抽离逻辑到自定义的Hook。我推荐你认真阅读一下如果你想学习更多关于如何在Hooks里请求数据的内容。\n\n## [](#%E6%8F%90%E9%AB%98%E6%B0%B4%E5%87%86)提高水准\n\n在class组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI渲染是被props和state驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。\n\n而在`useEffect`的思维模型中，默认都是同步的。副作用变成了React数据流的一部分。对于每一个`useEffect`调用，一旦你处理正确，你的组件能够更好地处理边缘情况。\n\n然而，用好`useEffect`的前期学习成本更高。这可能让人气恼。用同步的代码去处理边缘情况天然就比触发一次不用和渲染结果步调一致的副作用更难。\n\n这难免让人担忧如果`useEffect`是你现在使用最多的工具。不过，目前大抵还处理低水平使用阶段。因为Hooks太新了所以大家都还在低水平地使用它，尤其是在一些教程示例中。但在实践中，社区很可能即将开始高水平地使用Hooks，因为好的API会有更好的动量和冲劲。\n\n我看到不同的应用在创造他们自己的Hooks，比如封装了应用鉴权逻辑的`useFetch`或者使用theme context的`useTheme` 。你一旦有了包含这些的工具箱，你就不会那么频繁地直接使用`useEffect`。但每一个基于它的Hook都能从它的适应能力中得到益处。\n\n目前为止，`useEffect`主要用于数据请求。但是数据请求准确说并不是一个同步问题。因为我们的依赖经常是`[]`所以这一点尤其明显。那我们究竟在同步什么？\n\n长远来看， [Suspense用于数据请求](https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#react-16x-mid-2019-the-one-with-suspense-for-data-fetching) 会允许第三方库通过第一等的途径告诉React暂停渲染直到某些异步事物（任何东西：代码，数据，图片）已经准备就绪。\n\n当Suspense逐渐地覆盖到更多的数据请求使用场景，我预料`useEffect` 会退居幕后作为一个强大的工具，用于同步props和state到某些副作用。不像数据请求，它可以很好地处理这些场景因为它就是为此而设计的。不过在那之前，自定义的Hooks比如[这儿提到的](https://www.robinwieruch.de/react-hooks-fetch-data/)是复用数据请求逻辑很好的方式。"
    },
    {
      "id": "这可能是最通俗的ReactFiber",
      "metadata": {
        "permalink": "/这可能是最通俗的ReactFiber",
        "source": "@site/blog/这可能是最通俗的ReactFiber.md",
        "title": "这可能是最通俗的ReactFiber",
        "description": "请输入描述",
        "date": "2023-08-28T07:54:21.115Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 63.385,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "这可能是最通俗的ReactFiber",
          "title": "这可能是最通俗的ReactFiber",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "useEffect完整指南",
          "permalink": "/useEffect完整指南"
        },
        "nextItem": {
          "title": "完全理解React",
          "permalink": "/完全理解React"
        }
      },
      "content": "写一篇关于 React Fiber 的文章， 这个 Flag 立了很久，这也是今年的目标之一。 最近的在掘金的文章获得很多关注和鼓励，给了我很多动力，所以下定决心好好把它写出来。 我会以最通俗的方式将它讲透, 因此这算是一篇科普式的文章。不管你是使用React、还是Vue，这里面的思想值得学习学习!\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc21324c38b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n一年一度的 React 春晚: [React Conf](https://conf.reactjs.org/schedule.html \"https://conf.reactjs.org/schedule.html\") 即将到来，不知道今年会不会有什么惊喜，去年是 React Hooks，前年是 React Fiber... 我得赶在 React Conf 之前发布这篇文章:\n\n+   😲 **React Fiber 已经出来这么久了， 这文章是老酒装新瓶吧**? *对于我来说，通过这篇文章我重新认识了 React Fiber，它不是一个新东西, 它也是老酒装新瓶，不信你就看吧...*\n    \n+   🆕 **React Fiber 不是一个新的东西，但在前端领域是第一次广为认知的应用**。\n    \n+   😦 **了解它有啥用**? *React Fiber 代码很复杂，门槛很高，你不了解它，后面 React 新出的 Killer Feature 你可能就更不能理解了*\n    \n+   🤥 **我不是升到React v16了吗? 没什么出奇的啊**? *真正要体会到 React Fiber 重构效果，可能下个月、可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票、不是说今年第二季度就出来了吗*？\n    \n+   😁 **不好意思，一不小心又写得有点长，你就当小说看吧, 代码都是伪代码**\n    \n\n**以下文章大纲**\n\n+   [单处理进程调度: Fiber 不是一个新的东西](#%E5%8D%95%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-fiber-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF \"#%E5%8D%95%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-fiber-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%9C%E8%A5%BF\")\n+   [类比浏览器JavaScript执行环境](#%E7%B1%BB%E6%AF%94%E6%B5%8F%E8%A7%88%E5%99%A8javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83 \"#%E7%B1%BB%E6%AF%94%E6%B5%8F%E8%A7%88%E5%99%A8javascript%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\")\n+   [何为 Fiber](#%E4%BD%95%E4%B8%BA-fiber \"#%E4%BD%95%E4%B8%BA-fiber\")\n    +   [1\\. 一种流程控制原语](#1-%E4%B8%80%E7%A7%8D%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD \"#1-%E4%B8%80%E7%A7%8D%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD\")\n    +   [2\\. 一个执行单元](#2-%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83 \"#2-%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83\")\n+   [React 的Fiber改造](#react-%E7%9A%84fiber%E6%94%B9%E9%80%A0 \"#react-%E7%9A%84fiber%E6%94%B9%E9%80%A0\")\n    +   [1\\. 数据结构的调整](#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4 \"#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B0%83%E6%95%B4\")\n    +   [2\\. 两个阶段的拆分](#2-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8B%86%E5%88%86 \"#2-%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%8B%86%E5%88%86\")\n    +   [3\\. Reconcilation](#3-reconcilation \"#3-reconcilation\")\n    +   [4\\. 双缓冲](#4-%E5%8F%8C%E7%BC%93%E5%86%B2 \"#4-%E5%8F%8C%E7%BC%93%E5%86%B2\")\n    +   [5\\. 副作用的收集和提交](#5-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E6%8F%90%E4%BA%A4 \"#5-%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E6%8F%90%E4%BA%A4\")\n+   [⚠️ 未展开部分 🚧 -- 中断和恢复](#%E2%9A%A0%EF%B8%8F-%E6%9C%AA%E5%B1%95%E5%BC%80%E9%83%A8%E5%88%86-%F0%9F%9A%A7----%E4%B8%AD%E6%96%AD%E5%92%8C%E6%81%A2%E5%A4%8D \"#%E2%9A%A0%EF%B8%8F-%E6%9C%AA%E5%B1%95%E5%BC%80%E9%83%A8%E5%88%86-%F0%9F%9A%A7----%E4%B8%AD%E6%96%AD%E5%92%8C%E6%81%A2%E5%A4%8D\")\n+   [凌波微步](#%E5%87%8C%E6%B3%A2%E5%BE%AE%E6%AD%A5 \"#%E5%87%8C%E6%B3%A2%E5%BE%AE%E6%AD%A5\")\n+   [站在巨人的肩膀上](#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A \"#%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A\")\n\n## 单处理进程调度: Fiber 不是一个新的东西\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc2160c5d19~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*这个黑乎乎的界面应该就是微软的 `DOS` 操作系统*\n\n微软 [`DOS`](https://zh.wikipedia.org/zh-cn/DOS \"https://zh.wikipedia.org/zh-cn/DOS\") 是一个`单任务操作系统`, 也称为’单工操作系统‘. 这种操作系统同一个时间只允许运行一个程序. [invalid s](https://www.zhihu.com/people/s.invalid \"https://www.zhihu.com/people/s.invalid\")在[《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》](https://www.zhihu.com/question/319595914/answer/683541635 \"https://www.zhihu.com/question/319595914/answer/683541635\") 的回答中将其称为: '**一种压根没有任务调度的“残疾”操作系统**'.\n\n在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。\n\n直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。\n\n> 注意并发和并行不是同一个概念。\n\n现代操作系统都是**多任务操作系统**. 进程的调度策略如果按照CPU核心数来划分，可以分为**单处理器调度**和**多处理器调度**。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。\n\n**🔴说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行**。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc244cdd934~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n这让我想起了“龙珠”中的分身术(小时候看过，说错了别喷)，实质上是一个人，只不过是他运动速度太快，看起来就像分身了. 这就是所谓的**并发(Concurrent)**(单处理器)。\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc230c34e9b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是**并行**(严格地讲这是`Master-Slave`架构，分身虽然物理存在，但应该没有独立的意志)。\n\n所以说**🔴并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持**。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲[Concurrency is not parallelism](https://blog.golang.org/concurrency-is-not-parallelism \"https://blog.golang.org/concurrency-is-not-parallelism\")\n\n扯远了，接下来进程怎么调度就是教科书的内容了。如果读者在大学认真学过**操作系统原理**, 你可以很快理解以下几种单处理器进程**调度策略**(我就随便科普一下，算送的, 如果你很熟悉这块，可以跳过)：\n\n**0️⃣ 先到先得(First-Come-First-Served, FCFS)**\n\n这是最简单的调度策略, 简单说就是**没有调度**。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队).\n\n`FCFS` 上面 `DOS` 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。\n\n+   **FCFS 对`短进程`不利**。 短进程即执行时间非常短的进程，可以用饭堂排队来比喻: *在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像`长进程`一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久...*\n    \n+   **FCFS 对`I/O密集`不利**。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被宠幸。 可以类比ZF部门办业务: *假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平...*\n    \n\n所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。\n\n**1️⃣ 轮转**\n\n这是一种基于时钟的**抢占策略**，这也是抢占策略中最简单的一种: **公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来**。\n\n> **决策模式**: `抢占策略`相对应的有`非抢占策略`，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。\n\n这种调度策略的要点是**确定合适的时间片长度**: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 `FCFS` 没什么区别了; 太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。\n\n因此**时间片的长度最好符合大部分进程完成一次典型交互所需的时间**.\n\n轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和`FCFS`一样，轮转策略对I/O进程还是不公平。\n\n**2️⃣ 最短进程优先(Shortest Process Next, SPN)**\n\n上面说了`先到先得`策略对`短进程`不公平，`最短进程优先`索性就让'最短'的进程优先执行，也就是说: **按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略**。\n\n这样可以让短进程能得到较快的响应。但是怎么获取或者**评估进程执行时间**呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。\n\n`SPN` 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。\n\n另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 `FCFS` 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。\n\n**3️⃣ 最短剩余时间(Shortest Remaining Time, SRT)**\n\n**SRT 进一步优化了SPN，增加了抢占机制**。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较*刚添加的新进程*和*当前正在执行的老进程*的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。\n\n相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。**另外长进程饥饿问题还是没有解决**。\n\n**4️⃣ 最高响应比优先(HRRN)**\n\n**为了解决长进程饥饿问题，同时提高进程的响应速率**。还有一种`最高响应比优先的`策略，首先了解什么是响应比:\n\n```shell\n响应比 = （等待执行时间 + 进程执行时间） / 进程执行时间\n```\n\n**这种策略会选择响应比最高的进程优先执行**：\n\n+   对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行\n+   对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行\n\n**5️⃣ 反馈法**\n\nSPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是**事后反馈**的方式。这种策略下: **每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列**。\n\n举个例子:\n\n```shell\n队列1\n队列2\n...\n队列N\n```\n\n新增的任务会推入`队列1`，`队列1`会按照`轮转策略`以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入`队列2`。\n\n`队列2`会在`队列1`任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以`队列2`的轮转时间片长度是2。\n\n反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc24dfd080c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n没有一种调度策略是万能的, 它需要考虑很多因素:\n\n+   响应速率。进程等待被执行的时间\n+   公平性。兼顾短进程、长进程、I/O进程\n\n这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。\n\n上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 `Linux` 相关的进程调度算法，这方面的资料也非常多, 例如[《Linux进程调度策略的发展和演变》](https://blog.csdn.net/gatieme/article/details/51456569 \"https://blog.csdn.net/gatieme/article/details/51456569\")。\n\n## 类比浏览器JavaScript执行环境\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc207590429~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*JavaScript 就像单行道*\n\nJavaScript 是[单线程运行](https://juejin.cn/post/6844903553795014663 \"https://juejin.cn/post/6844903553795014663\")的，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。\n\n> 这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个`渲染线程`，GUI 渲染和 Javascript执行 两者是互斥的. 另外异步 I/O 操作底层实际上可能是多线程的在驱动。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc35b99001e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*图片来源: [Rendering Performance](https://developers.google.com/web/fundamentals/performance/rendering \"https://developers.google.com/web/fundamentals/performance/rendering\")*\n\n**它只是一个'JavaScript'，同时只能做一件事情，这个和 `DOS` 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差**。\n\n**对于’前端框架‘来说，解决这种问题有三个方向**:\n\n+   1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量\n+   2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互\n+   3️⃣ 尝试 Worker 多线程\n\nVue 选择的是第1️⃣, 因为对于Vue来说，使用`模板`让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下[今年Vue Conf 尤雨溪的演讲](https://www.yuque.com/vueconf/2019/gwn1z0 \"https://www.yuque.com/vueconf/2019/gwn1z0\")，非常棒!；而 React 选择了2️⃣ 。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。\n\nReact 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, **🔴在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 `Reconcilation`(中文可以译为`协调`)**.\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc366f124be~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。\n\n这样说，你可能没办法体会到，通过下面两个图片来体会一下(*图片来源于：[Dan Abramov](https://twitter.com/dan_abramov \"https://twitter.com/dan_abramov\") 的 [Beyond React 16](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html \"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\") 演讲, 推荐看一下👍. 另外非常感谢[淡苍](https://www.zhihu.com/people/BlackGanglion/activities \"https://www.zhihu.com/people/BlackGanglion/activities\") 将一个[类似的DEMO 分享在了 CodeSandbox](https://codesandbox.io/s/koyz664q35 \"https://codesandbox.io/s/koyz664q35\")上🎉，大家自行体验*):\n\n同步模式下的 React:\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc3acaf5689~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n优化后的 `Concurrent` 模式下的 React:\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc385cc0286~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\nReact 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。\n\n所以React 是怎么优化的？ 划重点， **🔴为了给用户制造一种应用很快的'假象'，我们不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率**。\n\n**🔴所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 '适时'地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处**:\n\n+   与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在[《「前端进阶」高性能渲染十万条数据(时间分片)》](https://juejin.cn/post/6844903938894872589#heading-1 \"https://juejin.cn/post/6844903938894872589#heading-1\") 以及司徒正美的[《React Fiber架构》](https://zhuanlan.zhihu.com/p/37095662 \"https://zhuanlan.zhihu.com/p/37095662\") 都做了相关实验\n+   司徒正美在[《React Fiber架构》](https://zhuanlan.zhihu.com/p/37095662 \"https://zhuanlan.zhihu.com/p/37095662\") 也提到：**🔴给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正**.\n\n这就是为什么React 需要 Fiber 😏。\n\n  \n\n## 何为 Fiber\n\n对于 React 来说，Fiber 可以从两个角度理解:\n\n  \n\n### 1\\. 一种流程控制原语\n\nFiber 也称[协程](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272 \"https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272\")、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的`Coroutine`, 还有前端开发者比较熟悉的 `ES6` 新增的[`Generator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator\")。\n\n> 本文不纠结 [Processes, threads, green threads, protothreads, fibers, coroutines: what's the difference?](https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591 \"https://stackoverflow.com/questions/3324643/processes-threads-green-threads-protothreads-fibers-coroutines-whats-the/16375591#16375591\")\n\n**🔴 其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制**。要理解协程，你得和普通函数一起来看, 以Generator为例:\n\n普通函数执行的过程中无法**被中断和恢复**：\n\n```js\nconst tasks = []\nfunction run() {\n  let task\n  while (task = tasks.shift()) {\n    execute(task)\n  }\n}\n```\n\n而 `Generator` 可以:\n\n```js\nconst tasks = []\nfunction * run() {\n  let task\n\n  while (task = tasks.shift()) {\n    // 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权\n    if (hasHighPriorityEvent()) {\n      yield\n    }\n\n    // 处理完高优先级事件后，恢复函数调用栈，继续执行...\n    execute(task)\n  }\n}\n```\n\nReact Fiber 的思想和协程的概念是契合的: **🔴React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染**。\n\n那么现在你应该有以下疑问:\n\n+   1️⃣ 浏览器没有抢占的条件, 所以React只能用让出机制?\n+   2️⃣ 怎么确定有高优先任务要处理，即什么时候让出？\n+   3️⃣ React 那为什么不使用 Generator？\n\n**答1️⃣: 没错, 主动让出机制**\n\n一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。\n\n所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：[**合作式调度(Cooperative Scheduling)**](https://juejin.cn/post/6844903874692661255#heading-7 \"https://juejin.cn/post/6844903874692661255#heading-7\"), 相对应的有**抢占式调度(Preemptive Scheduling)**\n\n**这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任**。比如可以由浏览器给我们分配执行时间片(通过`requestIdleCallback`实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc37fdd60d7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n这种调度方式很有趣，你会发现**这是一种身份的对调**，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。\n\n当然你超时不还浏览器也拿你没办法 🤷‍... 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。\n\n  \n\n* * *\n\n**答2️⃣: requestIdleCallback API**\n\n上面代码示例中的 `hasHighPriorityEvent()` 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。\n\n只能换一种思路，通过**超时检查的机制来让出控制权**。解决办法是: *确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器*。\n\n举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。\n\n其实浏览器提供了相关的接口 —— [`requestIdleCallback`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback \"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\") API：\n\n```auto\nwindow.requestIdleCallback(\n  callback: (dealine: IdleDeadline) => void,\n  option?: {timeout: number}\n  )\n```\n\n`IdleDeadline`的接口如下：\n\n```auto\ninterface IdleDealine {\n  didTimeout: boolean // 表示任务执行是否超过约定时间\n  timeRemaining(): DOMHighResTimeStamp // 任务可供执行的剩余时间\n}\n```\n\n单从名字上理解的话, `requestIdleCallback`的意思是**让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕**。\n\n**那浏览器什么时候有空？**\n\n我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd81f16c6f2~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。*  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc428fb4c0b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*图片来源: [你应该知道的requestIdleCallback](https://juejin.cn/post/6844903592831238157 \"https://juejin.cn/post/6844903592831238157\")*\n\n浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:\n\n+   处理用户输入事件\n+   Javascript执行\n+   requestAnimation 调用\n+   布局 Layout\n+   绘制 Paint\n\n上面说理想的一帧时间是 `16ms` (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 `requestIdleCallback` 的回调。例如\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc43c710e16~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**但是在浏览器繁忙的时候，可能不会有盈余时间，这时候`requestIdleCallback`回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间**。\n\n> 另外不建议在`requestIdleCallback`中进行`DOM`操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 `getBoundingClientRect`)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。\n\n目前 `requestIdleCallback` 目前只有Chrome支持。所以目前 React [自己实现了一个](https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js \"https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js\")。它利用[`MessageChannel`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel \"https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel\") 模拟将回调延迟到'绘制操作'之后执行:\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc5839a3974~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n  \n简单看一下代码\n\n```js\nconst el = document.getElementById('root')\nconst btn = document.getElementById('btn')\nconst ch = new MessageChannel()\nlet pendingCallback\nlet startTime\nlet timeout\n\nch.port2.onmessage = function work()  {\n  // 在绘制之后被执行\n  if (pendingCallback) {\n    const now = performance.now()\n    // 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间\n    // 通过这些数据来计算剩余时间\n    // 另外还要处理超时(timeout)，避免任务被饿死\n    // ...\n    if (hasRemain && noTimeout) {\n      pendingCallback(deadline)\n    }\n  }\n}\n\n// ...\n\nfunction simpleRequestIdleCallback(callback, timeout) {\n  requestAnimationFrame(function animation() {\n    // 在绘制之前被执行\n    // 记录开始时间\n    startTime = performance.now()\n    timeout = timeout\n    dosomething()\n    // 调度回调到绘制结束后执行\n    pendingCallback = callback\n    ch.port1.postMessage('hello')\n  })\n}\n```\n\n**任务优先级**\n\n上面说了，为了避免任务被饿死，可以设置一个超时时间. **这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行**. 目前 React 预定义了 5 个优先级, 这个我在\\[《谈谈React事件机制和未来(react-events)》\\]中也介绍过:\n\n+   `Immediate`(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断\n+   `UserBlocking`(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈\n+   `Normal` (5s) 应对哪些不需要立即感受到的任务，例如网络请求\n+   `Low` (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知\n+   `Idle` (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死\n\n  \n\n* * *\n\n**答3️⃣: 太麻烦**\n\n官方在[《Fiber Principles: Contributing To Fiber》](https://github.com/facebook/react/issues/7942 \"https://github.com/facebook/react/issues/7942\") 也作出了解答。主要有两个原因：\n\n1.  Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。\n2.  Generator 是有状态的, 很难在中间恢复这些状态。\n\n> 上面理解可能有出入，建议看一下原文\n\n可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。\n\n### 2\\. 一个执行单元\n\nFiber的另外一种解读是’纤维‘: **这是一种数据结构或者说执行单元**。我们暂且不管这个数据结构长什么样，**🔴将它视作一个执行单元，每次执行完一个'执行单元', React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去**.\n\n上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：\n\n假设用户调用 `setState` 更新组件, 这个待更新的任务会先放入队列中, 然后通过 `requestIdleCallback` 请求浏览器调度：\n\n```js\nupdateQueue.push(updateTask);\nrequestIdleCallback(performWork, {timeout});\n```\n\n现在浏览器有空闲或者超时了就会调用`performWork`来执行任务：\n\n```js\n// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间\nfunction performWork(deadline) {\n\n  // 2️⃣ 循环取出updateQueue中的任务\n  while (updateQueue.length > 0 && deadline.timeRemaining() > ENOUGH_TIME) {\n    workLoop(deadline);\n  }\n\n  // 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度\n  if (updateQueue.length > 0) {\n    requestIdleCallback(performWork);\n  }\n}\n```\n\n**`workLoop` 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘`执行单元`‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个`执行单元`，反之则停止执行，保存现场，等下一次有执行权时恢复**:\n\n  \n\n```js\n// 保存当前的处理现场\nlet nextUnitOfWork: Fiber | undefined // 保存下一个需要处理的工作单元\nlet topWork: Fiber | undefined        // 保存第一个工作单元\n\nfunction workLoop(deadline: IdleDeadline) {\n  // updateQueue中获取下一个或者恢复上一次中断的执行单元\n  if (nextUnitOfWork == null) {\n    nextUnitOfWork = topWork = getNextUnitOfWork();\n  }\n\n  // 🔴 每执行完一个执行单元，检查一次剩余时间\n  // 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理\n  while (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {\n    // 下文我们再看performUnitOfWork\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);\n  }\n\n  // 提交工作，下文会介绍\n  if (pendingCommit) {\n    commitAllWork(pendingCommit);\n  }\n}\n```\n\n画个流程图吧！\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deed1711f281b3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n## React 的Fiber改造\n\nFiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。\n\n  \n\n### 1\\. 数据结构的调整\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc72bc9a14c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*左侧是Virtual DOM，右侧可以看作diff的递归调用栈*\n\n上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为`Stack Reconcilation`. 你可以通过这篇文章[《从Preact中了解React组件和hooks基本原理》](https://juejin.cn/post/6844903861434449933 \"https://juejin.cn/post/6844903861434449933\") 来回顾一下历史。\n\n栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解😂, 递归非常适合树这种嵌套数据结构的处理。\n\n只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。\n\n因此**首先我们需要对React现有的数据结构进行调整，[`模拟函数调用栈`](https://zhuanlan.zhihu.com/p/36425839 \"https://zhuanlan.zhihu.com/p/36425839\"), 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代**.\n\nReact 目前的做法是使用`链表`, 每个 VirtualDOM 节点内部现在使用 `Fiber`表示, 它的结构大概如下:\n\n```js\nexport type Fiber = {\n  // Fiber 类型信息\n  type: any,\n  // ...\n\n  // ⚛️ 链表结构\n  // 指向父节点，或者render该节点的组件\n  return: Fiber | null,\n  // 指向第一个子节点\n  child: Fiber | null,\n  // 指向下一个兄弟节点\n  sibling: Fiber | null,\n}\n```\n\n用图片来展示这种关系会更直观一些：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc6db5530be~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的**。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见[Wiki](https://en.wikipedia.org/wiki/Call_stack \"https://en.wikipedia.org/wiki/Call_stack\")：\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecc9a904099b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n> 调用栈最经常被用于存放子程序的**返回地址**。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存`本地变量`、`函数参数`、`环境传递`(Scope?)\n\nReact Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:\n\n|  | 函数调用栈 | Fiber |\n| --- | --- | --- |\n| 基本单位 | 函数 | Virtual DOM 节点 |\n| 输入 | 函数参数 | Props |\n| 本地状态 | 本地变量 | State |\n| 输出 | 函数返回值 | React Element |\n| 下级 | 嵌套函数调用 | 子节点(child) |\n| 上级引用 | 返回地址 | 父节点(return) |\n\nFiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。\n\n有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 `performUnitOfWork` 的实现, 它其实就是一个深度优先的遍历：\n\n  \n\n```js\n/**\n * @params fiber 当前需要处理的节点\n * @params topWork 本次更新的根节点\n */\nfunction performUnitOfWork(fiber: Fiber, topWork: Fiber) {\n  // 对该节点进行处理\n  beginWork(fiber);\n\n  // 如果存在子节点，那么下一个待处理的就是子节点\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  // 没有子节点了，上溯查找兄弟节点\n  let temp = fiber;\n  while (temp) {\n    completeWork(temp);\n\n    // 到顶层节点了, 退出\n    if (temp === topWork) {\n      break\n    }\n\n    // 找到，下一个要处理的就是兄弟节点\n    if (temp.sibling) {\n      return temp.sibling;\n    }\n\n    // 没有, 继续上溯\n    temp = temp.return;\n  }\n}\n```\n\n你可以配合上文的 `workLoop` 一起看，**Fiber 就是我们所说的工作单元，`performUnitOfWork` 负责对 `Fiber` 进行操作，并按照深度遍历的顺序返回下一个 Fiber**。\n\n**因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的`Fiber`继续遍历下去**。\n\n整个迭代顺序和之前递归的一样, 下图假设在 `div.app` 进行了更新：\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecca7850a24d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*比如你在`text(hello)`中断了，那么下一次就会从 `p` 节点开始处理*\n\n这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的`return`回溯即可。\n\n### 2\\. 两个阶段的拆分\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd830671a70~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：`Reconciliation`(协调阶段) 和 `Commit`(提交阶段).\n\n> 我在之前的多篇文章中都有提及: [《自己写个React渲染器: 以 Remax 为例(用React写小程序)》](https://juejin.cn/post/6844903946016784392 \"https://juejin.cn/post/6844903946016784392\")\n\n除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:\n\n+   **⚛️ 协调阶段**: 可以认为是 Diff 阶段, **这个阶段可以被中断**, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为'`副作用`(Effect)' . 以下生命周期钩子会在协调阶段被调用：\n    \n    +   `constructor`\n    +   `componentWillMount` 废弃\n    +   `componentWillReceiveProps` 废弃\n    +   `static getDerivedStateFromProps`\n    +   `shouldComponentUpdate`\n    +   `componentWillUpdate` 废弃\n    +   `render`\n+   **⚛️ 提交阶段**: 将上一个阶段计算出来的需要处理的\\*\\*副作用(Effects)\\*\\*一次性执行了。**这个阶段必须同步执行，不能被打断**. 这些生命周期钩子在提交阶段被执行:\n    \n    +   `getSnapshotBeforeUpdate()` 严格来说，这个是在进入 commit 阶段前调用\n    +   `componentDidMount`\n    +   `componentDidUpdate`\n    +   `componentWillUnmount`\n\n也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。\n\n需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，**⚠️React 协调阶段的生命周期钩子可能会被调用多次!**, 例如 `componentWillMount` 可能会被调用两次。\n\n因此建议 **协调阶段的生命周期钩子不要包含副作用**. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如`componentWillMount`、`componentWillUpdate`. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.\n\n现在你应该知道为什么'提交阶段'必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在`componentDidMount`中发起的异步请求、useEffect 中定义的副作用... 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。\n\n关于为什么要拆分两个阶段，[这里](https://github.com/facebook/react/issues/13186#issuecomment-403959161 \"https://github.com/facebook/react/issues/13186#issuecomment-403959161\")有更详细的解释。\n\n### 3\\. Reconcilation\n\n接下来就是就是我们熟知的`Reconcilation`(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. **思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更**。\n\n首先再进一步看一下`Fiber`的结构:\n\n```auto\ninterface Fiber {\n  /**\n   * ⚛️ 节点的类型信息\n   */\n  // 标记 Fiber 类型, 例如函数组件、类组件、宿主组件\n  tag: WorkTag,\n  // 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)\n  type: any,\n\n  /**\n   * ⚛️ 结构信息\n   */ \n  return: Fiber | null,\n  child: Fiber | null,\n  sibling: Fiber | null,\n  // 子节点的唯一键, 即我们渲染列表传入的key属性\n  key: null | string,\n\n  /**\n   * ⚛️ 节点的状态\n   */\n  // 节点实例(状态)：\n  //        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。\n  //        对于类组件来说，这里保存类组件的实例\n  //        对于函数组件说，这里为空，因为函数组件没有实例\n  stateNode: any,\n  // 新的、待处理的props\n  pendingProps: any,\n  // 上一次渲染的props\n  memoizedProps: any, // The props used to create the output.\n  // 上一次渲染的组件状态\n  memoizedState: any,\n\n\n  /**\n   * ⚛️ 副作用\n   */\n  // 当前节点的副作用类型，例如节点更新、删除、移动\n  effectTag: SideEffectTag,\n  // 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来\n  nextEffect: Fiber | null,\n\n  /**\n   * ⚛️ 替身\n   * 指向旧树中的节点\n   */\n  alternate: Fiber | null,\n}\n```\n\nFiber 包含的属性可以划分为 5 个部分:\n\n+   **🆕 结构信息** - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位\n    \n+   **节点类型信息** - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp\n    \n+   **节点的状态** - 节点的组件实例、props、state等，它们将影响组件的输出\n    \n+   **🆕 副作用** - 这个也是新东西. 在 Reconciliation 过程中发现的'副作用'(变更需求)就保存在节点的`effectTag` 中(想象为打上一个标记). 那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过`nextEffect`连接起来\n    \n+   **🆕 替身** - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，**WIP树**)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的**旧树**，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。\n    \n\n现在可以放大看看`beginWork` 是如何对 Fiber 进行比对的:\n\n```auto\nfunction beginWork(fiber: Fiber): Fiber | undefined {\n  if (fiber.tag === WorkTag.HostComponent) {\n    // 宿主节点diff\n    diffHostComponent(fiber)\n  } else if (fiber.tag === WorkTag.ClassComponent) {\n    // 类组件节点diff\n    diffClassComponent(fiber)\n  } else if (fiber.tag === WorkTag.FunctionComponent) {\n    // 函数组件节点diff\n    diffFunctionalComponent(fiber)\n  } else {\n    // ... 其他类型节点，省略\n  }\n}\n```\n\n宿主节点比对:\n\n```auto\nfunction diffHostComponent(fiber: Fiber) {\n  // 新增节点\n  if (fiber.stateNode == null) {\n    fiber.stateNode = createHostComponent(fiber)\n  } else {\n    updateHostComponent(fiber)\n  }\n\n  const newChildren = fiber.pendingProps.children;\n\n  // 比对子节点\n  diffChildren(fiber, newChildren);\n}\n```\n\n类组件节点比对也差不多:\n\n```auto\nfunction diffClassComponent(fiber: Fiber) {\n  // 创建组件实例\n  if (fiber.stateNode == null) {\n    fiber.stateNode = createInstance(fiber);\n  }\n\n  if (fiber.hasMounted) {\n    // 调用更新前生命周期钩子\n    applybeforeUpdateHooks(fiber)\n  } else {\n    // 调用挂载前生命周期钩子\n    applybeforeMountHooks(fiber)\n  }\n\n  // 渲染新节点\n  const newChildren = fiber.stateNode.render();\n  // 比对子节点\n  diffChildren(fiber, newChildren);\n\n  fiber.memoizedState = fiber.stateNode.state\n}\n```\n\n子节点比对:\n\n```auto\nfunction diffChildren(fiber: Fiber, newChildren: React.ReactNode) {\n  let oldFiber = fiber.alternate ? fiber.alternate.child : null;\n  // 全新节点，直接挂载\n  if (oldFiber == null) {\n    mountChildFibers(fiber, newChildren)\n    return\n  }\n\n  let index = 0;\n  let newFiber = null;\n  // 新子节点\n  const elements = extraElements(newChildren)\n\n  // 比对子元素\n  while (index < elements.length || oldFiber != null) {\n    const prevFiber = newFiber;\n    const element = elements[index]\n    const sameType = isSameType(element, oldFiber)\n    if (sameType) {\n      newFiber = cloneFiber(oldFiber, element)\n      // 更新关系\n      newFiber.alternate = oldFiber\n      // 打上Tag\n      newFiber.effectTag = UPDATE\n      newFiber.return = fiber\n    }\n\n    // 新节点\n    if (element && !sameType) {\n      newFiber = createFiber(element)\n      newFiber.effectTag = PLACEMENT\n      newFiber.return = fiber\n    }\n\n    // 删除旧节点\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = DELETION;\n      oldFiber.nextEffect = fiber.nextEffect\n      fiber.nextEffect = oldFiber\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index == 0) {\n      fiber.child = newFiber;\n    } else if (prevFiber && element) {\n      prevFiber.sibling = newFiber;\n    }\n\n    index++\n  }\n}\n```\n\n上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.\n\n这里引用一下[Youtube: Lin Clark presentation in ReactConf 2017](https://www.youtube.com/watch?v=ZCuYPiUIONs \"https://www.youtube.com/watch?v=ZCuYPiUIONs\") 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:\n\n> 这篇文章[《React Fiber》](https://juejin.cn/post/6844903582622285831 \"https://juejin.cn/post/6844903582622285831\") 用文字版解释了Link Clark Slide.\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecce3162b355~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了'标签'。 在提交阶段，React 就会将这些打上标签的节点应用变更。\n\n### 4\\. 双缓冲\n\n`WIP 树`构建这种技术类似于图形化领域的'**双缓存(Double Buffering)**'技术, 图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。\n\n放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。\n\n双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。\n\nDan 在 [Beyond React 16](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html \"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\") 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，**你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？**:\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deeccf3468b00b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n### 5\\. 副作用的收集和提交\n\n接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在`completeWork`中做, 例如:\n\n```auto\nfunction completeWork(fiber) {\n  const parent = fiber.return\n\n  // 到达顶端\n  if (parent == null || fiber === topWork) {\n    pendingCommit = fiber\n    return\n  }\n\n  if (fiber.effectTag != null) {\n    if (parent.nextEffect) {\n      parent.nextEffect.nextEffect = fiber\n    } else {\n      parent.nextEffect = fiber\n    }\n  } else if (fiber.nextEffect) {\n    parent.nextEffect = fiber.nextEffect\n  }\n}\n```\n\n最后了，将所有副作用提交了:\n\n```auto\nfunction commitAllWork(fiber) {\n  let next = fiber\n  while(next) {\n    if (fiber.effectTag) {\n      // 提交，偷一下懒，这里就不展开了\n      commitWork(fiber)\n    }\n    next = fiber.nextEffect\n  }\n\n  // 清理现场\n  pendingCommit = nextUnitOfWork = topWork = null\n}\n```\n\n## ⚠️ 未展开部分 🚧 -- 中断和恢复\n\n上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：**⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞**。我个人觉得这才是 React Fiber 中最难处理的一部分。\n\n**实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务**。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。\n\n**但是如果不按顺序执行任务，可能会导致前后的状态不一致**。 比如低优先级任务将 `a` 设置为0，而高优先级任务将 `a` 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此**要让高优先级任务插队, 首先要保证状态更新的时序**。\n\n解决办法是: **所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行**, 例如：\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deeccf96dac168~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证**状态的最终一致性**：\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd05f86b375~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n最终红色的高优先级任务 `C` 执行时的状态值是`a=5,b=3`. 在恢复控制权时，会按照优先级先执行 `C`, 前面的`A`、 `B`暂时跳过\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd121a8657a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 `a`、`b` 可能会影响 `Foo` 组件树，而 `c` 会影响 `Bar` 组件树。所以为了保证**视图的最终一致性**, 所有更新任务都要被执行。\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd19b1362c0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n首先 `C` 先被执行，它更新了 `Foo` 组件\n\n接着执行 `A` 任务，它更新了`Foo` 和 `Bar` 组件，由于 `C` 已经以最终状态`a=5, b=3`更新了`Foo`组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 `A` 仅需更新 `Bar` 组件即可。\n\n接着执行 `B`，同理可以复用 Foo 更新结果。\n\n道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证**状态的一致性**和**视图的一致性**，这给了 React 团队很大的考验，以致于现在都没有正式release出来。\n\n## 凌波微步\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd21336ca41~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*同样来自Link Clark 的 Slider*\n\n前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒... 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。\n\nReact 开启 `Concurrent Mode` 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd2d4124b05~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n*来源：[Flarnie Marchan - Ready for Concurrent Mode?](https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s \"https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s\")*\n\n开启 `Concurrent Mode` 后，我们可以得到以下好处(详见[Concurrent Rendering in React](https://www.youtube.com/watch?v=ByBPyMBTzM0 \"https://www.youtube.com/watch?v=ByBPyMBTzM0\")):\n\n+   快速响应用户操作和输入，提升用户交互体验\n+   让动画更加流畅，通过调度，可以让应用保持高帧率\n+   利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。\n+   用`Suspense` 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。\n\n但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。\n\n为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存...\n\n尤雨溪在今年的[Vue Conf](https://www.yuque.com/vueconf/2019 \"https://www.yuque.com/vueconf/2019\")一个观点让我印象深刻：**如果我们可以把更新做得足够快的话，理论上就不需要时间分片了**。\n\n**时间分片并没有降低整体的工作量，该做的还是要做**, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，**不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背**.\n\n## 站在巨人的肩膀上\n\n本文之所以能成文，离不开社区上优质的开源项目和资料。\n\n**迷你 Fiber 实现**:\n\nReact 现在的代码库太复杂了! 而且一直在变动和推翻自己，[Hax](https://www.zhihu.com/people/he-shi-jun \"https://www.zhihu.com/people/he-shi-jun\") 在 [《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》](https://www.zhihu.com/question/270428598/answer/354017709 \"https://www.zhihu.com/question/270428598/answer/354017709\") 就开玩笑说: Fiber 性价比略低... 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……\n\n这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:\n\n+   [anu](https://github.com/RubyLouvre/anu \"https://github.com/RubyLouvre/anu\") [司徒正美](https://github.com/RubyLouvre \"https://github.com/RubyLouvre\") 开发的类React框架\n+   [Fre](https://github.com/132yse/fre \"https://github.com/132yse/fre\") [伊撒尔](https://www.zhihu.com/people/132yse \"https://www.zhihu.com/people/132yse\") 开发的类React框架，代码很精简⁉️\n+   [Luy](https://github.com/Foveluy/Luy \"https://github.com/Foveluy/Luy\")\n+   [didact](https://github.com/pomber/didact \"https://github.com/pomber/didact\")\n\n**优秀的文章 & 演讲**\n\n本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多，如果你想深入理解React Fiber的，下面这些文章不容错过:\n\n+   [Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦](https://www.youtube.com/watch?v=ZCuYPiUIONs \"https://www.youtube.com/watch?v=ZCuYPiUIONs\") React Fiber 启蒙，YouTube\n+   [Beyond React 16 - Dan Abramov 👍🎦](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html \"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\")\n+   [Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦](https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s \"https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s\")\n+   [司徒正美: React Fiber架构 👍](https://zhuanlan.zhihu.com/p/37095662 \"https://zhuanlan.zhihu.com/p/37095662\") 看不如写\n+   [展望 React 17，回顾 React 往事 👍](https://www.zhihu.com/people/NE_SmallTown/posts \"https://www.zhihu.com/people/NE_SmallTown/posts\") 看完 [Heaven](https://www.zhihu.com/people/NE_SmallTown \"https://www.zhihu.com/people/NE_SmallTown\") 的相关文章，会觉得你了解的React 知识真的只是[冰山一角](https://zhuanlan.zhihu.com/jheaven \"https://zhuanlan.zhihu.com/jheaven\")，我们都没资格说我们懂 React。\n+   [浅入 React16/fiber 系列 👍](https://zhuanlan.zhihu.com/p/36425839 \"https://zhuanlan.zhihu.com/p/36425839\") 同样来自 Heaven\n+   [淡苍：深入剖析 React Concurrent 👍](https://www.zhihu.com/search?type=content&q=requestIdleCallback \"https://www.zhihu.com/search?type=content&q=requestIdleCallback\")\n+   [Didact Fiber: Incremental reconciliation 👍](https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec \"https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec\") 实现了简单的 React Fiber\n+   [程墨: React Fiber是什么](https://zhuanlan.zhihu.com/p/26027085 \"https://zhuanlan.zhihu.com/p/26027085\")\n+   [译 深入React fiber架构及源码](https://zhuanlan.zhihu.com/p/57346388 \"https://zhuanlan.zhihu.com/p/57346388\")\n+   [黯羽轻扬: 完全理解React Fiber](http://www.ayqy.net/blog/dive-into-react-fiber/ \"http://www.ayqy.net/blog/dive-into-react-fiber/\")\n+   [Fiber Principles: Contributing To Fiber](https://github.com/facebook/react/issues/7942 \"https://github.com/facebook/react/issues/7942\")\n+   [Scheduling in React](https://philippspiess.com/scheduling-in-react/ \"https://philippspiess.com/scheduling-in-react/\")\n+   [桃翁: Deep In React 之浅谈 React Fiber 架构（一）](https://juejin.cn/post/6844903874692661255 \"https://juejin.cn/post/6844903874692661255\")\n+   [为 Luy 实现 React Fiber 架构](https://juejin.cn/post/6844903608488558599#heading-12 \"https://juejin.cn/post/6844903608488558599#heading-12\")\n+   [妖僧风月: React Fiber](https://juejin.cn/post/6844903582622285831 \"https://juejin.cn/post/6844903582622285831\")\n+   [Flarnie Marchan - Ready for Concurrent Mode? 🎦](https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s \"https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s\")\n+   [Web Fundamentals > Performance](https://developers.google.com/web/fundamentals/performance/rendering \"https://developers.google.com/web/fundamentals/performance/rendering\")\n+   [你应该知道的requestIdleCallback](https://juejin.cn/post/6844903592831238157 \"https://juejin.cn/post/6844903592831238157\")\n+   [深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/ \"https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/\")\n+   [Accurately measuring layout on the web](https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/ \"https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/\")\n\n**自荐React 相关文章**\n\n回顾一下今年写的关于 React 的相关文章\n\n**Concurrent模式预览（推荐）**:\n\n+   [React Concurrent 模式抢先预览: Suspense 篇](https://juejin.cn/post/6844903981999718407#comment \"https://juejin.cn/post/6844903981999718407#comment\")\n+   [React Concurrent 模式抢先预览下篇: useTransition 的平行世界](https://juejin.cn/post/6844903986420514823 \"https://juejin.cn/post/6844903986420514823\")\n\n\n本文讲了 React 如何优化 CPU 问题，React 野心远不在于此, I/O 方向的优化也在实践，例如 Suspend... 还有很多没讲完，后面的文章见！\n\n问卷调查，你觉得这种文章风格怎样？\n\n+   A. 事无巨细，太啰嗦了\n+   B. 娓娓道来，深入浅出我喜欢\n+   C. 内容不够深入\n+   D. 文章篇幅太长，可以拆分\n\n多选，下方评论，👍点赞走起\n\n  \n\n> **改了一个正经一点的网名：*sx*(傻叉) -> 荒山 ⛰**\n\n  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16deecd38f465448~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)"
    },
    {
      "id": "完全理解React",
      "metadata": {
        "permalink": "/完全理解React",
        "source": "@site/blog/完全理解React.md",
        "title": "完全理解React",
        "description": "请输入描述",
        "date": "2023-08-28T07:51:35.947Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 24.52,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "完全理解React",
          "title": "完全理解React",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "这可能是最通俗的ReactFiber",
          "permalink": "/这可能是最通俗的ReactFiber"
        },
        "nextItem": {
          "title": "从源码剖析useState的执行过程",
          "permalink": "/从源码剖析useState的执行过程"
        }
      },
      "content": "## 一.目标\n\nFiber是对React核心算法的重构，2年重构的产物就是Fiber reconciler\n\n核心目标：扩大其*适用性*，包括动画，布局和手势。分为5个具体目标（后2个算送的）：\n\n+   把可中断的工作拆分成小任务\n    \n+   对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果\n    \n+   在父子任务之间从容切换（yield back and forth），以支持React执行过程中的布局刷新\n    \n+   支持`render()`返回多个元素\n    \n+   更好地支持error boundary\n    \n\n既然初衷是不希望JS不受控制地长时间执行（想要手动调度），那么，为什么JS长时间执行会影响交互响应、动画？\n\n> 因为JavaScript在浏览器的主线程上运行，恰好与样式计算、布局以及许多情况下的绘制一起运行。如果JavaScript运行时间过长，就会阻塞这些其他工作，可能导致掉帧。\n\n（引自[Optimize JavaScript Execution](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution#reduce_complexity_or_use_web_workers)）\n\nReact希望通过Fiber重构来改变这种不可控的现状，进一步提升交互体验\n\nP.S.关于Fiber目标的更多信息，请查看[Codebase Overview](https://reactjs.org/docs/codebase-overview.html#fiber-reconciler)\n\n## 二.关键特性\n\nFiber的关键特性如下：\n\n+   增量渲染（把渲染任务拆分成块，匀到多帧）\n    \n+   更新时能够暂停，终止，复用渲染任务\n    \n+   给不同类型的更新赋予优先级\n    \n+   并发方面新的基础能力\n    \n\n增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做cooperative scheduling（合作式调度），操作系统的3种任务调度策略之一（Firefox还对真实DOM应用了这项技术）\n\n另外，React自身的*killer feature*是virtual DOM，2个原因：\n\n+   coding UI变简单了（不用关心浏览器应该怎么做，而是把下一刻的UI描述给React听）\n    \n+   既然DOM能virtual，别的（硬件、VR、native App）也能\n    \n\nReact实现上分为2部分：\n\n+   reconciler 寻找某时刻前后两版UI的差异。包括之前的Stack reconciler与现在的Fiber reconciler\n    \n+   renderer 插件式的，平台相关的部分。包括React DOM、React Native、React ART、ReactHardware、ReactAframe、React-pdf、ReactThreeRenderer、ReactBlessed等等\n    \n\n这一波是对reconciler的彻底改造，对killer feature的增强\n\n## 三.fiber与fiber tree\n\nReact运行时存在3种实例：\n\n```auto\nDOM 真实DOM节点\n-------\nInstances React维护的vDOM tree node\n-------\nElements 描述UI长什么样子（type, props）\n```\n\nInstances是根据Elements创建的，对组件及DOM节点的抽象表示，vDOM tree维护了组件状态以及组件与DOM树的关系\n\n在首次渲染过程中构建出vDOM tree，后续需要更新时（`setState()`），diff vDOM tree得到DOM change，并把DOM change应用（patch）到DOM树\n\nFiber之前的reconciler（被称为Stack reconciler）自顶向下的递归`mount/update`，*无法中断*（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验\n\nFiber解决这个问题的*思路*是把渲染/更新过程（递归diff）拆分成一系列小任务，每次检查树上的一小部分，做完看是否还有时间继续下一个任务，有的话继续，没有的话把自己挂起，主线程不忙的时候再继续\n\n增量更新需要更多的上下文信息，之前的vDOM tree显然难以满足，所以扩展出了*fiber tree*（即Fiber上下文的vDOM tree），更新过程就是根据输入数据以及现有的fiber tree构造出新的fiber tree（workInProgress tree）。因此，Instance层新增了这些实例：\n\n```auto\nDOM\n    真实DOM节点\n-------\neffect\n    每个workInProgress tree节点上都有一个effect list\n    用来存放diff结果\n    当前节点更新完毕会向上merge effect list（queue收集diff结果）\n- - - -\nworkInProgress\n    workInProgress tree是reconcile过程中从fiber tree建立的当前进度快照，用于断点恢复\n- - - -\nfiber\n    fiber tree与vDOM tree类似，用来描述增量更新所需的上下文信息\n-------\nElements\n    描述UI长什么样子（type, props）\n```\n\n注意：放在虚线上的2层都是临时的结构，仅在更新时有用，日常不持续维护。*effect*指的就是side effect，包括将要做的DOM change\n\nfiber tree上各节点的主要结构（每个节点称为*fiber*）如下：\n\n```auto\n// fiber tree节点结构\n{\n    stateNode,\n    child,\n    return,\n    sibling,\n    ...\n}\n```\n\n`return`表示当前节点处理完毕后，应该向谁提交自己的成果（effect list）\n\nP.S.fiber tree实际上是个单链表（Singly Linked List）树结构，见[react/packages/react-reconciler/src/ReactFiber.js](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiber.js#L91)\n\nP.S.注意小fiber与大Fiber，前者表示fiber tree上的节点，后者表示React Fiber\n\n## 四.Fiber reconciler\n\nreconcile过程分为2个阶段（phase）：\n\n1.  （可中断）render/reconciliation 通过构造workInProgress tree得出change\n    \n2.  （不可中断）commit 应用这些DOM change\n    \n\n### render/reconciliation\n\n以fiber tree为蓝本，把每个fiber作为一个工作单元，自顶向下逐节点构造*workInProgress tree*（构建中的新fiber tree）\n\n具体过程如下（以组件节点为例）：\n\n1.  如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag\n    \n2.  更新当前节点状态（`props, state, context`等）\n    \n3.  调用`shouldComponentUpdate()`，`false`的话，跳到5\n    \n4.  调用`render()`获得新的子节点，并为子节点创建fiber（创建过程会尽量复用现有fiber，子节点增删也发生在这里）\n    \n5.  如果没有产生child fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元\n    \n6.  如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做\n    \n7.  如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态\n    \n\n实际上是1-6的*工作循环*，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）\n\n所以，构建workInProgress tree的过程就是diff的过程，通过`requestIdleCallback`来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次`requestIdleCallback`回调再继续构建workInProgress tree\n\nP.S.Fiber之前的reconciler被称为Stack reconciler，就是因为这些调度上下文信息是由系统栈来保存的。虽然之前一次性做完，强调栈没什么意义，起个名字只是为了便于区分Fiber reconciler\n\n#### requestIdleCallback\n\n> 通知主线程，要求在不忙的时候告诉我，我有几个不太着急的事情要做\n\n具体用法如下：\n\n```auto\nwindow.requestIdleCallback(callback[, options])\n// 示例\nlet handle = window.requestIdleCallback((idleDeadline) => {\n    const {didTimeout, timeRemaining} = idleDeadline;\n    console.log(`超时了吗？${didTimeout}`);\n    console.log(`可用时间剩余${timeRemaining.call(idleDeadline)}ms`);\n    // do some stuff\n    const now = +new Date, timespent = 10;\n    while (+new Date < now + timespent);\n    console.log(`花了${timespent}ms搞事情`);\n    console.log(`可用时间剩余${timeRemaining.call(idleDeadline)}ms`);\n}, {timeout: 1000});\n// 输出结果\n// 超时了吗？false\n// 可用时间剩余49.535000000000004ms\n// 花了10ms搞事情\n// 可用时间剩余38.64ms\n```\n\n*注意*，`requestIdleCallback`调度只是希望做到流畅体验，并不能绝对保证什么，例如：\n\n```auto\n// do some stuff\nconst now = +new Date, timespent = 300;\nwhile (+new Date < now + timespent);\n```\n\n如果搞事情（对应React中的生命周期函数等时间上不受React控制的东西）就花了300ms，什么机制也保证不了流畅\n\nP.S.一般剩余可用时间也就10-50ms，可调度空间不很宽裕\n\n### commit\n\n第2阶段直接一口气做完：\n\n1.  处理effect list（包括3种处理：更新DOM树、调用组件生命周期函数以及更新ref等内部状态）\n    \n2.  出对结束，第2阶段结束，所有更新都commit到DOM树上了\n    \n\n注意，真的是*一口气做完*（同步执行，不能喊停）的，这个阶段的实际工作量是比较大的，所以尽量不要在后3个生命周期函数里干重活儿\n\n### 生命周期hook\n\n生命周期函数也被分为2个阶段了：\n\n```auto\n// 第1阶段 render/reconciliation\ncomponentWillMount\ncomponentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\n\n// 第2阶段 commit\ncomponentDidMount\ncomponentDidUpdate\ncomponentWillUnmount\n```\n\n第1阶段的生命周期函数可能会被*多次调用*，默认以low优先级（后面介绍的6种优先级之一）执行，被高优先级任务打断的话，稍后重新执行\n\n## 五.fiber tree与workInProgress tree\n\n双缓冲技术（double buffering），就像[redux里的`nextListeners`](http://www.ayqy.net/blog/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#articleHeader7)，以fiber tree为主，workInProgress tree为辅\n\n双缓冲具体指的是workInProgress tree构造完毕，得到的就是新的fiber tree，然后喜新厌旧（把current指针指向workInProgress tree，丢掉旧的fiber tree）就好了\n\n这样做的好处：\n\n+   能够复用内部对象（fiber）\n    \n+   节省内存分配、GC的时间开销\n    \n\n每个fiber上都有个`alternate`属性，也指向一个fiber，创建workInProgress节点时优先取`alternate`，没有的话就创建一个：\n\n```auto\nlet workInProgress = current.alternate;\nif (workInProgress === null) {\n  //...这里很有意思\n  workInProgress.alternate = current;\n  current.alternate = workInProgress;\n} else {\n  // We already have an alternate.\n  // Reset the effect tag.\n  workInProgress.effectTag = NoEffect;\n\n  // The effect list is no longer valid.\n  workInProgress.nextEffect = null;\n  workInProgress.firstEffect = null;\n  workInProgress.lastEffect = null;\n}\n```\n\n如注释指出的，fiber与workInProgress互相持有引用，“喜新厌旧”之后，旧fiber就作为新fiber更新的*预留空间*，达到复用fiber实例的目的\n\nP.S.源码里还有一些有意思的技巧，比如[tag的位运算](http://makersden.io/blog/look-inside-fiber/#side-effect-tags-types-of-side-effects)\n\n## 六.优先级策略\n\n每个工作单元运行时有6种优先级：\n\n+   synchronous 与之前的Stack reconciler操作一样，同步执行\n    \n+   task 在next tick之前执行\n    \n+   animation 下一帧之前执行\n    \n+   high 在不久的将来立即执行\n    \n+   low 稍微延迟（100-200ms）执行也没关系\n    \n+   offscreen 下一次render时或scroll时才执行\n    \n\nsynchronous首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。animation通过`requestAnimationFrame`来调度，这样在下一帧就能立即开始动画过程；后3个都是由`requestIdleCallback`回调执行的；offscreen指的是当前隐藏的、屏幕外的（看不见的）元素\n\n高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，*紧急的事件允许插队*\n\n这样的优先级机制存在*2个问题*：\n\n+   生命周期函数怎么执行（可能被频频中断）：触发顺序、次数没有保证了\n    \n+   starvation（低优先级饿死）：如果高优先级任务很多，那么低优先级任务根本没机会执行（就饿死了）\n    \n\n生命周期函数的问题有一个官方例子：\n\n```auto\nlow A\ncomponentWillUpdate()\n---\nhigh B\ncomponentWillUpdate()\ncomponentDidUpdate()\n---\nrestart low A\ncomponentWillUpdate()\ncomponentDidUpdate()\n```\n\n第1个问题正在解决（还没解决），生命周期的问题会破坏一些现有App，给平滑升级带来困难，Fiber团队正在努力寻找优雅的升级途径\n\n第2个问题通过尽量复用已完成的操作（reusing work where it can）来缓解，听起来也是正在想办法解决\n\n这两个问题本身不太好解决，只是解决到什么程度的问题。比如第一个问题，如果组件生命周期函数掺杂副作用太多，就没有办法无伤解决。这些问题虽然会给升级Fiber带来一定阻力，但绝不是不可解的（退一步讲，如果新特性有足够的吸引力，第一个问题大家自己想办法就解决了）\n\n## 七.总结\n\n### 已知\n\nReact在一些响应体验要求较高的场景不适用，比如动画，布局和手势\n\n根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验\n\n### 求\n\n一种能够彻底解决主线程长时间占用问题的机制，不仅能够应对眼前的问题，还要有长远意义\n\n> The “fiber” reconciler is a new effort aiming to resolve the problems inherent in the stack reconciler and fix a few long-standing issues.\n\n### 解\n\n把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）\n\n那么，面临5个子问题：\n\n#### 1.拆什么？什么不能拆？\n\n把渲染/更新过程分为2个阶段（diff + patch）：\n\n```auto\n1.diff ~ render/reconciliation\n2.patch ~ commit\n```\n\ndiff的实际工作是对比`prevInstance`和`nextInstance`的状态，找出差异及其对应的DOM change。diff本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）\n\npatch阶段把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。这些DOM操作虽然看起来也可以拆分（按照change list一段一段做），但这样做一方面可能造成DOM实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM更新的耗时比起diff及生命周期函数耗时不算什么，拆分的意义不很大\n\n所以，render/reconciliation阶段的工作（diff）可以拆分，commit阶段的工作（patch）不可拆分\n\nP.S.diff与reconciliation只是对应关系，并不等价，如果非要区分的话，reconciliation包括diff：\n\n> This is a part of the process that React calls reconciliation which starts when you call ReactDOM.render() or setState(). By the end of the reconciliation, React knows the result DOM tree, and a renderer like react-dom or react-native applies the minimal set of changes necessary to update the DOM nodes (or the platform-specific views in case of React Native).\n\n（引自[Top-Down Reconciliation](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#top-down-reconciliation)）\n\n#### 2.怎么拆？\n\n先凭空乱来几种diff工作拆分方案：\n\n+   按组件结构拆。不好分，无法预估各组件更新的工作量\n    \n+   按实际工序拆。比如分为`getNextState(), shouldUpdate(), updateState(), checkChildren()`再穿插一些生命周期函数\n    \n\n按组件拆太粗，显然对大组件不太公平。按工序拆太细，任务太多，频繁调度不划算。那么有没有合适的拆分单位？\n\n有。Fiber的拆分单位是fiber（fiber tree上的一个节点），实际上就是*按虚拟DOM节点拆*，因为fiber tree是根据vDOM tree构造出来的，树结构一模一样，只是节点携带的信息有差异\n\n所以，实际上是vDOM node粒度的拆分（以fiber为工作单元），每个组件实例和每个DOM节点抽象表示的实例都是一个工作单元。工作循环中，每次处理一个fiber，处理完可以中断/挂起整个工作循环\n\n#### 3.如何调度任务？\n\n分2部分：\n\n+   工作循环\n    \n+   优先级机制\n    \n\n工作循环是*基本的任务调度机制*，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会：\n\n```auto\n// Flush asynchronous work until the deadline runs out of time.\nwhile (nextUnitOfWork !== null && !shouldYield()) {\n  nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n}\n```\n\n`shouldYield`就是看时间用完了没（`idleDeadline.timeRemaining()`），没用完的话继续处理下一个任务，用完了就结束，把时间控制权还给主线程，等下一次`requestIdleCallback`回调再接着做：\n\n```auto\n// If there's work left over, schedule a new callback.\nif (nextFlushedExpirationTime !== NoWork) {\n  scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n}\n```\n\n也就是说，（不考虑突发事件的）正常调度是由工作循环来完成的，基本*规则*是：每个工作单元结束检查是否还有时间做下一个，没时间了就先“挂起”\n\n优先级机制用来处理突发事件与优化次序，例如：\n\n+   到commit阶段了，提高优先级\n    \n+   高优任务做一半出错了，给降一下优先级\n    \n+   抽空关注一下低优任务，别给饿死了\n    \n+   如果对应DOM节点此刻不可见，给降到最低优先级\n    \n\n这些策略用来动态调整任务调度，是工作循环的*辅助机制*，最先做最重要的事情\n\n#### 4.如何中断/断点恢复？\n\n中断：检查当前正在处理的工作单元，保存当前成果（`firstEffect, lastEffect`），修改tag标记一下，迅速收尾并再开一个`requestIdleCallback`，下次有机会再做\n\n断点恢复：下次再处理到该工作单元时，看tag是被打断的任务，接着做未完成的部分或者重做\n\nP.S.无论是时间用尽“自然”中断，还是被高优任务粗暴打断，对中断机制来说都一样\n\n#### 5.如何收集任务结果？\n\nFiber reconciliation的工作循环具体如下：\n\n1.  找到根节点优先级最高的workInProgress tree，取其待处理的节点（代表组件或DOM节点）\n    \n2.  检查当前节点是否需要更新，不需要的话，直接到4\n    \n3.  标记一下（打个tag），更新自己（组件更新`props`，`context`等，DOM节点记下DOM change），并为孩子生成workInProgress node\n    \n4.  如果没有产生子节点，归并effect list（包含DOM change）到父级\n    \n5.  把孩子或兄弟作为待处理节点，准备进入下一个工作循环。如果没有待处理节点（回到了workInProgress tree的根节点），工作循环结束\n    \n\n通过每个节点更新结束时*向上归并effect list*来收集任务结果，reconciliation结束后，根节点的effect list里记录了包括DOM change在内的所有side effect\n\n### 举一反三\n\n既然任务可拆分（只要最终得到完整effect list就行），那就允许*并行执行*（多个Fiber reconciler + 多个worker），首屏也更容易分块加载/渲染（vDOM森林）\n\n并行渲染的话，据说Firefox测试结果显示，130ms的页面，只需要30ms就能搞定，所以在这方面是值得期待的，而React已经做好准备了，这也就是在React Fiber上下文经常听到的待*unlock*的更多特性之一\n\n## 八.源码简析\n\n从15到16，源码结构发生了很大变化：\n\n+   再也看不到`mountComponent/updateComponent()`了，被拆分重组成了（`beginWork/completeWork/commitWork()`）\n    \n+   [ReactDOMComponent](https://github.com/facebook/react/blob/v16.0.0/src/renderers/dom/stack/client/ReactDOMComponent.js#L384)也被去掉了，在Fiber体系下DOM节点抽象用[ReactDOMFiberComponent](https://github.com/facebook/react/blob/v16.2.0/packages/react-dom/src/client/ReactDOMFiberComponent.js#L353)表示，组件用[ReactFiberClassComponent](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberClassComponent.js#L78)表示，之前是[ReactCompositeComponent](https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L126)\n    \n+   Fiber体系的核心机制是负责任务调度的[ReactFiberScheduler](https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiberScheduler.js)，相当于之前的[ReactReconciler](https://github.com/facebook/react/blob/v15.6.2/src/renderers/shared/stack/reconciler/ReactReconciler.js)\n    \n+   vDOM tree变成fiber tree了，以前是自上而下的简单树结构，现在是基于单链表的树结构，维护的节点关系更多一些\n    \n\nfiber tree来张图感受一下：\n\n[![fiber-tree](http://cdn.ayqy.net/data/home/qxu1001840309/htdocs/cms/wordpress/wp-content/uploads/2018/01/fiber-tree.png)](http://cdn.ayqy.net/data/home/qxu1001840309/htdocs/cms/wordpress/wp-content/uploads/2018/01/fiber-tree.png)\n\nfiber-tree\n\n其实稍一细想，从Stack reconciler到Fiber reconciler，源码层面就是干了一件*递归改循环*的事情（当然，实际做的事情远不止递归改循环，但这是第一步）\n\n总之，源码变化很大，如果对Fiber思路没有预先了解的话，看源码会比较*艰难*（看过React\\[15-\\]的源码的话，就更容易迷惑了）\n\nP.S.这张[清明流程图](https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/stack/images/intro/all-page-stack-reconciler.svg)要正式退役了\n\n### 参考资料\n\n+   [Lin Clark – A Cartoon Intro to Fiber – React Conf 2017](https://www.youtube.com/watch?v=ZCuYPiUIONs)：*5星推荐*，声音很好听，比Jing Chen好100倍\n    \n+   [acdlite/react-fiber-architecture](https://github.com/acdlite/react-fiber-architecture)\n    \n+   [Codebase Overview](https://reactjs.org/docs/codebase-overview.html)\n    \n+   [A look inside React Fiber – how work will get done.](http://makersden.io/blog/look-inside-fiber/)：Fiber源码解读，小说体看着有点费劲"
    },
    {
      "id": "从源码剖析useState的执行过程",
      "metadata": {
        "permalink": "/从源码剖析useState的执行过程",
        "source": "@site/blog/从源码剖析useState的执行过程.md",
        "title": "从源码剖析useState的执行过程",
        "description": "请输入描述",
        "date": "2023-08-28T07:50:35.036Z",
        "formattedDate": "2023年8月28日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 23.81,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师"
          }
        ],
        "frontMatter": {
          "slug": "从源码剖析useState的执行过程",
          "title": "从源码剖析useState的执行过程",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React"
          ]
        },
        "prevItem": {
          "title": "完全理解React",
          "permalink": "/完全理解React"
        },
        "nextItem": {
          "title": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
          "permalink": "/浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案"
        }
      },
      "content": "**长文预警，如果觉得前戏太长可直接从第三章开始看~**\n\n本文基于 [React 16.8.6](https://github.com/facebook/react/tree/v16.8.6 \"https://github.com/facebook/react/tree/v16.8.6\") 进行讲解\n\n使用的示例代码：\n\n```jsx\nimport React, { useState } from 'react'\nimport './App.css'\n\nexport default function App() {\n  \n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Star');\n  \n  // 调用三次setCount便于查看更新队列的情况\n  const countPlusThree = () => {\n    setCount(count+1);\n    setCount(count+2);\n    setCount(count+3);\n  }\n  return (\n    <div className='App'>\n      <p>{name} Has Clicked <strong>{count}</strong> Times</p>\n      <button onClick={countPlusThree}>Click *3</button>\n    </div>\n  )\n}\n```\n\n代码非常简单，点击button使count+3，count的值会显示在屏幕上。\n\n![Jietu20190419-090633@2x.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5bf9094d7f0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n## 一. 前置知识\n\n### 1\\. 函数组件和类组件\n\n> 本节参考：[How Are Function Components Different from Classes?](https://overreacted.io/how-are-function-components-different-from-classes/ \"https://overreacted.io/how-are-function-components-different-from-classes/\")\n\n**本节主要概念：**\n\n+   函数组件和类组件的区别\n+   React如何区分这两种组件\n\n我们来看一个简单的Greeting组件，它支持定义成类和函数两种性质。在使用它时，不用关心他是如何定义的。\n\n```jsx\n// 是类还是函数 —— 无所谓\n<Greeting />  // <p>Hello</p>\n```\n\n如果 `Greeting` 是一个函数，React 需要调用它。\n\n```jsx\n// Greeting.js\nfunction Greeting() {\n  return <p>Hello</p>;\n}\n\n// React 内部\nconst result = Greeting(props); // <p>Hello</p>\n```\n\n但如果 `Greeting` 是一个类，React 需要先将其实例化，再调用刚才生成实例的 `render` 方法：\n\n```jsx\n// Greeting.js\nclass Greeting extends React.Component {\n  render() {\n    return <p>Hello</p>;\n  }\n}\n\n// React 内部\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // <p>Hello</p>\n```\n\n**React通过以下方式来判断组件的类型：**\n\n```jsx\n// React 内部\nclass Component {}\nComponent.prototype.isReactComponent = {};\n\n// 检查方式\nclass Greeting extends React.Component {}\nconsole.log(Greeting.prototype.isReactComponent); // {}\n```\n\n### 2\\. React Fiber\n\n> 本节参考：[A cartoon intro to fiber](https://www.youtube.com/watch?v=ZCuYPiUIONs&list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&index=5 \"https://www.youtube.com/watch?v=ZCuYPiUIONs&list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&index=5\")\n\n**本节主要概念（了解即可）：**\n\n+   React现在的渲染都是由Fiber来调度\n+   Fiber调度过程中的两个阶段(以Render为界)\n\nFiber（可译为丝）比线程还细的控制粒度，是React 16中的新特性，旨在对渲染过程做更精细的调整。\n\n**产生原因：**\n\n1.  Fiber之前的reconciler（被称为Stack reconciler）自顶向下的递归`mount/update`，无法中断（持续占用主线程），这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，影响体验\n2.  渲染过程中没有优先级可言\n\n**React Fiber的方式：**\n\n把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。\n\nReact Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。\n\n维护每一个分片的数据结构，就是Fiber。\n\n有了分片之后，更新过程的调用栈如下图所示，中间每一个波谷代表深入某个分片的执行过程，每个波峰就是一个分片执行结束交还控制权的时机。让线程处理别的事情  \n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5c351497594~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**Fiber的调度过程分为以下两个阶段：**\n\n**render/reconciliation阶段** — 里面的所有生命周期函数都可能被执行多次，所以尽量保证状态不变\n\n+   componentWillMount\n+   componentWillReceiveProps\n+   shouldComponentUpdate\n+   componentWillUpdate\n\n**Commit阶段** — 不能被打断，只会执行一次\n\n+   componentDidMount\n+   componentDidUpdate\n+   compoenntWillunmount\n\nFiber的增量更新需要更多的上下文信息，之前的vDOM tree显然难以满足，所以扩展出了fiber tree（即Fiber上下文的vDOM tree），更新过程就是根据输入数据以及现有的fiber tree构造出新的fiber tree（workInProgress tree）\n\n与Fiber有关的所有代码位于[packages/react-reconciler](https://github.com/facebook/react/tree/v16.8.6/packages/react-reconciler \"https://github.com/facebook/react/tree/v16.8.6/packages/react-reconciler\")中，一个Fiber节点的详细定义如下：\n\n```javascript\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag; this.key = key; this.elementType = null; \n  this.type = null; this.stateNode = null;\n\n  // Fiber\n  this.return = null; this.child = null; this.sibling = null; \n  this.index = 0; this.ref = null; this.pendingProps = pendingProps;\n  this.memoizedProps = null; this.updateQueue = null;\n  \n  // 重点\n  this.memoizedState = null;\n  \n  this.contextDependencies = null; this.mode = mode;\n\n  // Effects\n  /** 细节略 **/\n}\n```\n\n我们只关注一下`this.memoizedState`\n\n**这个`key`用来存储在上次渲染过程中最终获得的节点的`state`，每次`render`之前，React会计算出当前组件最新的`state`然后赋值给组件，再执行`render`。**— 类组件和使用useState的函数组件均适用。\n\n记住上面这句话，后面还会经常提到memoizedState\n\n> 有关Fiber每个key的具体含义可以参见[源码的注释](https://github.com/facebook/react/blob/487f4bf2ee7c86176637544c5473328f96ca0ba2/packages/react-reconciler/src/ReactFiber.js#L84-L218 \"https://github.com/facebook/react/blob/487f4bf2ee7c86176637544c5473328f96ca0ba2/packages/react-reconciler/src/ReactFiber.js#L84-L218\")\n\n### 3\\. React渲染器与setState\n\n> 本节参考：[How Does setState Know What to Do?](https://overreacted.io/how-does-setstate-know-what-to-do/ \"https://overreacted.io/how-does-setstate-know-what-to-do/\")\n\n**本节主要概念：**\n\n+   React渲染器是什么\n+   setState为什么能够触发更新\n\n**由于React体系的复杂性以及目标平台的多样性。`react`包只暴露一些定义组件的API。绝大多数React的实现都存在于 渲染器（renderers）中。**\n\n`react-dom`、`react-dom/server`、 `react-native`、 `react-test-renderer`、 `react-art`都是常见的渲染器\n\n这就是为什么不管目标平台是什么，`react`包都是可用的。从`react`包中导出的一切，比如`React.Component`、`React.createElement`、 `React.Children` 和 `Hooks`都是独立于目标平台的。无论运行React DOM，还是 React DOM Server,或是 React Native，组件都可以使用同样的方式导入和使用。\n\n所以当我们想使用新特性时，`react` 和 `react-dom`都需要被更新。\n\n> 例如，当React 16.3添加了Context API，`React.createContext()`API会被React包暴露出来。 但是`React.createContext()` 其实并没有\\_实现\\_ context。因为在React DOM 和 React DOM Server 中同样一个 API 应当有不同的实现。所以`createContext()`只返回了一些普通对象： \\*\\*所以，如果你将react升级到了16.3+，但是不更新react-dom，那么你就使用了一个尚不知道Provider 和 Consumer类型的渲染器。\\*\\*这就是为什么老版本的`react-dom`会[报错说这些类型是无效的](https://stackoverflow.com/a/49677020/458193 \"https://stackoverflow.com/a/49677020/458193\")。\n\n这就是`setState` 尽管定义在React包中，调用时却能够更新DOM的原因。它读取由React DOM设置的`this.updater`，让React DOM安排并处理更新。\n\n```js\nComponent.setState = function(partialState, callback) {\n  // setState所做的一切就是委托渲染器创建这个组件的实例\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n```\n\n各个渲染器中的updater触发不同平台的更新渲染\n\n```js\n// React DOM 内部\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactDOMUpdater;\n\n// React DOM Server 内部\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactDOMServerUpdater;\n\n// React Native 内部\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactNativeUpdater;\n```\n\n至于updater的具体实现，就不是这里重点要讨论的内容了，下面让我们正式进入本文的主题：React Hooks\n\n## 二. 了解useState\n\n### 1\\. useState的引入和触发更新\n\n**本节主要概念：**\n\n+   useState是如何被引入以及调用的\n+   useState为什么能触发组件更新\n\n所有的Hooks在`React.js`中被引入，挂载在React对象中\n\n```javascript\n// React.js\nimport {\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from './ReactHooks';\n```\n\n我们进入`ReactHooks.js`来看看，发现`useState`的实现竟然异常简单，只有短短两行\n\n```javascript\n// ReactHooks.js\nexport function useState<S>(initialState: (() => S) | S) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n```\n\n看来重点都在这个`dispatcher`上，`dispatcher`通过`resolveDispatcher()`来获取，这个函数同样也很简单，只是将`ReactCurrentDispatcher.current`的值赋给了`dispatcher`\n\n```javascript\n// ReactHooks.js\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n  return dispatcher;\n}\n```\n\n所以`useState(xxx)` 等价于 `ReactCurrentDispatcher.current.useState(xxx)`\n\n看到这里，我们回顾一下第一章第三小节所讲的React渲染器与setState，是不是发现有点似曾相识。\n\n与updater是setState能够触发更新的核心类似，`ReactCurrentDispatcher.current.useState`是`useState`能够触发更新的关键原因，这个方法的实现并不在react包内。下面我们就来分析一个具体更新的例子。\n\n### 2\\. 示例分析\n\n以全文开头给出的代码为例。\n\n我们从Fiber调度的开始：`ReactFiberBeginwork`来谈起\n\n之前已经说过，React有能力区分不同的组件，所以它会给不同的组件类型打上不同的tag， 详见[shared/ReactWorkTags.js](https://github.com/facebook/react/blob/v16.8.6/packages/shared/ReactWorkTags.js \"https://github.com/facebook/react/blob/v16.8.6/packages/shared/ReactWorkTags.js\")。\n\n所以在beginWork的函数中，就可以根据workInProgess(就是个Fiber节点)上的tag值来走不同的方法来加载或者更新组件。\n\n```javascript\n// ReactFiberBeginWork.js\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  /** 省略与本文无关的部分 **/\n\n  // 根据不同的组件类型走不同的方法\n  switch (workInProgress.tag) {\n    // 不确定组件\n    case IndeterminateComponent: {\n      const elementType = workInProgress.elementType;\n      // 加载初始组件\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        elementType,\n        renderExpirationTime,\n      );\n    }\n    // 函数组件\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      // 更新函数组件\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // 类组件\n    case ClassComponent {\n      /** 细节略 **/\n  \t}\n  }\n```\n\n下面我们来找出useState发挥作用的地方。\n\n#### 2.1 第一次加载\n\nmount过程执行`mountIndeterminateComponent`时，会执行到`renderWithHooks`这个函数\n\n```javascript\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderExpirationTime,\n) {\n \n /** 省略准备阶段代码 **/ \n  \n  // value就是渲染出来的APP组件\n  let value;\n\n  value = renderWithHooks(\n    null,\n    workInProgress,\n    Component,\n    props,\n    context,\n    renderExpirationTime,\n  );\n  /** 省略无关代码 **/ \n  }\n  workInProgress.tag = FunctionComponent;\n  reconcileChildren(null, workInProgress, value, renderExpirationTime);\n  return workInProgress.child;\n}\n```\n\n**执行前：** nextChildren = value\n\n![11.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5d14a94b351~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**执行后：** value= 组件的虚拟DOM表示\n\n![12.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5d14a94b351~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**至于这个value是如何被渲染成真实的DOM节点，我们并不关心，state值我们已经通过renderWithHooks取到并渲染**\n\n#### 2.2 更新\n\n点击一下按钮：此时count从0变为3\n\n更新过程执行的是updateFunctionComponent函数，同样会执行到renderWithHooks这个函数，我们来看一下这个函数执行前后发生的变化：\n\n**执行前：** nextChildren = undefined\n\n![13.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5d7c00bb593~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n\\*\\*执行后：\\*\\*nextChildren=更新后的组件的虚拟DOM表示\n\n![14.jpg](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5d9fb21e17c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**同样的，至于这个nextChildren是如何被渲染成真实的DOM节点，我们并不关心，最新的state值我们已经通过renderWithHooks取到并渲染**\n\n**所以，`renderWithHooks`函数就是处理各种hooks逻辑的核心部分**\n\n## 三. 核心步骤分析\n\n[ReactFiberHooks.js](https://github.com/facebook/react/blob/v16.8.6/packages/react-reconciler/src/ReactFiberHooks.js \"https://github.com/facebook/react/blob/v16.8.6/packages/react-reconciler/src/ReactFiberHooks.js\")包含着各种关于Hooks逻辑的处理，本章中的代码均来自该文件。\n\n### 1\\. Hook对象\n\n在之前的章节有介绍过，Fiber中的`memorizedStated`用来存储state\n\n在类组件中`state`是一整个对象，可以和`memoizedState`一一对应。但是在`Hooks`中，React并不知道我们调用了几次`useState`，**所以React通过将一个Hook对象挂载在`memorizedStated`上来保存函数组件的`state`**\n\nHook对象的结构如下：\n\n```javascript\n// ReactFiberHooks.js\nexport type Hook = {\n  memoizedState: any, \n\n  baseState: any,    \n  baseUpdate: Update<any, any> | null,  \n  queue: UpdateQueue<any, any> | null,  \n\n  next: Hook | null, \n};\n```\n\n重点关注`memoizedState`和`next`\n\n+   `memoizedState`是用来记录当前`useState`应该返回的结果的\n+   `queue`：缓存队列，存储多次更新行为\n+   `next`：指向下一次`useState`对应的Hook对象。\n\n结合示例代码来看：\n\n```jsx\nimport React, { useState } from 'react'\nimport './App.css'\n\nexport default function App() {\n  \n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('Star');\n  \n  // 调用三次setCount便于查看更新队列的情况\n  const countPlusThree = () => {\n    setCount(count+1);\n    setCount(count+2);\n    setCount(count+3);\n  }\n  return (\n    <div className='App'>\n      <p>{name} Has Clicked <strong>{count}</strong> Times</p>\n      <button onClick={countPlusThree}>Click *3</button>\n    </div>\n  )\n}\n```\n\n第一次点击按钮触发更新时，memoizedState的结构如下\n\n![Jietu20190419-100634@2x.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5de6dd38821~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n只是符合之前对Hook对象结构的分析，只是queue中的结构貌似有点奇怪，我们将在第三章第2节中进行分析。\n\n### 2\\. renderWithHooks\n\nrenderWithHooks的运行过程如下：\n\n```javascript\n// ReactFiberHooks.js\nexport function renderWithHooks(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime,\n): any {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n \n  // 如果current的值为空，说明还没有hook对象被挂载\n  // 而根据hook对象结构可知，current.memoizedState指向下一个current\n  nextCurrentHook = current !== null ? current.memoizedState : null;\n\n  // 用nextCurrentHook的值来区分mount和update，设置不同的dispatcher\n  ReactCurrentDispatcher.current =\n      nextCurrentHook === null\n      // 初始化时\n        ? HooksDispatcherOnMount\n  \t\t// 更新时\n        : HooksDispatcherOnUpdate;\n  \n  // 此时已经有了新的dispatcher,在调用Component时就可以拿到新的对象\n  let children = Component(props, refOrContext);\n  \n  // 重置\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  const renderedWork: Fiber = (currentlyRenderingFiber: any);\n\n  // 更新memoizedState和updateQueue\n  renderedWork.memoizedState = firstWorkInProgressHook;\n  renderedWork.updateQueue = (componentUpdateQueue: any);\n  \n   /** 省略与本文无关的部分代码，便于理解 **/\n}\n```\n\n#### 2.1 初始化时\n\n**核心：** 创建一个新的hook，初始化state， 并绑定触发器\n\n初始化阶段`ReactCurrentDispatcher.current` 会指向`HooksDispatcherOnMount` 对象\n\n```js\n// ReactFiberHooks.js\n\nconst HooksDispatcherOnMount: Dispatcher = {\n/** 省略其它Hooks **/\n  useState: mountState,\n};\n\n// 所以调用useState(0)返回的就是HooksDispatcherOnMount.useState(0)，也就是mountState(0)\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n    // 访问Hook链表的下一个节点，获取到新的Hook对象\n  const hook = mountWorkInProgressHook();\n//如果入参是function则会调用，但是不提供参数\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n// 进行state的初始化工作\n  hook.memoizedState = hook.baseState = initialState;\n// 进行queue的初始化工作\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    eagerReducer: basicStateReducer, // useState使用基础reducer\n    eagerState: (initialState: any),\n  });\n\t// 返回触发器\n  const dispatch: Dispatch<BasicStateAction<S>,> \n    = (queue.dispatch = (dispatchAction.bind(\n    \tnull,\n    \t//绑定当前fiber结点和queue\n    \t((currentlyRenderingFiber: any): Fiber),\n    \tqueue,\n  ));\n  // 返回初始state和触发器\n  return [hook.memoizedState, dispatch];\n}\n\n// 对于useState触发的update action来说（假设useState里面都传的变量），basicStateReducer就是直接返回action的值\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n```\n\n重点讲一下返回的这个更新函数 `dispatchAction`\n\n```js\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n\n   /** 省略Fiber调度相关代码 **/\n  \n  // 创建新的新的update, action就是我们setCount里面的值(count+1, count+2, count+3…)\n    const update: Update<S, A> = {\n      expirationTime,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n\t  \n    // 重点：构建query\n    // queue.last是最近的一次更新，然后last.next开始是每一次的action\n    const last = queue.last;\n    if (last === null) {\n      // 只有一个update, 自己指自己-形成环\n      update.next = update;\n    } else {\n      const first = last.next;\n      if (first !== null) {\n        \n        update.next = first;\n      }\n      last.next = update;\n    }\n    queue.last = update;\n\n    /** 省略特殊情况相关代码 **/\n    \n    // 创建一个更新任务\n    scheduleWork(fiber, expirationTime);\n\n}\n```\n\n在`dispatchAction`中维护了一份query的数据结构。\n\nquery是一个有环链表，规则：\n\n+   query.last指向最近一次更新\n+   last.next指向第一次更新\n+   后面就依次类推，最终倒数第二次更新指向last，形成一个环。\n\n**所以每次插入新update时，就需要将原来的first指向query.last.next。再将update指向query.next，最后将query.last指向update.**\n\n下面结合示例代码来画图说明一下：\n\n前面给出了第一次点击按钮更新时，memorizedState中的query值  \n\n![Jietu20190419-130310@2x.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5e40929acc0~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n其构建过程如下图所示：\n\n![Jietu20190430-155220@2x.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5e851fc2ee3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n**即保证query.last始终为最新的action, 而query.last.next始终为action: 1**\n\n#### 2.2 更新时\n\n**核心**：获取该Hook对象中的 queue，内部存有本次更新的一系列数据，进行更新\n\n更新阶段 `ReactCurrentDispatcher.current` 会指向`HooksDispatcherOnUpdate`对象\n\n```javascript\n// ReactFiberHooks.js\n\n// 所以调用useState(0)返回的就是HooksDispatcherOnUpdate.useState(0)，也就是updateReducer(basicStateReducer, 0)\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  /** 省略其它Hooks **/\n   useState: updateState,\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\n// 可以看到updateReducer的过程与传的initalState已经无关了，所以初始值只在第一次被使用\n\n// 为了方便阅读，删去了一些无关代码\n// 查看完整代码：https://github.com/facebook/react/blob/487f4bf2ee7c86176637544c5473328f96ca0ba2/packages/react-reconciler/src/ReactFiberHooks.js#L606\nfunction updateReducer(reducer, initialArg, init) {\n// 获取初始化时的 hook\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  // 开始渲染更新\n  if (numberOfReRenders > 0) {\n    const dispatch = queue.dispatch;\n    if (renderPhaseUpdates !== null) {\n      // 获取Hook对象上的 queue，内部存有本次更新的一系列数据\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        // 获取更新后的state\n        do {\n          const action = update.action;\n          // 此时的reducer是basicStateReducer，直接返回action的值\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null);\n        // 对 更新hook.memoized \n        hook.memoizedState = newState;\n        // 返回新的 state，及更新 hook 的 dispatch 方法\n        return [newState, dispatch];\n      }\n    }\n  }\n  \n// 对于useState触发的update action来说（假设useState里面都传的变量），basicStateReducer就是直接返回action的值\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n```\n\n#### 2.3 总结\n\n单个hooks的更新行为全都挂在Hooks.queue下，所以能够管理好queue的核心就在于\n\n+   初始化queue - mountState\n+   维护queue - dispatchAction\n+   更新queue - updateReducer\n\n**结合示例代码：**\n\n+   当我们第一次调用`[count, setCount] = useState(0)`时，创建一个queue\n+   每一次调用`setCount(x)`，就dispach一个内容为x的action（action的表现为：将count设为x)，action存储在queue中，以前面讲述的有环链表规则来维护\n+   这些action最终在`updateReducer`中被调用，更新到`memorizedState`上，使我们能够获取到最新的state值。\n\n## 四. 总结\n\n### 1\\. 对官方文档中Rules of Hooks的理解\n\n[官方文档](https://reactjs.org/docs/hooks-rules.html \"https://reactjs.org/docs/hooks-rules.html\")对于使用hooks有以下两点要求：\n\n![Jietu20190418-094347@2x.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/30/16a6d5ec8ed212b5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)\n\n#### 2.1 为什么不能在循环/条件语句中执行\n\n**以useState为例：**\n\n和类组件存储state不同，React并不知道我们调用了几次`useState`，对hooks的存储是按顺序的(参见Hook结构)，一个hook对象的next指向下一个hooks。所以当我们建立示例代码中的对应关系后，Hook的结构如下：\n\n```javascript\n// hook1: const [count, setCount] = useState(0) — 拿到state1\n{\n  memorizedState: 0\n  next : {\n    // hook2: const [name, setName] = useState('Star') - 拿到state2\n    memorizedState: 'Star'\n    next : {\n      null\n    }\n  }\n}\n\n// hook1 => Fiber.memoizedState\n// state1 === hook1.memoizedState\n// hook1.next => hook2\n// state2 === hook2.memoizedState\n```\n\n所以如果把hook1放到一个if语句中，当这个没有执行时，hook2拿到的state其实是上一次hook1执行后的state（而不是上一次hook2执行后的）。这样显然会发生错误。\n\n> 关于这块内容如果想了解更多可以看一下[这篇文章](https://medium.com/the-guild/under-the-hood-of-reacts-hooks-system-eb59638c9dba \"https://medium.com/the-guild/under-the-hood-of-reacts-hooks-system-eb59638c9dba\")\n\n#### 2.2 为什么只能在函数组件中使用hooks\n\n只有函数组件的更新才会触发renderWithHooks函数，处理Hooks相关逻辑。\n\n**还是以setState为例，类组件和函数组件重新渲染的逻辑不同 ：**\n\n**类组件：** 用setState触发updater，重新执行组件中的render方法\n\n**函数组件：** 用useState返回的setter函数来dispatch一个update action，触发更新(dispatchAction最后的scheduleWork)，用updateReducer处理更新逻辑，返回最新的state值(与Redux比较像)\n\n### 2\\. useState整体运作流程总结\n\n说了这么多，最后再简要总结下useState的执行流程~\n\n**初始化：** 构建dispatcher函数和初始值\n\n**更新时：**\n\n1.  调用dispatcher函数，按序插入update(其实就是一个action)\n2.  收集update，调度一次React的更新\n3.  在更新的过程中将`ReactCurrentDispatcher.current`指向负责更新的Dispatcher\n4.  执行到函数组件App()时，`useState`会被重新执行，在resolve dispatcher的阶段拿到了负责更新的dispatcher。\n5.  `useState`会拿到Hook对象，`Hook.query`中存储了更新队列，依次进行更新后，即可拿到最新的state\n6.  函数组件App()执行后返回的nextChild中的count值已经是最新的了。FiberNode中的`memorizedState`也被设置为最新的state\n7.  Fiber渲染出真实DOM。更新结束。"
    },
    {
      "id": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
      "metadata": {
        "permalink": "/浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
        "source": "@site/blog/2023-06-19浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案.md",
        "title": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
        "description": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
        "date": "2023-06-19T00:00:00.000Z",
        "formattedDate": "2023年6月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          }
        ],
        "readingTime": 3.38,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
          "title": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
          "tags": [
            "前端",
            "javascript"
          ]
        },
        "prevItem": {
          "title": "从源码剖析useState的执行过程",
          "permalink": "/从源码剖析useState的执行过程"
        },
        "nextItem": {
          "title": "vue3中子父组件传值通信的9种方法",
          "permalink": "/vue3中子父组件传值通信的9种方法"
        }
      },
      "content": "![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a54b1f3f147a4fb5b7ab0378b372ab1a~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 1 需求描述\n\n最近遇到一个需求，就是前端页面要实时监听后端传过来的数据，同时当后端传过来这条数据时前端界面要语音播报这条数据。\n\n## 2 分析与解决方案\n\n这里主要说说语音播报的部分。本来觉得用浏览器自带的 API 来实现直接写一句话就 ok 了，但是没想到居然有一个 bug。那就是这条语音有时候能播报，有时候就没有声音了？为什么呢，**查了半天，是浏览器的安全限制的问题，需要用户交互才能播放声音**，这个问题困扰了一两天，**找到了如下两条解决方案：**\n\n- 第一个就是用按钮点击，当我们播报声音时，第一次播报必须得是用户用交互动作操作才行，显然我这里不能让用户点击，因为它是后台自动播报的，嘿嘿，这可难不到我，写了个模拟按钮点击事件，就 ok 啦~\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>语音播报</title>\n  </head>\n  <body>\n    <h3>点击下方按钮可以进行语音播报</h3>\n    <hr />\n    <button onclick=\"areSpeak('哈哈哈哈哈，这是声音~')\">播放声音</button>&nbsp;&nbsp;<button onclick=\"beQuiet()\">停止播放</button>\n  </body>\n  <script>\n    //#region 语音播报封装\n    const areSpeak = newMsg => {\n      // 初次播报使用模拟按钮触发\n      virtualClick(SpeakVoice)\n      speakWithDelay(newMsg)\n    }\n\n    /**\n     * 语音播报\n     * @param msg 播报的信息\n     */\n    const SpeakVoice = (msg = '') => {\n      const speech = new SpeechSynthesisUtterance(msg)\n      // 设置兼容中文\n      const voices = window.speechSynthesis.getVoices()\n      speech.voice = voices.filter(function (voice) {\n        return voice.localService == true && voice.lang == 'zh-CN'\n      })[0]\n      window.speechSynthesis.speak(speech)\n    }\n\n    /**\n     * 语音播报 带延迟 异步\n     * 搭配async await\n     * @param msg 播报的信息\n     */\n    const speakWithDelay = (utterance, delay = 1000) => {\n      return new Promise(resolve => {\n        const speech = new SpeechSynthesisUtterance(utterance)\n        // 设置兼容中文\n        let voices = window.speechSynthesis.getVoices()\n        speech.voice = voices.filter(function (voice) {\n          return voice.localService == true && voice.lang == 'zh-CN'\n        })[0]\n        speech.onend = () => {\n          setTimeout(resolve, delay)\n        }\n        window.speechSynthesis.speak(speech)\n      })\n    }\n\n    /**\n     * 模拟按钮点击\n     * @param callback\n     */\n    const virtualClick = callback => {\n      let button = document.createElement('button')\n      button.textContent = '点击我'\n\n      // 添加点击事件处理程序\n      button.addEventListener('click', function () {\n        console.log('按钮被点击了')\n        callback && callback()\n      })\n\n      // 模拟用户点击事件\n      let event = new MouseEvent('click', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      })\n      button.dispatchEvent(event)\n    }\n\n    const beQuiet = () => {\n      console.log('停止')\n      window.speechSynthesis.cancel()\n      SpeakVoice('')\n    }\n    //#endregion\n  </script>\n</html>\n```\n\n- 第二种解决方案就是用其他第三方的库，不过基于浏览器的安全限制，可能也会存在无法在后台自动播放的情况，所以这里还是没有采用其他第三方的库。\n\n## 3 参考链接\n\n官方文档：\n\n​ [https://developer.mozilla.org/zh-CN/docs/Web/API/SpeechSynthesis](https://developer.mozilla.org/zh-CN/docs/Web/API/SpeechSynthesis)"
    },
    {
      "id": "vue3中子父组件传值通信的9种方法",
      "metadata": {
        "permalink": "/vue3中子父组件传值通信的9种方法",
        "source": "@site/blog/2023-05-20vue3中子父组件传值通信的9种方法.md",
        "title": "vue3中子父组件传值通信的9种方法",
        "description": "vue3中子父组件传值通信的9种方法",
        "date": "2023-05-20T00:00:00.000Z",
        "formattedDate": "2023年5月20日",
        "tags": [
          {
            "label": "架构",
            "permalink": "/tags/架构"
          },
          {
            "label": "UML",
            "permalink": "/tags/uml"
          }
        ],
        "readingTime": 1.735,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "vue3中子父组件传值通信的9种方法",
          "title": "vue3中子父组件传值通信的9种方法",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "vue3中子父组件传值通信的9种方法",
          "tags": [
            "架构",
            "UML"
          ]
        },
        "prevItem": {
          "title": "浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案",
          "permalink": "/浏览器自带api语音播报speechSynthesis.speak()无法自动播报问题分析及非完美解决方案"
        },
        "nextItem": {
          "title": "这14种UML图，你知道几个？",
          "permalink": "/这14种UML图，你知道几个？"
        }
      },
      "content": "## **vue3 中子父组件传值通信的 9 种方法**\n\n​\n\n## 1 props 传参\n\n```\n<script setup lang=\"ts\">\nimport { ref, reactive, onMounted } from 'vue'\nimport Child1 from './components/Child1.vue'\nimport Child2 from './components/Child2.vue'\nimport Child3 from './components/Child3.vue'\n\nconst data = reactive({\n  lifebar: 100,\n  child1_lifebar: 0\n})\n\nconst child1ref: {\n  value: {\n    /**生命值 */\n    lifebar: number\n    /**加血 */\n    addLifebar: () => void\n  }\n} = ref<T>()\nconst child2ref = ref()\n\n/**自身加血 */\nconst addLifebar = () => {\n  data.lifebar++\n}\n\n/**给队友加血 */\nconst addTeammateLifebar = () => {\n  console.log(child1ref.value)\n  console.log(child1ref.value.lifebar)\n  child1ref.value?.addLifebar()\n}\n\nonMounted(() => {\n  console.log('父组件加载完毕')\n  console.log(child1ref.value.lifebar)\n  data.child1_lifebar = child1ref.value.lifebar\n})\n</script>\n\n<template>\n  <div class=\"main\">\n    <div style=\"height: 60px; display: flex; align-items: center; justify-content: center\">\n      我是父组件蔡文姬\n      <el-space style=\"margin-left: 5px\">\n        <el-button @click=\"addLifebar\">给自身增加1点血量</el-button>\n        <el-button @click=\"addTeammateLifebar\">1-给子组件1马可波罗加1点血(父组件调用子组件函数)</el-button>\n      </el-space>\n    </div>\n    <div style=\"height: 100px; display: flex; flex-direction: column; align-items: center; justify-content: start\">\n      <div><b>父组件蔡文姬信息</b></div>\n      <div>\n        当前血量:<b>{{ data.lifebar }}</b>\n      </div>\n      <div>\n        <!-- 这里没有自动刷新，暂时没有找到原因 -->\n        2-探测到的子组件1马可波罗当前气值(父组件调用子组件参数):<b>{{ data.child1_lifebar }}</b>\n      </div>\n    </div>\n    <div class=\"box-content\">\n      <div class=\"left-box\">\n        <Child1 ref=\"child1ref\" :lifebar=\"data.lifebar\"></Child1>\n        <Child3></Child3>\n      </div>\n      <div class=\"right-box\"><Child2></Child2></div>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.main {\n  width: 80%;\n  height: 800px;\n  margin: auto;\n  border: 2px solid yellowgreen;\n  .box-content {\n    width: 100%;\n    height: calc(100% - 200px);\n    display: flex;\n    justify-content: space-around;\n    align-items: center;\n    .left-box {\n      width: 45%;\n      height: 100%;\n      border: 2px solid hotpink;\n      position: relative;\n    }\n    .right-box {\n      width: 45%;\n      height: 100%;\n      border: 2px solid hotpink;\n    }\n  }\n}\n</style>\n\n```\n\n## 后续待更新中。。"
    },
    {
      "id": "这14种UML图，你知道几个？",
      "metadata": {
        "permalink": "/这14种UML图，你知道几个？",
        "source": "@site/blog/2023-04-25这14种UML图，你知道几个？.md",
        "title": "这14种UML图，你知道几个？",
        "description": "这14种UML图，你知道几个？",
        "date": "2023-04-25T00:00:00.000Z",
        "formattedDate": "2023年4月25日",
        "tags": [
          {
            "label": "架构",
            "permalink": "/tags/架构"
          },
          {
            "label": "UML",
            "permalink": "/tags/uml"
          }
        ],
        "readingTime": 6.665,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "这14种UML图，你知道几个？",
          "title": "这14种UML图，你知道几个？",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "这14种UML图，你知道几个？",
          "tags": [
            "架构",
            "UML"
          ]
        },
        "prevItem": {
          "title": "vue3中子父组件传值通信的9种方法",
          "permalink": "/vue3中子父组件传值通信的9种方法"
        },
        "nextItem": {
          "title": "ts绕开属性检查的3种方法",
          "permalink": "/ts绕开属性检查的3种方法"
        }
      },
      "content": "## **这14种UML图，你知道几个？**\n​\n\n## 1 什么是UML\n\nUML-Unified Modeling Language 统一建模语言，又称标准建模语言。是用来对软件密集系统进行可视化建模的一种语言。UML的定义包括UML语义和UML表示法两个元素。\n\n## 2 为什么要用UML\n\nUML的目标是以面向对象图的方式来描述任何类型的系统，具有很宽的应用领域。\n\n在一个软件系统开始写代码之前，使用UML建模，可以使我们对这个系统的架构有更为清晰的了解，降低系统开发的风险，好处大大的。\n\n在软件系统开发期间，亦可以使用UML。\n\n## 3 UML图具体有哪些\n\nUML分为结构图与行为图两大类。\n\n结构图包括：类图、对象图、包图、组合结构图、构件图、部署图、制品图；\n\n行为图包括：用例图、顺序图、通信图、定时图、状态图、活动图、交互概念图；\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e56ad914604471cab7a447584573b7b~tplv-k3u1fbpfcp-zoom-1.image)​\n\n### 3.1 ★类图\n\n类图是面向对象方法的核心建模工具。\n\n#### 3.1.1 类的表示方法\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/289f98448d7f4ac08bdba0c82796b7ed~tplv-k3u1fbpfcp-zoom-1.image)​\n\n\n如上所示，`Employee` 为类名，`name`、`age`、`address` 为属性，`work()`为方法。我们还看到前面有`-`、`+` 这个的意思是：\n\n    +：表示public\n    -：表示private\n    ：表示protected\n\n属性的完整表示方式是： **可见性 名称 ：类型 \\[ = 缺省值]**\n\n方法的完整表示方式是： **可见性 名称(参数列表) \\[ ： 返回类型]**\n\n> 注意：\n>\n> 1，中括号中的内容表示是可选的\n>\n> 2，也有将类型放在变量名前面，返回值类型放在方法名前面\n\n**举个例子**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1987efff26140adbfe6868680293c31~tplv-k3u1fbpfcp-zoom-1.image)​\n\n上图Demo类定义了三个方法：\n\nmethod()方法：修饰符为public，没有参数，没有返回值。\n\nmethod1()方法：修饰符为private，没有参数，返回值类型为String。\n\nmethod2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。\n\n#### 3.1.2 常见的类之间的关系\n\n##### 3.1.2.1 依赖关系\n\n一个事物发生变化影响另一个事物。\n\n耦合度最弱的一种关系，在代码中为某个类的方法通过局部变量、方法临时调用一下别的类（依赖类）的方法，来完成一些功能。\n\n下图所示，Driver司机类调用Car类的move()方法来开车，也就是临时用一下车。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e68d2841c6c4bc4a038fdfa9c47aa82~tplv-k3u1fbpfcp-zoom-1.image)​\n\n\n##### 3.1.2.2 泛化关系\n\n特殊/一般关系。是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n\n子类继承了父类的所有属性及方法。\n\n如下图所示，Student 类和 Teacher 类都是 Person 类的子类。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df96ab3b7a8c4a45b018d6f233c17d38~tplv-k3u1fbpfcp-zoom-1.image)​\n\n##### 3.1.2.3 关联关系\n\n描述了一组链，链是对象之间的连接。是一种拥有关系，它使得一个类知道另一个类的属性和方法。\n\n*   **单向关联**\n\n下图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8521f262beef459585b5c81caa572075~tplv-k3u1fbpfcp-zoom-1.image)​\n\n*   **双向关联**\n\n从下图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96153dcbca0c45d7a47e82a8eeb9a87f~tplv-k3u1fbpfcp-zoom-1.image)​\n\n*   **自关联**\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5763b221be0418ca6d94f93d58150b0~tplv-k3u1fbpfcp-zoom-1.image)​\n\n##### 3.1.2.4 聚合关系\n\n整体与部分生命周期不同。最弱的耦合关系，比如A聚合B，A和B分开后，B的生命周期依然在。\n\n如下图所示，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f5b920e979c4635bb24bbe178ebbb99~tplv-k3u1fbpfcp-zoom-1.image)​\n\n##### 3.1.2.5 组合关系\n\n组合关系比聚合耦合要强，A与B组合，A没了，那对应的B也没了。\n\n如下图所示，头和嘴的关系，没有了头，嘴也就不存在了。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb96d44b76a94cd39497a1e38112e51c~tplv-k3u1fbpfcp-zoom-1.image)​\n\n##### 3.1.2.6 实现关系\n\n接口与类之间的关系。\n\n在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n\n如下图所示，汽车和船是交通工具的泛化，汽车和船实现了交通工具。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d876e6229d547b9a382b27f06243661~tplv-k3u1fbpfcp-zoom-1.image)​\n\n### 3.2 ★对象图\n\n对象图是类图的一个实例，是系统在某个时间点的详细状态的快照，描述一组对象及它们之间的关系。\n\n也就是说将类图整合在了一起使用。\n\n下面是个例子：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d591a1a567ca45b49649a4ad545aaae5~tplv-k3u1fbpfcp-zoom-1.image)​\n\n\n### 3.3 包图\n\n### 3.4 组合结构图\n\n待更新。\n\n### 3.5 构件图（组件图）\n\n待更新。\n\n### 3.6 部署图\n\n待更新。\n\n### 3.7 制品图\n\n待更新。\n\n***\n\n### 3.8 ★用例图（序列图）\n\n待更新。\n\n### 3.9 顺序图\n\n待更新。\n\n### 3.10 通信图\n\n待更新。\n\n### 3.11 定时图\n\n待更新。\n\n### 3.12 状态图（状态机图）\n\n待更新。\n\n### 3.13 活动图\n\n待更新。\n\n### 3.14 交互概念图\n\n待更新。\n\n## 4 参考\n\n*   UML之类图 [UML之类图\\_uml类图\\_夜雨微澜°的博客-CSDN博客](https://blog.csdn.net/weixin_57504000/article/details/124218420 \"UML之类图_uml类图_夜雨微澜°的博客-CSDN博客\")\n*   掌握14种UML图，清晰图示 [掌握14种UML图，清晰图示\\_Aiky哇的博客-CSDN博客](https://blog.csdn.net/qq_35423190/article/details/125069834 \"掌握14种UML图，清晰图示_Aiky哇的博客-CSDN博客\")\n\n## 5 小结\n\n类图、对象图、用例图重要些，多练多应用实际。\n\n​"
    },
    {
      "id": "ts绕开属性检查的3种方法",
      "metadata": {
        "permalink": "/ts绕开属性检查的3种方法",
        "source": "@site/blog/2023-03-10ts绕开属性检查的3种方法.md",
        "title": "ts绕开属性检查的3种方法",
        "description": "ts绕开属性检查的3种方法",
        "date": "2023-03-10T00:00:00.000Z",
        "formattedDate": "2023年3月10日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "ts",
            "permalink": "/tags/ts"
          }
        ],
        "readingTime": 2.735,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "ts绕开属性检查的3种方法",
          "title": "ts绕开属性检查的3种方法",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "ts绕开属性检查的3种方法",
          "tags": [
            "前端",
            "ts"
          ]
        },
        "prevItem": {
          "title": "这14种UML图，你知道几个？",
          "permalink": "/这14种UML图，你知道几个？"
        },
        "nextItem": {
          "title": "如何使用react-router实现一个路由权限判断",
          "permalink": "/如何使用react-router实现一个路由权限判断"
        }
      },
      "content": "## **ts 绕开属性检查的 3 种方法**\n\n### 引言\n\n不知道大家有没有遇到这种情况，当我们预先定义了 ts 的一些类型后，在我们真正用到时却又和原先约定的类型定义不一样，哎？那有时候我们有不想或者因为因为一些情况不好去改原来已经定义过的类型定义，这又该怎么办呢？ 不要着急，ts 为我们提供了 3 中解决方案，\n\n请看下面：\n\n示例代码：\n\n```javascript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string, area: number } {\n  return {\n    color: config.color,\n    area: config.width\n  }\n}\nlet mySquare = createSquare({ color: 'red', width: 100 })\nconsole.log('mySquare--->', mySquare)\n```\n\n如上所示，声明一个 createSquare 函数，形参类型是 SquareConfig 接口，传入的形参是`{ color: \"red\", width: 100 }`，好，这个时候是符合我们原先的 ts 类型定义的，但是当我们把入参改为`{ color: \"red\", width12: 100 }`，这个时候 ts 就会判断出入参传入有误，嘿，还智能的提示一下写 width12 是不是想传 width 这个变量\n\n![image-20230301172449195](https://raw.githubusercontent.com/JACK-ZHANG-coming/map-depot/master/2023image-20230301172449195.png)\n\n可是，如果我们真的是需要第二参数不同，那该如何嘞，请看下面的 3 种解决方式：\n\n### 1 类型断言\n\n最简便的方法，用 as 告诉 ts 这就是我想要的，这个类型是对的，好的，那么 ts 就不会报错\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    return {\n        color: config.color,\n        area: config.width,\n    }\n}\nlet mySquare = createSquare({ color: \"red\", opacity: 0.5 } as SquareConfig);  // 这里声明了{ color: \"red\", opacity: 0.5 } 就是SquareConfig类型\nconsole.log('mySquare--->', mySquare)\n```\n\n### 2 添加一个字符串索引签名\n\n最佳方式\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    return {\n        color: config.color,\n        area: config.width,\n    }\n}\nlet mySquare = createSquare({ color: \"red\", opacity: 0.5 });  //这里依然不会报错\nconsole.log('mySquare--->', mySquare)\n```\n\n### 3 对象赋值转接一手\n\n```\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    return {\n        color: config.color,\n        area: config.width,\n    }\n}\nlet squareOptions = { color: \"red\", opacity: 0.5 } // 用squareOptions变量来转接一下\nlet mySquare = createSquare(squareOptions);  //这里依然不会报错\nconsole.log('mySquare--->', mySquare)\n```\n\n参考：\n\n​ https://typescript.bootcss.com/interfaces.html"
    },
    {
      "id": "如何使用react-router实现一个路由权限判断",
      "metadata": {
        "permalink": "/如何使用react-router实现一个路由权限判断",
        "source": "@site/blog/2023-02-19react-router知识点总结.md",
        "title": "如何使用react-router实现一个路由权限判断",
        "description": "如何使用react-router实现一个路由权限判断",
        "date": "2023-02-19T00:00:00.000Z",
        "formattedDate": "2023年2月19日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          },
          {
            "label": "react-router",
            "permalink": "/tags/react-router"
          }
        ],
        "readingTime": 3.35,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "如何使用react-router实现一个路由权限判断",
          "title": "如何使用react-router实现一个路由权限判断",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "如何使用react-router实现一个路由权限判断",
          "tags": [
            "前端",
            "react",
            "react-router"
          ]
        },
        "prevItem": {
          "title": "ts绕开属性检查的3种方法",
          "permalink": "/ts绕开属性检查的3种方法"
        },
        "nextItem": {
          "title": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
          "permalink": "/一文学会ajax基础使用与使用nodejs搭建一个后端服务"
        }
      },
      "content": "**前言**\n\n> 这是一篇关于react-router的通篇全解的文章，本文旨在阅读完本文可以对react-router有一个系统的了解——emmm原来的思路是打算这么写的，但是近日阅读了一个大佬的文章，发现最好还是学以致用，并且融入自己的思想，所以决定前面介绍react-router的一些常规知识（1-3大点），后面第4大点会写一个实例，用react-router写一个路由鉴权。第4大点最为重要，如果对react-router有些许了解的也可以直接进入第4大点。\n>\n> 首先，有一说一，最详细的教程还是：[官网](https://reactrouter.com/en/main)  。下面的介绍将是融入个人理解的白话文：\n\n## 1 相关理解\n\n### 1.1 SPA的理解\n\n什么是spa？英文全拼single page web application，中文单页面Web应用。\n\n通俗的说，点击页面中的链接不会刷新页面（浏览器左上角的那个小圆环不会转），只会做页面的局部更新，那这就是个单页面web应用。比如我们用的`<a></a>`标签，里面加个href='https://www.zhangqiang.hk.cn/' 属性，当我们点击那个a标签，此时页面跳转了网页，左上角那个小圆圈呼溜溜的转了，那这就不是个单页面web应用。\n\n而ajax异步请求、react-router都是可以实现spa的、\n\n### 1.2 路由的理解\n\n#### 1.2.1 什么是路由?\n\n- 一个路由就是一个映射关系(key:value)\n- key为路径, value可能是function或component\n\n#### 1.2.2 路由分类\n\n**后端路由：**\n\n理解： value是function, 用来处理客户端提交的请求。\n注册路由： router.get(path, function(req, res))\n工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据\n\n**前端路由：**\n\n浏览器端路由，value是component，用于展示页面内容。\n注册路由: `<Route path=\"/test\" component={Test}>`\n工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件\n\n**react-router-dom的理解:**\n\n- react的一个插件库。\n- 专门用来实现一个SPA应用。\n- 基于react的项目基本都会用到此库。\n\n## 2 react-router-v5\n\n### 2.1 react-router-dom相关API\n\n#### 2.1.1 内置组件\n\n```\n<BrowserRouter>\n<HashRouter>\n<Route>\n<Redirect>\n<Link>\n<NavLink>\n<Switch>\n```\n\n#### 2.1.2 其它\n\n- history对象\n\n- match对象\n\n- withRouter函数\n\n\n\n### 2.2 基本路由使用\n\n#### 2.2.1 安装react-router-dom\n\n```\nnpm install --save react-router-dom\n```\n\n#### 2.2.2 嵌套路由使用\n\n\n\n#### 2.2.3 向路由组件传递参数数据\n\n\n\n#### 2.2.4 多种路由跳转方式\n\n\n\n## 3 react-router-v6\n\n\n\n\n\n## 4 实例-react-router实现前端路由鉴权\n\n相关参考：\n\n​\t使用React-Router实现前端路由鉴权：https://juejin.cn/post/6854573217445740557#comment"
    },
    {
      "id": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
      "metadata": {
        "permalink": "/一文学会ajax基础使用与使用nodejs搭建一个后端服务",
        "source": "@site/blog/2023-01-14一文学会ajax基础使用与使用nodejs搭建一个后端服务.md",
        "title": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
        "description": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
        "date": "2023-01-14T00:00:00.000Z",
        "formattedDate": "2023年1月14日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "ajax",
            "permalink": "/tags/ajax"
          },
          {
            "label": "node.js",
            "permalink": "/tags/node-js"
          }
        ],
        "readingTime": 19.79,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
          "title": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
          "tags": [
            "前端",
            "ajax",
            "node.js"
          ]
        },
        "prevItem": {
          "title": "如何使用react-router实现一个路由权限判断",
          "permalink": "/如何使用react-router实现一个路由权限判断"
        },
        "nextItem": {
          "title": "react高阶组件概念与简单使用",
          "permalink": "/react高阶组件概念与简单使用"
        }
      },
      "content": "## 写在前面\n\n> - 本文对应的 github 代码仓库地址\n>\n>   <https://github.com/front-end-study-GoGoGo/ajax-study-demo>\n>\n> - 本文对应的视频教程地址：\n>\n>   <https://www.bilibili.com/video/BV1yW4y137R5>\n>\n> - 博主个人前端网站：[zhangqiang.hk.cn](https://link.juejin.cn/?target=https%3A%2F%2Fzhangqiang.hk.cn)\n>\n> - 欢迎加入博主的前端学习 qq 交流群：：[706947563](https://link.juejin.cn/?target=https%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Fk%3DEbeK9mdG0e6P2pZdonIoILPqcGNsnR1x%26jump_from%3Dwebapi)，**专注前端开发，共同学习进步啊 ~**\n\n## 简介\n\n> AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n>\n> AJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n>\n> AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。\n>\n> AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。\n>\n> XMLHttpRequest 只是实现 Ajax 的一种方式。\n\n上面是来自[菜鸟教程](https://www.runoob.com/ajax/ajax-tutorial.html)的简介，用白话文概括呢，ajax 是 javascript 里面内置的一种异步方法实现方式，用 XMLHttpRequest 对象可以来实现这种异步方式。目前我们主流的前端接口请求方式**fetch、axios** 都是基于 ajax 封装的，所以了解 ajax 的使用对于解读 fetch 与 axios 的源码也是必不可少的。\n\n**In short**，学习 ajax 的使用是很重要的。\n\n## 0 准备工作\n\n首先，执行个小目标，我们**在本地先快速起一个后端服务**，使前端可以调到这个接口，很简单，请看下面的操作：\n\n打开我们的 vscode（如果你使用的是 webstorm 也是一样的操作，不过很推荐 vscode 呀，干净简洁很喜欢~）,执行`npm init`初始化一下 npm 配置（在这之前要确保电脑上已经安装 node.js，可以在终端输入 node -v 查看，有版本号说明已经安装）：\n\n0.1 npm 初始化\n\n- node -v 有版本号显示说明已经安装 node.js\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13f09f3924df4e2ba315cc75842377df~tplv-k3u1fbpfcp-watermark.image?)\n\n- 执行 npm init，一路回车就完事了，然后我们可以看到所在文件夹里面会有个 package.json 文件，说明 npm init 初始化成功。之后安装的 npm 包版本都可以在 package.json 里面查看到。\n\n![image-20230113150934180](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c63118b3b346cea844aad73709778a~tplv-k3u1fbpfcp-zoom-1.image)\n\n0.2 安装 express\n\n在终端执行`npm install express`，安装 express，这是一个库可以让我们用 node.js 启动一个后端服务器，当这个后端服务启动的时候，我们就可以通过前端代码请求它暴露出来的接口访问到相应的后端服务。\n\n0.2.1 如果安装成功的小伙伴不用看这个小点，我在安装的时候遇到了这个报错，分析一下是因为 npm 的源是国外的原因，所以我将其设置成了淘宝镜像\n\n![image-20230113152632762](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0051ef0b57b4cb79b05497876e8cac0~tplv-k3u1fbpfcp-zoom-1.image)\n\n设置淘宝镜像命令,在终端执行（下面图片里面有）：\n\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n\n0.2.1 安装成功\n\n![image-20230113152715760](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf56f3cbf37a4134a92f58f6f21eca92~tplv-k3u1fbpfcp-zoom-1.image)\n\n**顺便再装个库，`npm install body-parser` ，** 后面会有用，针对 post 请求的\n\n![image-20230113215801561](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50cde2f6109945a0bdbb2b42ac034919~tplv-k3u1fbpfcp-zoom-1.image)\n\n0.2.2 启动 node 后端服务\n\n我们创建一个文件夹 src，在 src 下面建个 server.js 的文件，然后再粘贴下方的代码到 server.js 文件里面\n\n```\n//1. 引入express\nconst express = require('express');\n​\n//2. 创建应用对象\nconst app = express();\n​\n//3. 创建路由规则\n// request 是对请求报文的封装\n// response 是对响应报文的封装\napp.get('/server', (request, response) => {\n    //设置响应头  设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    //设置响应体 这里是返回给前端的内容\n    response.send('哈哈哈，接口请求成功，这一串文字是接口返回的数据~~');\n});\n​\n//4. 监听端口启动服务\napp.listen(8000, () => {\n    console.log(\"服务已经启动, 8000 端口监听中....\");\n});\n```\n\n![image-20230113153544950](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6404e23014854aeab8e8b73250ef6e89~tplv-k3u1fbpfcp-zoom-1.image)\n\n终端进入 src 这个文件夹，然后执行`node server.js`，启动后端服务\n\n![image-20230113154009446](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00cfb9f5f74840f4829d8839e95dd993~tplv-k3u1fbpfcp-zoom-1.image)\n\n如上图，我们已经在本地打开了 8000 端口，同时写了个`/server` get 类型的接口地址，我们可以直接通过浏览器来访问`http://127.0.0.1:8000/server`测试一下接口，如果我们看到下图这样，说明后端服务开启成功~\n\n![image-20230113154625311](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d27f8851264d404b8ca6f3a4d7c591d7~tplv-k3u1fbpfcp-zoom-1.image)\n\nok，后端服务启动完毕！~ 还是很厉害的嘛，我们进入下个流程~~ 前端写 ajax 请求。\n\n## 1 写个简单的 ajax 请求\n\n### 1.1 get 请求 与 post 请求\n\n#### 1.1.1 前端代码\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n​\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>ajax使用</title>\n    <style>\n        .mainContainer {\n            font-size: 20px;\n        }\n    </style>\n</head>\n​\n<body>\n    <div class=\"mainContainer\">\n        <div>右键打开控制台查看ajax网络请求</div>\n        <button>点击发送GET请求</button>\n        <button>02点击发送带参数的GET请求</button>\n        <button>03点击发送带参数的POST请求</button>\n    </div>\n​\n    <script>\n​\n        //获取button元素\n        const btn = document.getElementsByTagName('button')[0]\n        //绑定事件\n        btn.onclick = function () {\n            //1. 创建对象\n            const xhr = new XMLHttpRequest()\n            //2. 初始化 设置请求方法和 url\n            xhr.open('GET', 'http://127.0.0.1:8000/server')\n            //3. 发送\n            xhr.send()\n            //4. 事件绑定 处理服务端返回的结果\n            // on  when 当....时候\n            // readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4\n            // change  改变\n            xhr.onreadystatechange = function () {\n                //判断 (服务端返回了所有的结果)\n                if (xhr.readyState === 4) {\n                    //判断响应状态码 200  404  403 401 500\n                    // 2xx 成功\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        //处理结果  行 头 空行 体\n                        //响应\n                        // console.log(xhr.status);//状态码\n                        // console.log(xhr.statusText);//状态字符串\n                        // console.log(xhr.getAllResponseHeaders());//所有响应头\n                        // console.log(xhr.response);//响应体\n                        //设置 result 的文本\n                        console.log(`${btn.textContent}返回回来的数据：`, xhr.response)\n                    } else {\n                        console.log('接口请求失败', btn.textContent)\n                    }\n                }\n            }\n        }\n​\n        // 02点击发送带参数的GET请求\n        const btn2 = document.getElementsByTagName('button')[1];\n        //绑定事件\n        btn2.onclick = function () {\n            //1. 创建对象\n            const xhr = new XMLHttpRequest()\n            //2. 初始化 设置请求方法和 url\n            xhr.open('GET', 'http://127.0.0.1:8000/server/getAndValue?a=100&b=200&c=300');\n            //3. 发送\n            xhr.send()\n            //4. 事件绑定 处理服务端返回的结果\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        console.log(`${btn2.textContent}返回回来的数据：`, xhr.response)\n                    } else {\n                        console.log('接口请求失败', btn2.textContent)\n                    }\n                }\n            }\n        }\n​\n        // 03点击发送带参数的post请求\n        const btn3 = document.getElementsByTagName('button')[2];\n        //绑定事件\n        btn3.onclick = function () {\n            //1. 创建对象\n            const xhr = new XMLHttpRequest()\n            //2. 初始化 设置请求方法和 url\n            xhr.open('POST', 'http://127.0.0.1:8000/server/postAndValue');\n            //设置请求头  post请求要设置请求头，以form表单的形式传参\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            //3. 发送\n            xhr.send('a=100&b=200&c=30000000000111')\n            //4. 事件绑定 处理服务端返回的结果\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status >= 200 && xhr.status < 300) {\n                        console.log(`${btn3.textContent}返回回来的数据：`, xhr.response)\n                    } else {\n                        console.log('接口请求失败', btn3.textContent)\n                    }\n                }\n            }\n        }\n    </script>\n</body>\n​\n</html>\n```\n\n#### 1.1.2 后端代码\n\n```\n//1. 引入express\nconst express = require('express');\n​\nconst bodyParser = require('body-parser'); // 使用express中间件，以解决post请求后端获取不到值问题\n​\n//2. 创建应用对象\nconst app = express();\n​\n// 下面这两句话是针对post请求加的， req.body是解析json的结果，一定加上这么2句，否则post请求获取不到req.body的  \napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n​\n//3. 创建路由规则\n// request 是对请求报文的封装\n// response 是对响应报文的封装\napp.get('/server', (request, response) => {\n    //设置响应头  设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    //设置响应体 这里是返回给前端的内容\n    response.send('哈哈哈，接口请求成功，这一串文字是接口返回的数据~~');\n});\n​\n// 3.2 get带参数的接口\napp.get('/server/getAndValue', (request, response) => {\n    //设置响应头  设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    // response.setHeader('Access-Control-Allow-Headers', '*');\n    //设置响应体 这里是返回给前端的内容\n    let result = request.query;\n    if (result.a !== undefined) {\n        result.a = result.a + 10000\n    }\n    response.send(result);\n});\n​\n// 3.2 get带参数的接口\napp.get('/server/getAndValue', (request, response) => {\n    //设置响应头  设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    // response.setHeader('Access-Control-Allow-Headers', '*');\n    //设置响应体 这里是返回给前端的内容\n    let result = request.query;\n    if (result.a !== undefined) {\n        result.a = result.a + 10000\n    }\n    response.send(result);\n});\n​\n​\n// 3.2 post带参数的接口\napp.all('/server/postAndValue', (request, response) => {\n    //设置响应头  设置允许跨域\n    response.setHeader('Access-Control-Allow-Origin', '*');\n    response.setHeader('Access-Control-Allow-Headers', '*');\n    // response.header('Access-Control-Allow-Headers', 'Content-Type')\n    //设置响应体 这里是返回给前端的内容\n    let result = request.body;\n    console.log('postAndValue--->', result)\n    response.send(request.body);\n});\n​\n​\n//4. 监听端口启动服务\napp.listen(8000, () => {\n    console.log(\"服务已经启动, 8000 端口监听中....\");\n});\n```\n\n#### 1.2.3 运行结果\n\n![image-20230113220628033](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b28651d0039b4e588daf99074456e9a9~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 2 相关参考手册\n\n### 2.1 XMLHttpRequest 对象的方法\n\n| 方法                                          | 描述                                                                                                                       |\n| --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| abort()                                       | 取消当前请求                                                                                                               |\n| getAllResponseHeaders()                       | 返回头部信息                                                                                                               |\n| getResponseHeader()                           | 返回特定的头部信息                                                                                                         |\n| open(_method_, _url_, _async_, _user_, _psw_) | 规定请求 method：请求类型 GET 或 POSTurl：文件位置 async：true（异步）或 false（同步）user：可选的用户名称 psw：可选的密码 |\n| send()                                        | 将请求发送到服务器，用于 GET 请求                                                                                          |\n| send(_string_)                                | 将请求发送到服务器，用于 POST 请求                                                                                         |\n| setRequestHeader()                            | 设置请求头，向要发送的报头添加标签/值对                                                                                    |\n\n### 2.2 XMLHttpRequest 对象的属性\n\n| 属性               | 描述                                                                                                                    |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------- |\n| onreadystatechange | 定义当 readyState 属性发生变化时被调用的函数                                                                            |\n| readyState         | 保存 XMLHttpRequest 的状态。0：请求未初始化 1：服务器连接已建立 2：请求已收到 3：正在处理请求 4：请求已完成且响应已就绪 |\n| responseText       | 以字符串返回响应数据                                                                                                    |\n| responseXML        | 以 XML 数据返回响应数据                                                                                                 |\n| response           | 以原格式返回响应数据，可以理解为后端返回的数据格式是啥那就是啥                                                          |\n| status             | 返回请求的状态号 200: \"OK\"403: \"Forbidden\"404: \"Not Found\"                                                              |\n| statusText         | 返回状态文本（比如 \"OK\" 或 \"Not Found\"）                                                                                |\n\n### 2.3 http 状态码\n\n#### 1xx: 信息\n\n| 消息:                   | 描述:                                                                                  |\n| ----------------------- | -------------------------------------------------------------------------------------- |\n| 100 Continue            | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 |\n| 101 Switching Protocols | 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。                             |\n\n#### 2xx: 成功\n\n| 消息:                             | 描述:                                                                                                                         |\n| --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |\n| 200 OK                            | 请求成功（其后是对 GET 和 POST 请求的应答文档。）                                                                             |\n| 201 Created                       | 请求被创建完成，同时新的资源被创建。                                                                                          |\n| 202 Accepted                      | 供处理的请求已被接受，但是处理未完成。                                                                                        |\n| 203 Non-authoritative Information | 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。                                                          |\n| 204 No Content                    | 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而 Servlet 可以确定用户文档足够新，这个状态代码是很有用的。 |\n| 205 Reset Content                 | 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。                                                  |\n| 206 Partial Content               | 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它。                                                                      |\n\n#### 3xx: 重定向\n\n| 消息:                  | 描述:                                                                                                                                                                           |\n| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 300 Multiple Choices   | 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。                                                                                                            |\n| 301 Moved Permanently  | 所请求的页面已经转移至新的 url。                                                                                                                                                |\n| 302 Found              | 所请求的页面已经临时转移至新的 url。                                                                                                                                            |\n| 303 See Other          | 所请求的页面可在别的 url 下被找到。                                                                                                                                             |\n| 304 Not Modified       | 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 |\n| 305 Use Proxy          | 客户请求的文档应该通过 Location 头所指明的代理服务器提取。                                                                                                                      |\n| 306 _Unused_           | 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。                                                                                                                      |\n| 307 Temporary Redirect | 被请求的页面已经临时移至新的 url。                                                                                                                                              |\n\n#### 4xx: 客户端错误\n\n| 消息:                             | 描述:                                                                                                      |\n| --------------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| 400 Bad Request                   | 服务器未能理解请求。                                                                                       |\n| 401 Unauthorized                  | 被请求的页面需要用户名和密码。                                                                             |\n| 402 Payment Required              | 此代码尚无法使用。                                                                                         |\n| 403 Forbidden                     | 对被请求页面的访问被禁止。                                                                                 |\n| 404 Not Found                     | 服务器无法找到被请求的页面。                                                                               |\n| 405 Method Not Allowed            | 请求中指定的方法不被允许。                                                                                 |\n| 406 Not Acceptable                | 服务器生成的响应无法被客户端所接受。                                                                       |\n| 407 Proxy Authentication Required | 用户必须首先使用代理服务器进行验证，这样请求才会被处理。                                                   |\n| 408 Request Timeout               | 请求超出了服务器的等待时间。                                                                               |\n| 409 Conflict                      | 由于冲突，请求无法被完成。                                                                                 |\n| 410 Gone                          | 被请求的页面不可用。                                                                                       |\n| 411 Length Required               | \"Content-Length\" 未被定义。如果无此内容，服务器不会接受请求。                                              |\n| 412 Precondition Failed           | 请求中的前提条件被服务器评估为失败。                                                                       |\n| 413 Request Entity Too Large      | 由于所请求的实体的太大，服务器不会接受请求。                                                               |\n| 414 Request-url Too Long          | 由于 url 太长，服务器不会接受请求。当 post 请求被转换为带有很长的查询信息的 get 请求时，就会发生这种情况。 |\n| 415 Unsupported Media Type        | 由于媒介类型不被支持，服务器不会接受请求。                                                                 |\n| 416                               | 服务器不能满足客户在请求中指定的 Range 头。                                                                |\n| 417 Expectation Failed            |                                                                                                            |\n\n#### 5xx: 服务器错误\n\n| 消息:                          | 描述:                                              |\n| ------------------------------ | -------------------------------------------------- |\n| 500 Internal Server Error      | 请求未完成。服务器遇到不可预知的情况。             |\n| 501 Not Implemented            | 请求未完成。服务器不支持所请求的功能。             |\n| 502 Bad Gateway                | 请求未完成。服务器从上游服务器收到一个无效的响应。 |\n| 503 Service Unavailable        | 请求未完成。服务器临时过载或当机。                 |\n| 504 Gateway Timeout            | 网关超时。                                         |\n| 505 HTTP Version Not Supported | 服务器不支持请求中指明的 HTTP 协议版本。           |"
    },
    {
      "id": "react高阶组件概念与简单使用",
      "metadata": {
        "permalink": "/react高阶组件概念与简单使用",
        "source": "@site/blog/2022-12-05react高阶组件概念与简单使用.md",
        "title": "react高阶组件概念与简单使用",
        "description": "react高阶组件概念与简单使用",
        "date": "2022-12-05T00:00:00.000Z",
        "formattedDate": "2022年12月5日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 3.7,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "react高阶组件概念与简单使用",
          "title": "react高阶组件概念与简单使用",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "react高阶组件概念与简单使用",
          "tags": [
            "前端",
            "react"
          ]
        },
        "prevItem": {
          "title": "一文学会ajax基础使用与使用nodejs搭建一个后端服务",
          "permalink": "/一文学会ajax基础使用与使用nodejs搭建一个后端服务"
        },
        "nextItem": {
          "title": "浅谈与使用js中的原型",
          "permalink": "/浅谈与使用js中的原型"
        }
      },
      "content": "<!-- truncate -->\n> 我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=13fmu8we7j7e\n\n# react 高阶组件概念与简单使用\n\n## 1 react 高阶组件是什么\n\n> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n>\n> 具体而言，**高阶组件是参数为组件，返回值为新组件的函数。**\n\n上面这段话是来自[react 官网](https://zh-hans.reactjs.org/docs/higher-order-components.html)的介绍，下面是个人消化后的理解：\n\n它是一个**函数**，接收一个参数，这个**参数是组件**，然后再**返回一个新组件**（返回的这个组件里会含有处理过的 state 值）；\n\n归其缘由，它是一种设计思想，它将多个组件中公共的逻辑部分抽离出来封装成了一个函数，这个函数接收那多个组件中的一个组件作为参数，然后再返回这个组件，从而实现多个组件中那个组件的最终效果。\n\n## 2 react 高阶组件作用\n\n- 精简代码，封装复用逻辑\n\n​ ...\n\n## 3 简单实现 react 高阶组件\n\n```react\n/**\n * 需求简述：\n * 实现两个组件文本框，\n * 一个组件为外边框为1px绿色、里面显示内容为当前浏览器的高宽；\n * 另一个组件为外边框2px红色、里面内容为当前浏览器的高宽。\n */\n\nimport React, { useState, useEffect } from 'react'\n\n\nconst WithShowBodySize = (Component) => {\n\n  const [xPos, setXPos] = useState('');\n  const [yPos, setYPos] = useState('');\n\n  const getPos = () => {\n    setXPos(document.body.offsetWidth);\n    setYPos(document.body.offsetHeight);\n  }\n\n  useEffect(() => {\n    console.log('WithShowBodySize');\n    getPos()\n    window.addEventListener('resize', getPos);\n    return () => {\n      window.removeEventListener('resize', () => {\n        console.log('resize监听事件已移除');\n      })\n    }\n  }, []);\n\n  return (\n    <>\n      <Component xPos={xPos} yPos={yPos}></Component>\n    </>\n  )\n}\n\nconst ShowBodySizeA = (props) => {\n  return <div style={{ border: '1px solid yellowGreen' }}>{props?.xPos}-{props?.yPos}</div>\n}\n\nconst ShowBodySizeB = (props) => {\n  return <div style={{ border: '3px solid red' }}>{props?.xPos}-{props?.yPos}</div>\n}\n\nconst HOCDemo = (props) => {\n\n  const A = WithShowBodySize(ShowBodySizeA);\n  const B = WithShowBodySize(ShowBodySizeB);\n\n  useEffect(() => {\n    console.log('HOCDemo');\n  }, [])\n\n  return (\n    <>\n      高阶组件思想运用\n      <br></br>\n      <br></br>\n      {A}\n      <br></br>\n      {B}\n    </>\n  )\n};\n\nexport default HOCDemo;\n\n```\n\n## 4 对应本文视频讲解\n\n- react 高阶组件实例讲解\n\n​ https://www.bilibili.com/video/BV1D44y1S7op/?vd_source=e248443ed146cfdb38797f0fa5dca3da\n\n## 5 **插个眼：**\n\n这边看到了篇博客，关于 HOC 讲的很详细，没全明白，等以后再看，看看能不能有更多收获：\n\n- 「react 进阶」一文吃透 React 高阶组件(HOC)：\n\n  https://juejin.cn/post/6940422320427106335#heading-0\n\n**还有个小疑问也记录一下：**\n\n参考文章说“render 中不要声明 HOC”，那以上方代码为例，我用的函数式组件，我不在函数里面引用 HOC 在哪里引用呢？在外面引用的话会报错呀。\n\n还有当我引用两次抽离出来的那个高阶组件 useEffect 会执行两次，引用 n 次高阶组件 useEffect 就会执行 n 次，这种属于高阶组件的正确运用吗，有没有引用 n 次 useEffect 只会执行一次的那种。\n\n![image-20221204213125672](https://raw.githubusercontent.com/JACK-ZHANG-coming/map-depot/master/imgs/image-20221204213125672.png)"
    },
    {
      "id": "浅谈与使用js中的原型",
      "metadata": {
        "permalink": "/浅谈与使用js中的原型",
        "source": "@site/blog/2022-11-22浅谈与使用js中的原型.md",
        "title": "浅谈与使用js中的原型",
        "description": "浅谈与使用js中的原型",
        "date": "2022-11-22T00:00:00.000Z",
        "formattedDate": "2022年11月22日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          }
        ],
        "readingTime": 3.38,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "浅谈与使用js中的原型",
          "title": "浅谈与使用js中的原型",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "浅谈与使用js中的原型",
          "tags": [
            "前端",
            "javascript"
          ]
        },
        "prevItem": {
          "title": "react高阶组件概念与简单使用",
          "permalink": "/react高阶组件概念与简单使用"
        },
        "nextItem": {
          "title": "js中this指向问题及call，apply，bind的区别",
          "permalink": "/js中this指向问题及call，apply，bind的区别"
        }
      },
      "content": "<!-- truncate -->\n\n# 浅谈与使用js中的原型\n\n## 1 什么是原型\n\n> “ 每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例 共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性(指向 原型对象)。”\n\n上面这段话摘至《JavaScript高级程序设计》（第4版）224-225页 关于原型的讲解。按照我现在的理解就是：每个函数上面都有一个prototype属性，这个就是原型，我们可以通过这个原型属性来完成一些比较厉害的操作。\n\n## 2 原型的使用\n\n首先我们使用设计模式中的工厂模式来实现一个Person类，可以通过new这个Person的函数来创建一个与之具有相同属性的实例，也就省的我们再次创建Person函数了。\n\n```\n// 工厂模式实现 方法1\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function () {\n    console.log(this.name)\n  }\n}\nlet person1 = new Person('Nicholas', 29, 'Software Engineer')\nlet person2 = new Person('Greg', 27, 'Doctor')\nperson1.sayName() // Nicholas\nperson2.sayName() // Greg\n```\n\n从上面代码中可以看到`sayName`这个方法是在Person函数里面的，每次new的Person的实例时候都需要跟着一起重新创建，但是这个方法在每个实例中都是相同的功能，重新创建需要开辟新的空间，显得有些冗余了，那么有没有什么操作可以使其可以更简洁呢？有，那就是用原型，请看下面这份代码：\n\n```\n// 工厂模式实现 方法2 使用原型属性\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n}\nPerson.prototype.sayName = function () {\n  console.log(this.name)\n}\nlet person1 = new Person('Nicholas', 29, 'Software Engineer')\nlet person2 = new Person('Greg', 27, 'Doctor')\nperson1.sayName() // Nicholas\nperson2.sayName() // Greg\n```\n\n我们将`sayName`这个方法直接赋值给了`Person.prototype`,也就是Person的原型，那么后面再通过Person创建实例，实例上面就会自动继承这个方法，也无效再次重新创建，从而就提高了代码的性能。\n\n## 3 小结\n\n本文仅是对于原型有个简单的认识也使用，原型在js中是一个比较重要的模块，还有`__proto__` 、 ` 原型链 ` 这些概念没有讲到，如果感兴趣，可以再通过书籍及视频来交叉理解。笔者能力有限，文中难免有错谬之处，欢迎批评指正，一起学习，共同进步 ~"
    },
    {
      "id": "js中this指向问题及call，apply，bind的区别",
      "metadata": {
        "permalink": "/js中this指向问题及call，apply，bind的区别",
        "source": "@site/blog/2022-11-21js中this指向问题及call，apply，bind的区别.md",
        "title": "js中this指向问题及call，apply，bind的区别",
        "description": "js中this指向问题及call，apply，bind的区别。",
        "date": "2022-11-21T00:00:00.000Z",
        "formattedDate": "2022年11月21日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "javascript",
            "permalink": "/tags/javascript"
          }
        ],
        "readingTime": 4.99,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "js中this指向问题及call，apply，bind的区别",
          "title": "js中this指向问题及call，apply，bind的区别",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "js中this指向问题及call，apply，bind的区别。",
          "tags": [
            "前端",
            "javascript"
          ]
        },
        "prevItem": {
          "title": "浅谈与使用js中的原型",
          "permalink": "/浅谈与使用js中的原型"
        },
        "nextItem": {
          "title": "react生命周期总结（旧、新生命周期及Hook）",
          "permalink": "/react生命周期总结（旧、新生命周期及Hook）"
        }
      },
      "content": "<!-- truncate -->\n\n# js中this指向问题及call，apply，bind的区别\n\n\n\n## 1 this指向\n\n### 1.1 what is 'this'?\n\n> 在 ECMAScript 5 中，函数内部存在两个特殊的对象:arguments（一个类数组对象，包含调用函数时传入的所有参数） 和 **this（本文将要讲的）**。ECMAScript 6 又新增了 new.target （检测这个函数是否使用了new关键字，如使用则将引用被调用的构造函数，否则值为undefined）属性。\n\n### 1.2 标准函数与箭头函数的this指向\n\nthis在标准函数与箭头函数中的时会有两种不同类型的指向行为。\n\n#### 1.2.1 标准函数的this指向\n\n在标准函数中，this 指向的是把函数当成方法调用的上下文对象。也就是说在哪里调用的这个函数，那这个this只会指向它外面最靠近它的对象。\n\n```javascript\n// 1.直接调用时，从这个this往它外层找，最靠近它的对象是window，所以它指向的就是window\nfunction fun() {\n  console.log(this)\n}\nfun()\n\n// 2.以方法的形式调用，从这里this往外层找，可以看到靠近这个this的对象是我们定义的obj对象，所以this指向的就是obj\nconst obj = {\n  name: 'obj啊',\n  sayObj: fun\n}\nobj.sayObj()\n\n// 3.当使用new关键字调用，这个时候最靠近this的是new关键字实例化出来的对象，所以下面这两句话的this指向分别是creatPerson1对象和creatPerson2对象\nfunction Person(name, age) {\n  console.log(this)\n  this.name = name\n  this.age = age\n}\nconst creatPerson1 = new Person('Jack', 11111)\nconst creatPerson2 = new Person('Tom', 22222)\n```\n\n运行结果如下：\n\n![image-20221120213129164](https://raw.githubusercontent.com/JACK-ZHANG-coming/map-depot/master/imgs/image-20221120213129164.png)\n\n\n\n#### 1.2.2 箭头函数this指向\n\n当箭头函数时，this指向的是定义箭头函数的上下文。也就是说哪里定义了箭头函数，那这个this就在哪里，不会因为在其他地方调用而改变this指向。通常我们口头说的“箭头函数没有this”、“箭头函数this指向无法改变”...\n\n```javascript\n// 我们在全局作用下定义一个箭头函数，外围靠近它最近的对象是window，好，那么此刻它的this直接就是window，而且后续无论在哪里调用都不会改变了。\nconst sayColor = () => console.log(this)\n// 1.直接调用，this指向window\nsayColor()\n// 2.以obj_1对象里面的方法形式调用，this依然指向window\nlet obj_1 = {\n  name: 'obj_1啦啦',\n  sayColor: sayColor\n}\nobj_1.sayColor()\n```\n\n运行结果如下：\n\n![image-20221120224500747](https://raw.githubusercontent.com/JACK-ZHANG-coming/map-depot/master/imgs/image-20221120224500747.png)\n\n## 2 call，apply，bind的区别\n\n**相同点：**\n\n- 都可以改变函数的this指向\n- 第一个参数为this将要指向的对象，后续的传参都是作为函数形参的值\n\n**不同点：**\n\n- call的后续传参是**一个一个传**，然后顺序对应；apply的后续传参是**以数组的形式**，解析的时候也是跟call一样顺序对应；\n- call、apply没有返回值，而bind改变完this指向后会返回一个改变完this指向之后的原函数的拷贝 可以再次进行调用。\n\n```javascript\nvar a = {\n  name: '一一',\n  age: '23',\n  sex: '女',\n  hobby: '写代码',\n  say: function (sex, hobby) {\n    console.log(this.name, this.age, sex, hobby)\n  }\n}\nvar b = {\n  name: '二二',\n  age: '24'\n}\na.say()\na.say.call(b, '男', '爬山')\na.say.apply(b, ['男', '密室逃脱'])\n// bind可以向cally一样传参，例如:\na.say.bind(b, '男', 'UNO')()\n// 但由于bind返回的仍然是一个函数，所以我们还可以在函数调用的时候再进行传参。例如：\na.say.bind(b)('男', 'UNO')\n```\n\n运行的结果如下：\n\n![image-20221120235353188](https://raw.githubusercontent.com/JACK-ZHANG-coming/map-depot/master/imgs/image-20221120235353188.png)\n\n## 3 小结\n\n关于this指向、call、apply、bind的记录本篇就总结到这里，在日常使用脚手架、组件开发时可能会用的地方比较少，但是当我们维护一些老代码或者看一些偏向底层的代码时，将会有助于理解。\n\n\n\n## 参考文献：\n\n[1] 马特·弗里斯比.JavaScript高级程序设计.第4版.人民邮电出版社，2020.300页-301页.\n\n[2] whyfail.https://blog.csdn.net/weixin_44733660/article/details/122838505\n\n[3] MDN.https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"
    },
    {
      "id": "react生命周期总结（旧、新生命周期及Hook）",
      "metadata": {
        "permalink": "/react生命周期总结（旧、新生命周期及Hook）",
        "source": "@site/blog/2022-10-08react生命周期总结（旧、新生命周期及Hook）.md",
        "title": "react生命周期总结（旧、新生命周期及Hook）",
        "description": "react生命周期总结（旧、新生命周期及Hook）。",
        "date": "2022-10-08T00:00:00.000Z",
        "formattedDate": "2022年10月8日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 5.74,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "react生命周期总结（旧、新生命周期及Hook）",
          "title": "react生命周期总结（旧、新生命周期及Hook）",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "react生命周期总结（旧、新生命周期及Hook）。",
          "tags": [
            "前端",
            "react"
          ]
        },
        "prevItem": {
          "title": "js中this指向问题及call，apply，bind的区别",
          "permalink": "/js中this指向问题及call，apply，bind的区别"
        },
        "nextItem": {
          "title": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
          "permalink": "/开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用"
        }
      },
      "content": "<!-- truncate -->\n\n# react生命周期总结（旧、新生命周期及Hook）\n\n## 1 理解生命周期\n\n什么是react生命周期呢？当我们使用各种框架开发程序时，当这个框架启动、程序刚运行时、各个页面之间的交互、数据渲染到页面上面、程序运行结束，应当会有个闭环的操作，而在这个环的起点和终点之间的各个节点，框架给给定一些特定函数供我们自行调用，方便我们执行一些操作，这便是生命周期。react也是如此。\n\n\n## 2 react有哪些生命周期函数与作用\n\n### 2.1 react 17版本之前\n\n\n\n![img](https://cdn.nlark.com/yuque/0/2022/png/22565604/1656945408594-7187c2e7-10b6-42f4-813e-098d77d8b80b.png)\n\n主要分为三个阶段 **初始化阶段**、**更新阶段**、**卸载组件**。\n\n- **初始化阶段:** 也称为组件挂载时的阶段，这个阶段会执行我们在**初次加载组件到组件第一次渲染在界面上面期间**的一系列钩子函数。\n\n执行的流程为：constructor->componentWillMount->render->componentDidMount\n\n \t1. `constructor` 这是一个构造器，这里面可以接收一个父组件传来的props然后初始化state值。\t\t\n\n```\nconstructor(props) {\n  super(props)\n  this.state = {\n  a: 0\n  }\n  console.log('constructor执行了')\n}\n```\n\n \t2. `componentWillMount` 组件将要挂载，这个是在执行render之前会执行这个函数，也就说会在渲染浏览器dom之前执行这个函数，个人认为这个函数没有多大实际意义，用的比较少。\n \t3. `render` **常用且重要**的钩子函数之一。在这里面我们会写一些html标签及自定义的函数，render执行完后便会将这些语句对应渲染到浏览器上面，用户就可以看到我们写的东西了。\n \t4. `componentDidMount` 常用的钩子，组件挂载完毕执行，也就在render执行完之后之后，因为render执行了，浏览器的dom树已经有了，所以我们便可以在这里操作dom和ref（react的一个特性，代替dom操作，因为react不提倡直接操作dom嘛）。**通常在这个钩子函数里面我们请求一些后端接口数据，来初次渲染我们页面**。\n\n- **更新阶段：**  什么时候会执行更新阶段这一系列的钩子函数呢，那自然是我们在更新了state值的时候或者是接收到父组件props值的时候，就是`this.setState({})`这个。\n\n  这个阶段常规流程是：componentWillReceiveProps->shouldComponentUpdate->componentWillUpdate->render->componentDidUpdate\n\n  1.  `componentWillReceiveProps` 当子组件收到父组件传过来的props，会执行这个函数。\n\n2. `shouldComponentUpdate` 当更新state值的时候会执行这个函数，比如`this.setState({})`。\n3. `componentWillUpdate` 执行render前的一个钩子函数，里面会有两个参数`componentWillUpdate(nextProps, nextState)`，这是将要渲染的props和state的值，在react17中将要弃用这个钩子，执行 `this.forceUpdate()` 可以直接从这个钩子函数节点开始执行。\n4. `render` 和初始化时候执行的那个render一样，只是这里是更新值的，所以dom节点会重新更新一下。\n5. `componentDidUpdate `组件更新完毕执行的钩子函数。\n\n- **卸载组件：**当组件卸载时执行的钩子函数，这里只有一个，那就是`componentWillUnmount`，一般我们在这个函数里面关闭一些定时器或其他收尾的操作。\n\n### 2.2 react 17版本之后（包括）\n\n![img](https://cdn.nlark.com/yuque/0/2022/png/22565604/1656977515120-9ce187b3-8f13-4da3-aacf-454bf203350d.png)\n\n在新的生命周期中，react弃用了`componentWillMount`、`componentWillReceiveProps`、`componentWillUpdate`这三个钩子，取而代之的是`getDerivedStateFromProps`,其实就是把那三个钩子的含义融入到了这一个钩子中，写法如下：\n\n```\nstatic getDerivedStateFromProps(props, state) {\n    console.log('getDerivedStateFromProps---props, state:', props, state)\n    // 如果return null 则依然以原来的规则更新state，否则会锁定更新state\n    return null\n    // return {a:11}\n }\n```\n\n另外还新增了一个钩子，`getSnapshotBeforeUpdate`，这里可获取到即将要更新的props和state\n\n```\n getSnapshotBeforeUpdate(prevProps, prevState) {\n   console.log('getSnapshotBeforeUpdate---prevProps:,prevState:', prevProps, prevState)\n   return null\n }\n```\n\n其他和原来的生命周期一致。\n\n## 3 react 函数组件中的hook 与 class组件生命周期函数的比较\n\n> Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n在Hook中，我们写的都是函数组件，也就没有了类组件这些生命周期钩子，但是取而代之的是Hook提供的一些钩子，其含义也和类组件里面的生命周期函数类似，但是更好用，写起来更方便。\n\n比如：`useState`、`useEffect`等。\n\n更多详细的可以看官方文档或其他文档及视频，这里只是提一下。"
    },
    {
      "id": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
      "metadata": {
        "permalink": "/开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
        "source": "@site/blog/2022-09-13开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用.md",
        "title": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
        "description": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用。",
        "date": "2022-09-13T00:00:00.000Z",
        "formattedDate": "2022年9月13日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "工具",
            "permalink": "/tags/工具"
          }
        ],
        "readingTime": 2.655,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
          "title": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用。",
          "tags": [
            "前端",
            "工具"
          ]
        },
        "prevItem": {
          "title": "react生命周期总结（旧、新生命周期及Hook）",
          "permalink": "/react生命周期总结（旧、新生命周期及Hook）"
        },
        "nextItem": {
          "title": "制作一个炫酷的github个人主页",
          "permalink": "/制作一个炫酷的github个人主页"
        }
      },
      "content": "<!-- truncate -->\n## 开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用\n\n最近在写 ts 相关的前端项目时，总是要给类型加限定，比如`let go:string='';`这种，还有一些接口，虽然方便理解阅读了，但是写起来很麻烦啊，我这样的懒人怎想一个一个慢慢的写？于是，开发了一个小工具，用于一键生成使用，现在分享给大家！\n\n## 线上访问地址：https://jack-zhang-coming.github.io/rap-to-ts/\n\n## 源码安装与二次开发\n\n源码 github 仓库：https://github.com/JACK-ZHANG-coming/rap-to-ts\n\n把项目拉取到本地，然后运行以下命令\n\n### `npm install`\n\n安装项目依赖\n\n### `npm start`\n\n运行项目\n\n---\n\n## 使用说明\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/255741cd16fe4e7b818b48aa7a9a42b1~tplv-k3u1fbpfcp-zoom-1.image\" />\n\n## 🤪 What is it?\n\n> 本工具是为了解决咱们前端在联调 rap 接口管理平台文档时，需要完成`xxx.d.ts`这样的文件**ts 接口**的代码抒写，要重复复制粘贴好多次接口文档里面的属性名的问题。 本工具追求的是一次性全复制，一键生成想要的代码。\n\n## 🍳 How to use?\n\n**以 情指勤督宣项目中 实时警情检测-警情处置接口文档为例：**\n\nhttp://rap2.taobao.org/organization/repository/editor?id=288614&mod=477198&itf=2078459\n\n### 1 点击导出 json 文件\n\n![image-20211203170333052](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b287b79b12df43448d3912eeaeb9ee44~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2 打开这个文件，复制所有内容\n\n> 我这里是直接把这个文件拖拽到浏览器上面，然后就自动显示了，之后我直接把文件里面的所有内容复制\n\n#### 2.1 打开文件\n\n![image-20211203171452271](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3604abb3065540a79c0eab1744cd40aa~tplv-k3u1fbpfcp-zoom-1.image)\n\n#### 2.2 复制里面所有内容\n\n> ctrl+a , ctrl+c，复制所有内容\n\n![image-20211203171507234](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b1b708332147919b52b1bca135f841~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 3 将复制的 json 内容放入 本工具 的 【转换前 rap 导出的 json 内容:】这一栏：\n\n![image-20211203172403979](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a16dcda2364fd99a9b18834e09a27a~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 4 根据所需，导出对应的 ts 格式\n\n![image-20211203172824281](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62552b068a824bb4952574c9d75ce5ba~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 5 直接将导出的内容全部复制到开发的代码中即可使用\n\n![image-20211203173010651](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e513dca3a0ab4b008422337c02a092d6~tplv-k3u1fbpfcp-zoom-1.image)\n\n## Other\n\n本工具目前仅支持 String、Number、Boolean 基础类型的 ts 格式直接转换，如果是 Array、Object 类型转换的则为 any 类型，可根据自己所需进一步更改，欢迎 Issuse 与 Pull requests 。"
    },
    {
      "id": "制作一个炫酷的github个人主页",
      "metadata": {
        "permalink": "/制作一个炫酷的github个人主页",
        "source": "@site/blog/2022-08-10制作一个炫酷的github个人主页.md",
        "title": "制作一个炫酷的github个人主页",
        "description": "制作一个炫酷的github个人主页。",
        "date": "2022-08-10T00:00:00.000Z",
        "formattedDate": "2022年8月10日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "github",
            "permalink": "/tags/github"
          }
        ],
        "readingTime": 2.465,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "制作一个炫酷的github个人主页",
          "title": "制作一个炫酷的github个人主页",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "制作一个炫酷的github个人主页。",
          "tags": [
            "前端",
            "github"
          ]
        },
        "prevItem": {
          "title": "开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用",
          "permalink": "/开源一个个人写的小工具，用于rap（一个接口管理平台）转ts代码格式用"
        },
        "nextItem": {
          "title": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
          "permalink": "/MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）"
        }
      },
      "content": "<!-- truncate -->\n\n# 制作一个炫酷的github个人主页\n\n\n## 0 前言\n\n**正常情况下，我们github的主页是这样的：**\n\n![image-20211118140448512](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ba47bd34684468b1d11c431cafcf90~tplv-k3u1fbpfcp-zoom-1.image)\n\n是不是感觉有些千篇一律呢？好，那么下面我进行这样一波操作，让你的github主页变得焕然一新！\n\n***\n\n## 1 新建一个与自己github名同名的仓库，步骤如下：\n\n### 1.1 步骤1.1\n\n![image-20211118100237506](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4472aba0abd49fea830cd44971630e2~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 1.2 步骤1.2\n\n![image-20211118101901035](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a785e806ce47d58bcad2caa9d90349~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 2 编辑 readme.md文件\n\n### 2.1 步骤2.1\n\n![image-20211118102014198](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/208fb0ec940949ba9870a525060ddadf~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.2 步骤2.2\n\n![image-20211118102050732](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b550559527fb49789fa6fa724e5902a9~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.3 将我们事先准备好的模板复制粘贴进来\n\n![image-20211118105020090](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000e5770b4fc4b27b28231ecd39a1b08~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.4 点击完成\n\n![image-20211118105116240](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc80265a52bf420fa7500922d0dcffa9~tplv-k3u1fbpfcp-zoom-1.image)\n\n**此刻就已经大功告成啦！**\n\n![image-20211118105358998](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f425203951c747988cfd691e52c578a9~tplv-k3u1fbpfcp-zoom-1.image)\n\n**赶快制作一个炫酷的github主页吧！！~**\n\n***\n\n另外附上自己的github仓库以及参考的仓库\n\n本人github仓库：\n\n> <https://github.com/JACK-ZHANG-coming/JACK-ZHANG-coming>\n\n参考：\n\n> <https://github.com/anuraghazra/github-readme-stats/blob/master/docs/readme_cn.md>\n>\n> <https://github.com/NWYLZW#>\n\n***\n\n***\n\n***\n\n## 🤏**每天一个javascript小知识**\n\n`Array.prototype.concat()`\n\n> `concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n\n```\nconst array1 = ['a', 'b', 'c'];\nconst array2 = ['d', 'e', 'f'];\nconst array3 = array1.concat(array2);\n​\nconsole.log(array3);\n// expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n```\n\n以上代码输出为：\n\n![image-20211118110958290](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/895b68e8e068485b870f478df45a2197~tplv-k3u1fbpfcp-zoom-1.image)\n\n**语法**\n\n> ```\n> var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])\n> ```\n\n**参数**\n\nvalueN为可选值\n\n数组和/或值，将被合并到一个新的数组中。如果省略了所有 `valueN` 参数，则 `concat` 会返回调用此方法的现存数组的一个浅拷贝。\n\n**返回值**\n\n新的 Array 实例。\n\n**描述**\n\n`concat`方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。\n\n> 注意：数组/值在连接时保持不变。此外，对于新数组的任何操作（仅当元素不是对象引用时）都不会对原始数组产生影响，反之亦然。"
    },
    {
      "id": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
      "metadata": {
        "permalink": "/MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
        "source": "@site/blog/2022-07-10MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）.md",
        "title": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
        "description": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）。",
        "date": "2022-07-10T00:00:00.000Z",
        "formattedDate": "2022年7月10日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "运维",
            "permalink": "/tags/运维"
          }
        ],
        "readingTime": 3.765,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
          "title": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）。",
          "tags": [
            "前端",
            "运维"
          ]
        },
        "prevItem": {
          "title": "制作一个炫酷的github个人主页",
          "permalink": "/制作一个炫酷的github个人主页"
        },
        "nextItem": {
          "title": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
          "permalink": "/使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践"
        }
      },
      "content": "<!-- truncate -->\n# MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）\n\n> 背景：本人最近在用一台2021款的mac连接公司vpn，虽然已经显示连接成功，但是依然无法正常访问公司内网。经过长达1个多月的尝试，终于找到一条可以正常使用vpn的方案，现总结如下：\n>\n> 1 为苹果官方的bug，等待官方修复；\n>\n> 2 当前终极解决方案：使用一台iphone手机通过usb连接Mac，作为Mac的网卡，上网，得以正常访问公司内网。\n\n**如果大家还未升级到12.1-12.3版本的，千万不要升级，等版本稳定了再升上来。。。当然，新版mac不支持降级。。**\n\n## 0 特别感谢\n\n首先特别感谢一下 [Carlton Xu](https://blog.csdn.net/xuxingzhuang?type=blog) 大佬的协助，同时也是拜读了Xu大佬的文章才得以解决了这个问题。\n\n## 1 通常连接L2TP解决方案\n\n参考如下：\n\n-   Mac 配置L2TP 隧道连接操作步骤\n\n<https://blog.csdn.net/xuxingzhuang/article/details/122429887?spm=1001.2014.3001.5502>\n\n> 上面这篇博客里面有提到“192.168.10.0 为VPN Server端需要访问的网络地址”这句话，我们公司自己的网络地址为 192.168.8.0\n>\n> 我直接加了这5条，看起来也没毛病，之后用iphone那个终极解决方案连接电脑也是可以正常访问内外网的\n>\n> ```\n> #!/bin/sh\n> # 192.168.8.0 为VPN Server端需要访问的网络地址，如果有多个需要逐条添加；$1 为VPN拨上之后的网卡设置；\n> /sbin/route add 192.168.100.0 -interface $1 \n> /sbin/route add 192.168.124.0 -interface $1\n> /sbin/route add 192.168.8.0 -interface $1\n> /sbin/route add 192.168.8.1 -interface $1\n> /sbin/route add 192.168.8.155 -interface $1 \n> ```\n\n-   MacOS 软件版本更新Monterey12.1版之后L2TP无法正常访问内网服务解决方案\n\n<https://blog.csdn.net/xuxingzhuang/article/details/123846050?spm=1001.2014.3001.5502>\n\n-   更新Monterey后，l2tp VPN连接异常（官方论坛）\n\n<https://discussionschinese.apple.com/thread/253310862?page=3>\n\n<https://discussionschinese.apple.com/thread/253307367?page=2>\n\n## 2 当前针对12.1-12.3版本的终极解决方案\n\n> 好了，在经过各种方法无果后，我们来试一下这个方案。\n>\n> 用usb连苹果手机上网，首先我们需要一个iphone和一个usb线将手机与mac连接。\n\n### 2.1 关闭mac wifi，打开iphone的热点，用usb线与mac连接。\n\n这个时候在Mac 的“系统偏好设置”->“网络”里面就会自动检测到这个网，然后我们连接它。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37d987302c354eea84012fec12c32c33~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.2 连接vpn，正常访问公司内网\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0457499f75ec4a84b6401c898cf87ead~tplv-k3u1fbpfcp-watermark.image?)\n\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/639ad41d6b684a36be08a61d49f7c2ef~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.3 内网的ip能访问，但域名不可以问题\n\n我之前出现了在浏览器里面使用ip地址可以访问，是用域名却不可以访问的问题，这个时候我把dns里面只放公司内部的dns，不要放其他杂七杂八的dns就好了。\n\n![image-20220331233904705](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d6850874cc64148a350ba68966f6334~tplv-k3u1fbpfcp-zoom-1.image)\n\n***\n\nok，到此，我们已经可以正常使用公司的内网了。 希望mac可以尽快修复这个问题吧，如果有小伙伴发现更方便的连接方式也可以互相讨论下哦~"
    },
    {
      "id": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
      "metadata": {
        "permalink": "/使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
        "source": "@site/blog/2022-05-21-使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践.md",
        "title": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
        "description": "git相关操作。",
        "date": "2022-05-21T00:00:00.000Z",
        "formattedDate": "2022年5月21日",
        "tags": [
          {
            "label": "git",
            "permalink": "/tags/git"
          },
          {
            "label": "vscode",
            "permalink": "/tags/vscode"
          }
        ],
        "readingTime": 14.735,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
          "title": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "git相关操作。",
          "tags": [
            "git",
            "vscode"
          ]
        },
        "prevItem": {
          "title": "MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）",
          "permalink": "/MacOS Monterey12.1-12.3版本连接L2TP无法正常访问公司内网非完美解决方案（详细）"
        },
        "nextItem": {
          "title": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
          "permalink": "/一个前端开发对于Flex布局的总结（图解，简单易懂，全）"
        }
      },
      "content": "<!-- truncate -->\n\n\n> 前言：在日常开发中，掌握基础的git命令对于项目代码多人协作与远程存储是很有必要的；而在vscode也有对应git命令的可视化操作，本文将一一结束，从最基础的命令开始。\n>\n> 我们常用的代码托管平台有github、gitlab、码云、或者自己公司搭建的代码托管平台(需连接公司内网比如gitlab、svn等)；\n\n## 0 前置\n\n首先，我们的电脑上要有安装git，并且得在vscode里面可以使用git命令，检测是否有安装成功可在vscode的终端里面直接输入\n\n`git version`。然后我们有一个现成的代码仓库，比如这个https://github.com/front-end-study-GoGoGo/vue-study-project 这个是我在github上自己建的一个仓库。\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f73fc7c24fc94fd3b35395bb9a3a83f1~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n从上图可以看到我们可以正常在vscode里面使用git原生命令，如果你的电脑不行，可自行百度如何安装git并在vscode里面使用（如果已经安装了可能需要弄个环境变量），我的是mac，所以就没有做那么多操作了。\n\n## 1 git 常用命令大全\n\nOK，上一步我们已经可以在vscode的终端里面使用git命令了，那么git命令到底包含哪些呢，下面这边文章把我们常用的git操作做了个集合（可用于参考手册查询）：\n\n[git 常用命令大全](https://www.cnblogs.com/toBeYoung/p/15344606.html)\n\n## 2 项目实战，使用git命令对代码进行管理（拉取、推送代码等全套纯命令操作）\n\n### 2.1 项目操作场景（从初中级前端开发角度出发）\n\n正常一个项目的开发流程为这样，由产品经理设计好原型，UI设计师把UI做好，然后前端就可以根据UI图来搭前端项目架子了，然后就是产品讨论会把各个页面的详细功能过一遍，如果开发过程中有不明确的地方再沟通。\n\n- 建前端代码仓库\n\n> 这个一般是由一个人来把代码仓库建好，本人是直接在gitlab或是github的官网新建一个代码仓库，可视化操作很方便。\n\n- 分配开发各自的页面，进行代码管理维护\n\n> 代码仓库有了之后，如果是一个项目上有几个前端开发工程师，那么必然需要合理代码管理方式，才能使大家的代码同步进行开发，首先我们会分配好各自负责的开发页面，然后管理代码提交目前我总共有遇到以下**3种方式**：\n\n1. 把远程代码fork到自己的仓库，然后在自己的那个仓库上面开发，开发后在把代码提交到自己的远程仓库，然后再从自己的远程仓库pull request到远程主仓库。（这种比较适合5人以上的多人开发的项目代码管理）\n2. 直接在远程仓库上面建各自的分支，然后各自在自己的分支上面开发，开发后在合并到master分支。（这种比较适合3-5人的项目代码管理）目前我所用的还是这种多一些。\n3. 还有一种就是项目仓库上面只有一个分支，那就是master，直接在master分支上面开发，在master分支上进行拉取推送代码。（这种适合1-2人）\n\n### 2.2 使用git命令对代码进行拉取、推送、提交（重点概念理解）\n\n2.2.1 克隆远程github仓库代码\n\n```\ngit clone https://github.com/front-end-study-GoGoGo/vue-study-project \n```\n\n> 后面那个链接是git仓库的地址，如果是第一次克隆这个团队的项目，需要登录自己的github或是对应平台的账号密码。\n\n2.2.2 切换git分支，在自己对应的开发分支上面开发\n\n- 查看分支命令\n\n```\ngit branch // 查看所有本地分支\ngit branch -r // 查看所有远程分支\ngit branch -a // 查看所有本地和远程分支\n```\n\n- 新建及切换分支命令\n\n```\ngit branch newBranch // 新建一个本地分支 newBranch为分支名,新分支基于当前分支创建\ngit push origin newBranch // 把新建的本地分支推送到远程，分支名称和新建的本地分支一致，远程就新建了一个分支\ngit checkout branchName // 切换本地分支\ngit fetch // 如果在远程创建了新分支，本地可以通过git fetch 来获取最新的远程分支\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31683159aeae4b9181c892b65c331af3~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n上图所示，只有一个主分支，还没有自己对应的分支，可以自己新建一个分支，然后在自己的这个分支上面进行代码开发。\n\n2.2.3  提交代码\n\n如下图可见，我们在`1.txt`文档里面敲了一行字，然后我们将这些改动提交到**远程主仓库**：\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d8116ceea784d14b62517b6caa139e0~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n**提交流程**：\n\n（1）先将代码**推送**到**自己本地仓库**，再**提交**到**自己的远程仓库** （这里也可以跳过提交的那一步骤，直接推送，新手嘛一步一步走，不容易出错）；\n\n- 推送及提交代码\n\n```\ngit add . // . 代表全部，全部添加到暂存区\ngit commit -m '描述内容' // 推送到本地仓库，并写上备注（改了啥东西）\ngit push origin branchName // branchName 远程分支名，推送到远程分支\n```\n\n![image-20220503104307532](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69220e1e12f942d2a69747715c2c8d98~tplv-k3u1fbpfcp-zoom-1.image)\n\n（2）切换到远程主仓库分支，拉取**远程主仓库**最新代码（这里为了防止别人也推送了代码到远程主仓库，我们要保持我们远程主仓库的代码是最新的）；\n\n- 切换分支及拉取代码\n\n```\ngit checkout branchName // 切换本地分支\ngit pull // 拉取该分支最新代码\n```\n\n![image-20220503110630766](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30793e3d818340d4be98a3cc72f56b3f~tplv-k3u1fbpfcp-zoom-1.image)\n\n（3）再切换回自己分支，**合并** **远程主仓库**代码到**自己的仓库** ，然后再重复一次步骤（1） （这里防止和别人的代码有冲突，如果有冲突，那么就把冲突解决完在执行步骤1）；\n\n> 切换回自己分支后注意，如果主分支没有新的代码，那么我们就不用执行合并分支代码的操作，当然执行了也没事，执行下面这些代码就是为了让我们的自己分支的代码包含主分支的最新代码的\n\n- 切换、合并分支及推送、提交代码\n\n```\ngit checkout branchName // 切换本地分支\ngit merge branchName // 合并本地branchName到当前分支\ngit add . // . 代表全部，全部添加到暂存区\ngit commit -m '描述内容' // 推送到本地仓库，并写上备注（改了啥东西）\ngit push origin branchName // branchName 远程分支名，推送到远程分支\n```\n\n![image-20220503112020992](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2a0d3a4671048eeb767613503739ec4~tplv-k3u1fbpfcp-zoom-1.image)\n\n（4）再切换到**远程主仓库**，将**自己的仓库**的代码**合并**到**远程主仓库**，**推送** **远程主仓库**的代码，然后**切换回自己的分支**，继续开发。至此，代码提交流程闭环完毕。\n\n- 切换、合并分支及推送代码到远程仓库\n\n```\ngit checkout branchName // 切换本地分支\ngit merge branchName // 合并本地branchName到当前分支\ngit add . // . 代表全部，全部添加到暂存区\ngit commit -m '描述内容' // 推送到本地仓库，并写上备注（改了啥东西）\ngit push origin branchName // branchName 远程分支名，推送到远程分支\ngit checkout branchName // 切换本地分支\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5857ddea9f71468eb921fe969bbb521c~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n### 2.3 代码撤销与回退\n\n> 日常开发中，我们难免会出现代码提交错误的情况，所以撤销与回退的掌握是很有必要的，平时不常用，但是关键时刻有大用。\n>\n> 撤销：将刚刚提交的代码从远程仓库撤销回来，可以重新再次编辑然后再提交。\n>\n> 回退：回退到之前代码提交的某一版本，然后对其进行编辑。\n\n 相关文章参考：\n\n- git回退代码指令操作 ：https://blog.csdn.net/m0_46309087/article/details/121322220\n\n2.3.1 代码撤销\n\n```\n--------撤销工作区的更改--------\ngit checkout -- filePath // 撤销工作区指定文件的更改，filePath,文件路径都可通过 git status查看\ngit checkout . // 撤销工作区所有更改\n--------撤销暂存区的更改--------\ngit reset HEAD filePath // 撤销上次add指定的文件更改\ngit reset HEAD . // 撤销上次add的全部更改\n```\n\n> 撤销工作区的更改\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/302c93bb3ca74147b8442838eccbdbf6~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n> 撤销暂存区的更改\n\n![image-20220504104722990](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79adfbee149f476faf8e904e48634bef~tplv-k3u1fbpfcp-zoom-1.image)\n2.3.2 代码回退\n\n> 代码回退包含两种情况，对应**reset**和**revert**指令；\n>\n> reset是回退代码到某一版本，某一版本以后的代码都不保存，然后回退之后再次提交其后面的版本会被覆盖掉。\n>\n> revert是只回退某一版本代码，对齐它版本代码不影响，只会撤回某一版本的代码，对应版本的日志将保留，相对于reset更为安全。对于多人协作开发任务，更推荐使用第二种方法回退代码。\n\n- reset回退方式\n\n```\ngit log  // 查看提交（commit）记录  (进入以后我们按回车可以往下翻动日志，英文状态下按q可以退出记录查看状态)\ngit reset [目标版本号]   // 目标版本号为HEAD编号，一般输前几位就可\ngit add .\ngit commit -m ''\ngit push origin branchName\n```\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c08b15534846ed8fd4c6b71a68a132~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eaf9007a85c441f9cbf7b528bc7cb92~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n- revert回退方式\n\n```\ngit log  // 查看HEAD日志\ngit revert [要回退的版本号]  // 回退该版本代码并生成新的版本号 (此刻终端会变成vim编辑器，按qa!可以退出，然后我们继续编辑我们想要的)\ngit add .  // 提交代码到暂存区\ngit commit -m “”  // 提交代码到本地仓库\ngit push origin branchName // 上传到远程分支\n```\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9550371f58a43b39557e756e3c50d2a~tplv-k3u1fbpfcp-zoom-1.image)\n\n![image-20220504222925464](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aa8bfded906428398b97ac5c9bf845f~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 3 结合vscode可视化git操作对代码进行管理\n\n> 这一小节主要介绍使用vscode自带的git操作功能对托管的代码进行操作，主要对代码分支切换、拉取、合并、推送、提交操作（也就是日常中常用的）。依然以上面的的代码仓库为例：\n\n3.0 切换分支\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/262c6cc2cc1f4e40b697f6d0ec412a21~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 3 结合vscode可视化git操作对代码进行管理\n\n> 这一小节主要介绍使用vscode自带的git操作功能对托管的代码进行操作，主要对代码分支切换、拉取、合并、推送、提交操作（也就是日常中常用的）。依然以上面的的代码仓库为例：\n\n3.0 切换分支\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b9353322aa8416a8a8f13493a16b703~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n3.1 拉取代码\n\n> 这里我们在主分支上，拉取主分支的代码\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed9b8d7a90f4456ba1c48b268b91c64d~tplv-k3u1fbpfcp-zoom-1.image)\n\n3.2 合并代码\n\n> 此刻我们切换到自己的分支，然后将主分支的代码合并到自己的分支，保持自己的分支也是最新的代码\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ece4e1a43f1042b2b7f657d66acfa67a~tplv-k3u1fbpfcp-zoom-1.image)\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb9747ea6c24f948e94e679096dd4ac~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n> 这个时候合并遇到了代码不一致，那么我们就解决冲突。\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da2561a0a86e40cea1d9464b5fccc33c~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n3.3 推送代码\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c728abb4f3e45a9823141f40d7a4e8d~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n3.4 提交代码\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1e14daf1974d9c9e85e1fbd00b7f9f~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n## 4 git可视化软件分享\n\n### 4.1 SourceTree\n\n### 4.2 githubDesktop（推荐）\n\n---\n\nOk，感谢阅读，难免存在不足之处，欢迎讨论更正优化~"
    },
    {
      "id": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
      "metadata": {
        "permalink": "/一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
        "source": "@site/blog/2021-11-12-一个前端开发对于Flex布局的总结（图解，简单易懂，全）.md",
        "title": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
        "description": "自适应布局的前缀基础。",
        "date": "2021-11-12T00:00:00.000Z",
        "formattedDate": "2021年11月12日",
        "tags": [
          {
            "label": "css",
            "permalink": "/tags/css"
          },
          {
            "label": "FlexBox",
            "permalink": "/tags/flex-box"
          }
        ],
        "readingTime": 10.49,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
          "title": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "自适应布局的前缀基础。",
          "tags": [
            "css",
            "FlexBox"
          ]
        },
        "prevItem": {
          "title": "使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践",
          "permalink": "/使用git命令与vscode从零开始对远程代码仓库进行拉取、提交、合并、推送分支等操作在项目中的实践"
        },
        "nextItem": {
          "title": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
          "permalink": "/一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念"
        }
      },
      "content": "<!-- truncate -->\n\n## 0 前言\nFlex布局是当下前端页面比较流行的布局之一，使垂直居中、水平居中变得尤为便捷。在日常开发中，经常可以用到，但是每次开发都要百度看一下它的一些属性细节，今天特地再进行一次系统的总结，这样以后自己就不用百度啦~~ 好的，下面开始~~~\n\n## 1 flex布局基本概念\n\n我们要了解两个基本概念，分别为**容器属性**和**项目属性**。下面直接来看代码和图吧，用实战来举例子：\n\n```\n <div class=\"flex-container\">\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n    <div>4</div>\n    <div>5</div>\n    <div>6</div>\n    <div>7</div>\n    <div>8</div>\n    <div>9</div>\n    <div>10</div>\n    <div>11</div>\n    <div>12</div>\n    <div>13</div>\n </div> \n```\n\n![image-20211111211523293](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/881c70f2f3c94b108ca7505d01f4c611~tplv-k3u1fbpfcp-zoom-1.image)\n\n我们可以看到最外层的那个div（就是那个有'flex-container'类样式的div）就是**容器**，而紧接着最外面的div里面的13个div就是**项目**啦~~，当我们分别在容器上与单独的项目上写flex属性，就被称之为**容器属性**与**项目属性**。这里需要注意的是，容器属性只对它第一层的div（项目）有作用，如果它下面的div再嵌套一层div，那是作用不到那个div的，那个div就属于普通文本流。\n\n```\n<div class=\"flex-container\">\n    <div>1<div>容器属性对里面这个div没有作用</div></div>\n</div>\n```\n\n## 2 容器属性\n\n好，重头戏来了。这里可以作为参考手册，我敢保证，我打开过100次以上的flex布局知识的网页，都是看这一部分的。\n\n**容器属性**，它的作用是用于定义容器里面的项目如何布局。话不多说，来看看它常用的几个属性，如下：\n\n### 2.1 **flex-direction属性**（排列方向）\n\n取值：`row(默认)` | `row-reverse` | `column` | `column-reverse`\n\n用于控制项目排列方向与顺序。\n\n`row`：默认值。横向排列，项目排列顺序为正序1-2-3；\n\n`row-reverse`：同为横向排列，但项目顺序为倒序3-2-1；\n\n`column` ：与row相反，为纵向排列，项目顺序为正序1-2-3；\n\n`column-reverse`：同为纵向排列，项目顺序为倒序3-2-1；\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1200b8dfa5a146328b1fe3a5aaec3739~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.2 **flex-wrap属性**（换行）\n\n取值：`nowrap(默认)` | `wrap` | `wrap-reverse`\n\n用于控制项目是否换行。\n\n`nowrap(默认)` ：表示不换行。\n\n![image-20211111220928435](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508c9c12a7c84afda1c991b24efca373~tplv-k3u1fbpfcp-zoom-1.image)\n\n`wrap` ：自动换行，当排列时项目超出容器的宽度就自动换行。\n\n![image-20211111220839920](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9030f5664fc346288a2d0909252931f2~tplv-k3u1fbpfcp-zoom-1.image)\n\n`wrap-reverse`：同样表示换行，需要注意的是第一排会紧贴容器底部，而不是我们想象的项目13紧贴容器顶部，效果与wrap相反。\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5f66d2e34e4877b9a262f0941b7d30~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.3 **flex-flow属性**（排列方向&换行简写）\n\nflex-flow属性是flex-deriction与flex-wrap属性的简写集合，默认属性为row nowrap，即横向排列，且不换行，如果需要控制项目排列与换行。\n\n### 2.4 **justify-content属性**（横轴对齐方式）\n取值：flex-start(默认) | flex-end | center | space-between | space-around | space-evenly;\n\n用于控制项目在横轴的对齐方式。\n\n`默认flex-start`为左对齐，center 为居中，对应的flex-end为右对齐。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ea44ae5d444d14b20b805d59951f99~tplv-k3u1fbpfcp-watermark.image?)\n![image-20211111224828617](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/545df9f3dd5045e18c9c2e3b12c01485~tplv-k3u1fbpfcp-zoom-1.image)  ![image-20211111224912049](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a784a0f5b2c467098ad2c61d7ec0fe4~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n`space-between`为左右两端对齐，即左右两侧项目都紧贴容器，且项目之间间距相等。\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd961c13f1b48a99ab263cef6ba07a8~tplv-k3u1fbpfcp-watermark.image?)\n\n`space-around`为项目之间间距为左右两侧项目到容器间距的2倍，比较特别的布局，日常使用不太多。\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84634ca90ddf4d9291d21bf8932b3bbf~tplv-k3u1fbpfcp-watermark.image?)\n\nspace-evenly为项目之间间距与项目与容器间距相等，相当于除去项目宽度，平均分配了剩余宽度作为项目左右margin。\n\n![image-20211111231710252](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10939490856949b0acef44630652dceb~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 2.5 **align-items属性**（纵轴对齐方式）\n\n取值：flex-start | flex-end | center | baseline | stretch(默认)\n\n用于控制项目在纵轴排列方式，最常用的就是垂直居中啦。\n\n`默认stretch`：如果项目没设置高度，或高度为auto，则占满整个容器；\n\n![image-20211111231121689](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/724319fde5f44f58b3f0ed5238f7ca60~tplv-k3u1fbpfcp-zoom-1.image)\n\n`flex-start`：纵轴紧贴容器顶部；\n\n![image-20211111231147517](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae60f600a77455caf3b6dc8a62759ee~tplv-k3u1fbpfcp-zoom-1.image)\n\n`flex-end`：与flex-start相对，纵轴紧贴容器底部；\n\n![image-20211111231240279](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ff089e5d354913801e5f9669bac811~tplv-k3u1fbpfcp-zoom-1.image)\n\n`center`：最常使用，在纵轴中心位置排列，也就是居中对齐；\n\n![image-20211111231020908](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97e1fccfc0e4b8da59e8df75fdc65ed~tplv-k3u1fbpfcp-zoom-1.image)\n\n`baseline`：比较特殊，它让项目以第一行文字的基线为参照进行排列；\n\n![image-20211111231501500](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83ecc5c544a4d62a0ff34c7d3de4370~tplv-k3u1fbpfcp-zoom-1.image)\n\n> 注意，常理来说justify-content与align-items默认分别处理项目**横轴，纵轴的对齐方式**，但如果我们修改了flex-direction为column，它们处理的轴向会交换，也就是justify-content处理纵轴，align-items处理横轴。\n### 2.6 **align-content**（多行项目对齐方式）\n\n取值：flex-start | flex-end | center | space-between | space-around | space-evenly | stretch(默认);\n\n用于控制多行项目时的对齐方式，如果项目只有一行则不会起作用。\n\n`stretch(默认)`：即在项目没设置高度，或高度为auto情况下让项目填满整个容器，与align-items类似。注意，如下演示的13个项目我均没有设置高度。\n\n![image-20211111232033499](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/177e4b3359784cd8bdfde0794bffdcf5~tplv-k3u1fbpfcp-zoom-1.image)\n\n`flex-start`、`flex-end`、`center`：与align-items属性表现一致，对于纵轴的上中下对齐咯。\n\n![image-20211111232241017](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bba78258726a4279bf68d72319eac776~tplv-k3u1fbpfcp-zoom-1.image)\n\n![image-20211111232308731](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/690cd9af372242c9a2d98b026de66e58~tplv-k3u1fbpfcp-zoom-1.image)\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac1055b36dd243b4a280d901575cf339~tplv-k3u1fbpfcp-watermark.image?)\n\n`space-between`：上下两侧项目紧贴容器。\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7f5abfc6ba342c4ad14cc9ef6f71a8d~tplv-k3u1fbpfcp-watermark.image?)\n\n`space-around`：与justify-content保持一致，即项目之间间距为上下两端项目与容器间距两倍。\n\n![image-20211111232915423](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831f48a85f854288a7d43799ffae5f96~tplv-k3u1fbpfcp-zoom-1.image)\n\n`space-evenly`：项目之间间距与项目到容器之间间距相等。\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d028cc9ec094d1a9f5f0ffe4f58bf6b~tplv-k3u1fbpfcp-watermark.image?)\n\n## 3 项目属性\n\n写在每个项目上面的单独属性，只对单独的项目自身起作用。容器属性写在容器上，项目属性写在项目上，就好比容器属性给ul，项目属性给li。\n\n### 3.1 order\n\n取值：`默认0`，用于决定项目排列顺序，数值越小，项目排列越靠前。\n\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75212bf2bd3460d9f8ece1f34b6d08c~tplv-k3u1fbpfcp-watermark.image?)\n\n### 3.2 flex-grow\n\n取值：`默认0`，用于决定项目在容器里有剩余空间的情况下是否放大，默认0表示不放大；注意，即便设置了固定宽度，但是设置了flex-grow也会放大。\n\n-   假设默认四个项目中前三个项目都是0，最后一个是1，最后的项目会沾满剩余所有空间。\n\n![image-20211112215054862](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/861045c917bc43a188ec567238facd5d~tplv-k3u1fbpfcp-zoom-1.image)\n\n-   假设默认四个项目中前两个项目都是0，最后两个是1，那么最后两个就会平分剩余的空间。\n\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00dbad184ae2461b8f36c6b9e565287d~tplv-k3u1fbpfcp-watermark.image?)\n\n-   假设默认四个项目中前两个项目都是0，最后两个是一个是1，一个是1.5，那么最后连个平分剩余的空间是分别为1/2.5和1.5/2.5。\n\n![image-20211112215517416](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/291e0816699f42de8874d37d3ab1abcf~tplv-k3u1fbpfcp-zoom-1.image)\n\n### 3.3 **flex-shrink**\n\n取值：`默认1`，用于决定项目在空间不足时是否缩小，默认项目都是1，即**空间不足时大家一起等比缩小**；注意，即便设置了固定宽度，也会缩小。\n\n但如果**某个项目flex-shrink设置为0**，**那这个项目即使空间不够，自身也不缩小**。\n\n\n![ac0q3-lf25v.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d196053dbb4944b4bf0bffbc07b142b8~tplv-k3u1fbpfcp-watermark.image?)\n\n上图中第3个项目flex-shrink为0，所以自身不会缩小。\n\n### 3.4 flex-basis\n\n取值：`默认auto`，用于设置项目宽度，默认auto时，项目会保持默认宽度，或者以width为自身的宽度，**但如果设置了flex-basis，权重会width属性高，因此会覆盖width属性。**\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ffc66bbff5f49b9a64d9ca081ba5bf0~tplv-k3u1fbpfcp-watermark.image?)\n\n### 3.5 flex\n\n取值：默认0 1 auto，flex属性是flex-grow，flex-shrink与flex-basis三个属性的简写，用于定义项目放大，缩小与定义宽度。\n\n该属性有两个快捷键值，分别是`flex:auto`(1 1 auto)等分放大缩小，与`flex:none`(0 0 auto)不放大不缩小。\n\n### 3.6 align-self\n\n取值：`auto(默认)` | flex-start | flex-end | center | baseline | stretch，表示继承父容器的align-items属性。如果没父元素，则默认stretch。\n\n用于让个别项目拥有与其它项目不同的对齐方式，各值的表现与父容器的align-items属性完全一致。\n\n![image-20211112221407850](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d3b700ca2c4dcd844676337de6856c~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 4 源码\n\n```\n<!DOCTYPE html>\n<html>\n​\n<head>\n  <meta charset=\"UTF-8\">\n  <title>flex布局</title>\n  <style>\n    .flex-container {\n      display: flex;\n      flex-direction: row;\n      /*横向排列，正序，默认值*/\n      flex-wrap: wrap;\n      /*换行*/\n      max-width: 600px;\n      height: 200px;\n      margin: auto;\n      background-color: rgba(156, 240, 108, 0.301);\n    }\n​\n    /* 选择父元素样式是 .flex-container 的所有 <div> 元素 */\n    .flex-container>div {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      width: 50px;\n      height: 50px;\n      /* margin: 10px; */\n      font-size: 22px;\n    }\n​\n    .flex-container>div:nth-of-type(n) {\n      background-color: rgba(119, 232, 240, 0.788);\n    }\n​\n    .flex-container>div:nth-of-type(2n) {\n      background-color: rgb(230, 178, 81);\n    }\n​\n    .flex-container>div:nth-of-type(3n) {\n      background-color: rgba(118, 105, 233, 0.774);\n    }\n​\n    .flex-container>div:nth-of-type(4n) {\n      background-color: rgb(214, 123, 199);\n    }\n  </style>\n</head>\n​\n<body>\n  <div class=\"flex-container\">\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n    <div>4</div>\n    <div>5</div>\n    <div>6</div>\n    <div>7</div>\n    <div>8</div>\n    <div>9</div>\n    <div>10</div>\n    <div>11</div>\n    <div>12</div>\n    <div>13</div>\n  </div>\n</body>\n​\n</html>\n```\n\n## 5 源码仓库地址\n\n[template-html-css-js/02flex布局.html at main · front-end-study-GoGoGo/template-html-css-js (github.com)](https://github.com/front-end-study-GoGoGo/template-html-css-js/blob/main/06css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E4%BE%8B%E5%AD%90/02flex%E5%B8%83%E5%B1%80.html)"
    },
    {
      "id": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
      "metadata": {
        "permalink": "/一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
        "source": "@site/blog/2021-08-06-一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念 copy.md",
        "title": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
        "description": "自适应布局的前缀基础。",
        "date": "2021-08-06T00:00:00.000Z",
        "formattedDate": "2021年8月6日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "css",
            "permalink": "/tags/css"
          }
        ],
        "readingTime": 2.735,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
          "title": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "自适应布局的前缀基础。",
          "tags": [
            "前端",
            "css"
          ]
        },
        "prevItem": {
          "title": "一个前端开发对于Flex布局的总结（图解，简单易懂，全）",
          "permalink": "/一个前端开发对于Flex布局的总结（图解，简单易懂，全）"
        },
        "nextItem": {
          "title": "react子父组件互相通信传值",
          "permalink": "/react子父组件互相通信传值"
        }
      },
      "content": "<!-- truncate -->\n\n**写在前面：**\n\n> - 本文作为本人学习总结之用，同时分享给大家~\n>\n> - 个人前端博客网站：[https://zhangqiang.hk.cn](https://zhangqiang.hk.cn)\n>\n> - 欢迎加入博主的前端学习qq交流群：：[706947563](https://link.juejin.cn/?target=https%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Fk%3DEbeK9mdG0e6P2pZdonIoILPqcGNsnR1x%26jump_from%3Dwebapi)，**专注前端开发，共同学习进步**！\n\n------\n\n**本章你将能学到：**\n\n- 结合css、div布局对屏幕尺寸、分辨率、缩放有更深一层的理解。\n\n------\n\n这几个小知识点，也许我们在日常中，经常有所耳闻，但是具体什么意思呢，总是容易混淆，经过我多次亲身经历开发，特地总结如下（不要小瞧这几个概念哦，这可跟我们css布局开发息息相关）：\n\n- **屏幕尺寸**，也就是通常我们生活中所说的屏幕大小，23英寸啊、27英寸啊这些，都是我们肉眼可见的大小，也就是指**屏幕的对角线尺寸**，以英寸单位(1英寸=2.54cm)。\n- **分辨率**，通常我们的电脑分辨率为1920*1080等，也就是说显示屏上会显示多少个像素点，像素点越多，屏幕自然也就越清晰。![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7c38d1b884c4d88a6b02405f11fba6a~tplv-k3u1fbpfcp-watermark.image)\n\n对于分辨率，常用的属于还有下面这些：\n\n> **720P**的分辨率为1280x720像素\n>\n> **1080P**的分辨率为1920*1080像素\n>\n> **2k**的分辨率为2560*1440像素\n>\n> **4k**的分辨率为3840*2160像素\n>\n> **8K**的分辨率为7680×4320像素\n\n也就是正常给div一个 `width:50px; height:100px;` 其中的`px`就是像素的意思啦~\n\n- **屏幕缩放**（显示文本、应用等项目的大小）\n\n你以为你以为的就是你以为的了？咳，这里所说的缩放指的是这个：\n\n\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e5d63775e174c0da16d2e089fc7636b~tplv-k3u1fbpfcp-watermark.image)\n\n\n\n\n\n比如我们给一个div 100px的宽度，但是，我们用测量像素的工具一量，咦？！居然不是100像素，变大了？？？ 好了，就是因为这个缩放的原因，它把我们本应该100%显示的div宽度，变成了125%。实际上，他就是100px，你改成100%显示就好了。\n\n但是，我们有的电脑就是显示125%比较合适，那咋办呢？此刻就要用自适应的布局啦~ flex布局、单位可以给vw、vh这些，亦可解决。"
    },
    {
      "id": "react子父组件互相通信传值",
      "metadata": {
        "permalink": "/react子父组件互相通信传值",
        "source": "@site/blog/2021-08-02react子父组件互相通信传值.md",
        "title": "react子父组件互相通信传值",
        "description": "react子父组件互相通行，意在融会贯通。",
        "date": "2021-08-02T00:00:00.000Z",
        "formattedDate": "2021年8月2日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          }
        ],
        "readingTime": 2.6,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "react子父组件互相通信传值",
          "title": "react子父组件互相通信传值",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "react子父组件互相通行，意在融会贯通。",
          "tags": [
            "前端",
            "react"
          ]
        },
        "prevItem": {
          "title": "一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念",
          "permalink": "/一个初级前端结合css、div谈一谈屏幕尺寸、分辨率、缩放概念"
        },
        "nextItem": {
          "title": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
          "permalink": "/回炉重造，css常规布局系统整理——实战开发后复盘小结"
        }
      },
      "content": "<!-- truncate -->\n\n## react子父组件互相通信传值\n\n**写在前面：**\n\n> - 本文作为本人学习总结之用，同时分享给大家~\n>\n> - 个人前端博客网站：[https://zhangqiang.hk.cn](https://zhangqiang.hk.cn)\n>\n> - 欢迎加入博主的前端学习qq交流群：：[706947563](https://link.juejin.cn/?target=https%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Fk%3DEbeK9mdG0e6P2pZdonIoILPqcGNsnR1x%26jump_from%3Dwebapi)，**专注前端开发，共同学习进步**！\n>\n\n**本系列你将能学到：**\n\n- **父组件**传值与函数给**子组件**，在子组件可使用父组件的值与函数； （该章链接：https://juejin.cn/post/6991470029736771615）\n- **子组件**传值与函数给**父组件**，在父组件里面可使用子组件里面的值与函数；（该章链接：https://juejin.cn/post/6992215510104408101）\n- **子组件**传值与函数给**子组件**，在子组件里面可使用另一个子组件的值与函数；（该章链接：https://juejin.cn/post/6992576182357082142）\n\n------\n\n\n\n### 1 **父组件**传值与函数给**子组件**，在子组件可使用父组件的值与函数\n\n- 主要是通过react三大属性之一props来进行。[详细](https://juejin.cn/post/6991470029736771615)\n\n---\n\n### 2 子组件传值与函数给父组件，在父组件可使用子组件的值与函数\n\n- 通过react的hooks新特性，`useRef`、`useImperativeHandle`、`forwardRef` 来实现。\n\n**useRef :**\n\n`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数（`initialValue`）。返回的 ref 对象在组件的整个生命周期内持续存在。\n\n**useImperativeHandle :**\n\n`useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。`useImperativeHandle` 应当与 [`forwardRef`](https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref) 一起使用。\n\n**forwardRef ：**\n\n`React.forwardRef` 接受渲染函数作为参数。React 将使用 `props` 和 `ref` 作为参数来调用此函数。此函数应返回 React 节点。[详细](https://juejin.cn/post/6992215510104408101)\n\n---\n\n### 3 子组件传值与函数给子组件，在子组件可使用另一个子组件的值与函数\n\n- 其跟子传父的实现方法差不多，通过react的hooks新特性，将`useRef`建立的实例再通过`props`传给另一个子组件就可以啦~。[详细](  https://juejin.cn/post/6992576182357082142)\n\n------\n\n**感谢看完！**"
    },
    {
      "id": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
      "metadata": {
        "permalink": "/回炉重造，css常规布局系统整理——实战开发后复盘小结",
        "source": "@site/blog/2021-07-18-回炉重造，css常规布局系统整理——实战开发后复盘小.md",
        "title": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
        "description": "本文意在系统总结常用的css布局，以达到融会贯通之功效。",
        "date": "2021-07-18T00:00:00.000Z",
        "formattedDate": "2021年7月18日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "css",
            "permalink": "/tags/css"
          }
        ],
        "readingTime": 13.665,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
          "title": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "本文意在系统总结常用的css布局，以达到融会贯通之功效。",
          "tags": [
            "前端",
            "css"
          ]
        },
        "prevItem": {
          "title": "react子父组件互相通信传值",
          "permalink": "/react子父组件互相通信传值"
        },
        "nextItem": {
          "title": "一个前端开发从零开始配置前端开发环境纪实",
          "permalink": "/一个前端开发从零开始配置前端开发环境纪实"
        }
      },
      "content": "<!-- truncate -->\n\n# 回炉重造，css常规布局系统整理——实战开发后复盘小结\n\n> 写在前面：\n>\n> ​\t在了解css布局之前，我们先了解两个小概念，我认为这将对你有所帮助！\n>\n> ​\t块级元素：display:bloak；占据一行，下一个元素自动换行，如div等；\n>\n> ​\t行内元素：display:inline；元素没有高宽，根据元素内的内容改变大小，如span、a标签等；\n>\n> ​\t行内块：display:inline-bloak；使行内元素具有块级元素特性、使块级元素具有行内元素特性；\n\n## 1 基础css布局\n\n### **1.1 position定位**\n\n​\t`position`用于规定如div等元素的定位方法的类型。\n\n​\t其包含`static`、`relative`、`fixed`、`absolute`、`sticky`这5个定位方式，当`position`后面加上这几种定位方式之后，我们就可以用`top、right、left、bottom`对元素进行位置改变操作啦~\n\n#### 1.1.0 实例代码运行效果图\n\n![image-20210616213753355](https://i.loli.net/2021/07/18/Bz95UFDrn4VAm6Y.png)\n\n#### 1.1.1 static定位方式\n\n​\t静态定位，浏览器的默认的，写不写没啥区别，top、right、left、bottom不起作用。\n\n```css\ndiv.static {\n    position: static;\n    border: 3px solid #73AD21;\n    top: 50px;  /*演示：这句话不起作用，可删去*/\n    left: 10px; /*演示：这句话不起作用，可删去*/\n}\n```\n\n#### 1.1.2 fixed定位方式\n\n​\t固定定位，元素的位置相对于浏览器（就是你能看到的这个浏览器窗口）来说，是固定的，无论你怎么滑动窗口，它都在那儿雷打不动。 \n​\t可以与其他元素重叠。（常用于导航栏位置固定）\n\n```css\ndiv.fixed_1 {\n    position: fixed;\n    border: 3px solid #111111;\n    width: 200px;\n    height: 60px;\n    top: 300px;\n    left: 50px;\n}\n\ndiv.fixed_2 {\n    position: fixed;\n    border: 3px solid #44f895;\n    width: 200px;\n    height: 60px;\n    top: 300px;\n    left: 260px;\n}\n\ndiv.fixed_3 {\n    position: fixed;\n    border: 3px solid #7a5e5e;\n    background-color: #ebaaaa;\n    width: 200px;\n    height: 60px;\n    top: 310px;\n    left: 360px;\n}\n```\n\n#### 1.1.3 relative定位方式\n\n​\t相对定位，相对于这个元素的原来位置进行移动，原来的位置依然是存在的（通常里面会包上absolute绝对定位来用）。\n\n```css\ndiv.relative {\n    position: relative;\n    border: 3px solid #9cf0c2;\n    width: 200px;\n    height: 60px;\n}\n```\n\n#### 1.1.4 absolute定位方式\n\n​\t绝对定位，根据外面一层包着的元素来定位（relative)，左啊还是右啊，如果外面没有那就是html元素，最大的那个咯。（口诀：**子绝父相**）。\n\n```css\ndiv.absolute {\n    position: absolute;\n    background-color: #9cf0c2;\n    border: #29c9c9;\n    width: 150px;\n    height: 30px;\n    top: 20px;\n}\n```\n\n#### 1.1.5 sticky定位方式\n\n​\t粘性定位，和fixed定位有些相似，但是又有些不同，一开始可以自由滑动，当到一定位置时就会在那里不动。 先自由滑动，到一定位置就固定在那里不动。\n\n```css\ndiv.sticky {\n    position: -webkit-sticky; // 兼容Safari \n    position: sticky;\n    top: 20px; /* 到顶部20px位置不动 */\n    background-color: #29c9c9;\n    border: 2px solid #73AD21;\n}\n```\n\n#### 1.1.6 实例源码\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>position定位使用</title>\n</head>\n\n<body>\n    <div style=\"height: 2000px;\">\n        <!-- static定位 -->\n        <div class=\"static\">这个是static定位</div>\n        <!-- fixed 定位 -->\n        <div class=\"fixed_1\">fixed方块1</div>\n        <div class=\"fixed_2\">fixed方块2</div>\n        <div class=\"fixed_3\">fixed方块3</div>\n        <!-- relative定位 -->\n        <div class=\"relative\">\n            relative定位\n            <!-- absolute定位 -->\n            <div class=\"absolute\">absolute定位</div>\n        </div>\n        <!-- sticky定位 -->\n        <div class=\"sticky\">这个是sticky定位</div>\n\n    </div>\n</body>\n\n</html>\n```\n\n### 1.2 float定位\n\n#### 1.2.0 实例代码运行效果图\n\n![image-20210717112031353](https://i.loli.net/2021/07/18/KZYwsaxcID1COqM.png)\n\n#### 1.2.1 float详解\n\n​\t何为float定位？浮动的元素，脱离文档流（比如正常我们放一个div在页面里，是有一个文档流的，就是会有位置的，而变为float定位后，就会漂浮起来，原来的位置就不占用了，再放其他div，会从忽略float的位置，正常排列），空间释放（原来是占用着这个位置的，然后浮动，就漂浮起来了，这个位置就不占用了）。\n\n​\t**清除浮动：** `clear：both` 因为float定位他是浮起来的嘛，这个位置就是空的，而`clear：both`会清除浮动，默认为正常的文档流，这样后面的元素就可正常排列了（可以自己在代码中去体验）。\n\n#### 1.2.2 实例源码\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>css浮动</title>\n        <style>\n            div.main{\n                width: 1000px;\n                height: 500px;\n                background-color: aquamarine;\n            }\n            div.child{\n                width: 100px;\n                height: 100px;\n                background-color: blue;\n                float: left;\n                margin: 5px;\n            }\n\t\t\t// 清除浮动\n            div.clear{\n                height: 20px;\n                border: 2px solid black;\n                clear: both;\n            }\n        </style>\n    </head>\n\n    <body>\n        <!-- 浮动 -->\n        <div class=\"main\">\n            <div class=\"child\"></div>\n            <div class=\"child\"></div>\n            <div class=\"clear\"></div>\n        </div>\n    </body>\n</html>\n```\n\n## 2 开发中常用的布局\n\n### 2.1 flex布局 \n\n​\t一种响应式布局，何为响应式？可以随着浏览器窗口大小放大缩小，而布局元素也相应放大缩小。\n\n​\t具体分析见下面第三节的讲解。\n\n### 2.2 antd栅格布局\n\n​\t当我们使用ant design组件开发时，必然要使用的其自带的一种布局模式。\n\n​\t可参考ant design官网的介绍：[https://ant.design/components/grid-cn/](https://ant.design/components/grid-cn/)\n\n### 2.3 grid网格布局\n\n​\t如果说flex是一维布局，那么grid就是二维布局，更高级，它有行和列，flex只有行，其常用于固定元素个数布局；\n\n​\t可参考阮一峰的网络日志 - CSS Grid 网格布局教程 ：[http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)\n\n## 3 flex布局详解\n\n### 3.1 flex布局是什么\n\n> 在 Flexbox 布局模块（问世）之前，可用的布局模式有以下四种：\n>\n> - 块（Block），用于网页中的部分（节）\n> - 行内（Inline），用于文本\n> - 表，用于二维表数据\n> - 定位，用于元素的明确位置\n>\n> 弹性框布局模块，可以更轻松地设计灵活的响应式布局结构，而无需使用浮动或定位。\n\n### 3.2 教程文档小结\n\n#### 3.2.1 基本概念\n\n- **容器和属性**\n\n![image-20210717234454111](https://i.loli.net/2021/07/17/VUMXTN9GtCqw4Li.png)\n\n​\t采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n​\t容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。\n\n#### 3.2.2 容器属性\n\n**容器常用有6个属性**\n\n> - flex-direction\n> - flex-wrap\n> - flex-flow\n> - justify-content\n> - align-items\n> - align-content\n\n##### 3.2.2.1 flex-direction\n\n​\t`\tflex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.flex-container {\n    display: flex;\n    flex-direction: row(默认) | row-reverse | column | column-reverse;\n}\n```\n\n​\t用于控制项目排列方向与顺序，默认row，即横向排列，项目排列顺序为正序1-2-3-4；row-reverse同为横向排列，但项目顺序为倒序4-3-2-1。\n\n​\tcolumn 与row相反，为纵向排列，项目顺序为正序1-2-3，column-reverse同为纵向排列，项目顺序为倒序3-2-1。\n\n![image-20210718120308267](https://i.loli.net/2021/07/18/PtOFKLoMZaplHBz.png)\n\n##### 3.2.2.2 flex-wrap属性\n\n​\t用于控制项目是否换行，nowrap表示不换行。\n\n```css\n.flex-container {\n    display: flex;\n   \tflex-wrap: nowrap(默认) | wrap | wrap-reverse;\n}\n```\n\n​\t`nowrap`表示不换行，项目会一直在容器的第一行排列，无论有多少个项目，只会都挤在第一行。\n\n![image-20210718135810921](https://i.loli.net/2021/07/18/Zjc1xo36sMI5ESu.png)\n\n​\t`wrap`表示自动换行，当项目在第一行排列不完时，会自动切换到下一行排列。\n\n![image-20210718135651384](https://i.loli.net/2021/07/18/CwSkJhQIKPvNeYA.png)\n\n​\t`wrap-reverse` 也是自动换行，但不同的是，它是从底下开始排列的（之前我们都是从上面开始排的）。\n\n![image-20210718140037635](https://i.loli.net/2021/07/18/9gpuCVS7BXEazik.png)\n\n##### 3.2.2.3 flex-flow属性\n\n​\t`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`（横向排列，不换行）。\n\n```css\n.flex-container {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n##### 3.2.2.4 justify-content属性\n\n​\t**哟，常用，好使。**`justify-content`属性定义了项目在主轴上的对齐方式（我们想要使项目在容器中居中时，经常用得到）。\n\n```css\n.flex-container {\n  justify-content: flex-start(默认) | flex-end | center | space-between | space-around;\n}\n```\n\n![image-20210718142114313](https://i.loli.net/2021/07/18/mXy8nMTFzHk45gp.png)\n\n> 这里的的主轴是将横轴看做为主轴。常取值分别代表的意思如下：\n>\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n##### 3.2.2.5 align-items属性\n\n**哟，这个也常用，好使**！`align-items`属性定义项目在交叉轴上如何对齐。\n\n```css\n.flex-container {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![image-20210718142628046](https://i.loli.net/2021/07/18/hmOjQCrxzEHiaBD.png)\n\n> 这里的的交叉轴是将纵轴看做为交叉轴。常取值分别代表的意思如下：\n>\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n##### 3.2.2.6 align-content属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n![image-20210718142936834](https://i.loli.net/2021/07/18/XiVnew5CumD7ytF.png)\n\n> 常取值分别代表的意思如下：\n>\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n#### 3.2.3 项目属性\n\n​\t前面我们介绍的是写在容器上的属性，写完之后会作用于容器里面的项目排列布局样式。而**项目属性**是写在项目上的。换一种说法就是项目属性相当于我们写的`ul`里面的`li`，给`li`写属性。\n\n​\t因为这里我不常用到，所以就简单记之，详情可参考本文末尾的参考文章。\n\n> 项目可写属性如下：\n>\n> - `order `  定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n> - `flex-grow `  规定某个 flex 项目相对于其余 flex 项目将增长多少。\n> - `flex-shrink `  规定某个 flex 项目相对于其余 flex 项目将收缩多少。\n> - `flex-basis`  规定 flex 项目的初始长度。\n> - `flex`  是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。\n> - `align-self ` 规定弹性容器内所选项目的对齐方式。将覆盖容器的 align-items 属性所设置的默认对齐方式。\n\n\n\n### 3.3 flex布局应用\n\n#### 3.3.0 实例代码运行效果图\n\n![image-20210718120418455](https://i.loli.net/2021/07/18/UlMfBIwbyo8A6tr.png)\n\n#### 3.3.1 实例HTML源码\n\n``` html\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset=\"UTF-8\">\n  <title>flex布局</title>\n  <style>\n    .flex-container {\n      display: flex;\n      flex-direction: row;\n      flex-wrap: wrap;\n      background-color: DodgerBlue;\n    }\n\n    /* 选择父元素样式是 .flex-container 的所有 <div> 元素 */\n    .flex-container>div {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      background-color: #f1f1f1;\n      width: 100px;\n      height: 80px;\n      margin: 10px;\n    }\n\n    .flex-container>div>div {\n      background-color: yellowgreen;\n      width: 50px;\n      height: 50px;\n      line-height: 50px;\n      text-align: center;\n      font-size: 30px;\n    }\n  </style>\n</head>\n\n<body>\n  <div class=\"flex-container\">\n    <div>\n      <div>1</div>\n    </div>\n    <div>\n      <div>2</div>\n    </div>\n    <div>\n      <div>3</div>\n    </div>\n    <div>\n      <div>4</div>\n    </div>\n  </div>\n</body>\n\n</html>\n```\n\n### 4 最后\n\n#### 4.1 参考\n\n> w3school Flexbox 布局模块 https://www.w3school.com.cn/css/css3_flexbox.asp\n>\n> 一篇文章弄懂flex布局 https://www.cnblogs.com/echolun/p/11299460.html\n>\n> Flex 布局教程：语法篇 https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n\n#### 4.2 注\n\n> ​\t本文作为本人学习总结之用，同时分享给大家，如果觉得这些内容有对你也有用的话，就请点个赞吧~ 谢谢~ \n>\n>  因为个人技术有限，如果有发现错误或存在疑问之处，欢迎指出或指点！不胜感谢！\n>\n> ​\t个人博客网站：https://zhangqiang.hk.cn\n>\n> ​\t欢迎加入博主的前端学习qq交流群：706947563，**专注前端开发，共同学习进步**！"
    },
    {
      "id": "一个前端开发从零开始配置前端开发环境纪实",
      "metadata": {
        "permalink": "/一个前端开发从零开始配置前端开发环境纪实",
        "source": "@site/blog/2021-06-15-一个前端开发从零开始配置前端开发环境纪实.md",
        "title": "一个前端开发从零开始配置前端开发环境纪实",
        "description": "请输入描述",
        "date": "2021-06-15T00:00:00.000Z",
        "formattedDate": "2021年6月15日",
        "tags": [
          {
            "label": "前端环境配置",
            "permalink": "/tags/前端环境配置"
          },
          {
            "label": "个人记录",
            "permalink": "/tags/个人记录"
          }
        ],
        "readingTime": 2.8,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "一个前端开发从零开始配置前端开发环境纪实",
          "title": "一个前端开发从零开始配置前端开发环境纪实",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "请输入描述",
          "tags": [
            "前端环境配置",
            "个人记录"
          ]
        },
        "prevItem": {
          "title": "回炉重造，css常规布局系统整理——实战开发后复盘小结",
          "permalink": "/回炉重造，css常规布局系统整理——实战开发后复盘小结"
        },
        "nextItem": {
          "title": "使用react+docusaurus快速搭建一个博客网站",
          "permalink": "/使用react+docusaurus快速搭建一个博客网站"
        }
      },
      "content": "<!-- truncate -->\n\n# 一个前端开发从零开始配置前端开发环境纪实\n\n\n> 统筹规划：代码相关都装在D盘，其他软件安装（及内置的下载路径）放E盘，尽量避免C盘。\n>\n> 视频教程：\n>\n> ​\t【前端开发纪录片1/4】一个前端开发从零开始配置前端开发环境纪实  https://www.bilibili.com/video/BV125411K74E/\n>\n> ​\t【前端开发纪录片2/4】一个前端开发从零开始配置前端开发环境纪实  https://www.bilibili.com/video/BV1J44y1B7UU/\n>\n> ​\t【前端开发纪录片3/4】一个前端开发从零开始配置前端开发环境纪实  https://www.bilibili.com/video/BV1Jq4y1L7db/\n>\n> ​\t【前端开发纪录片4/4】一个前端开发从零开始配置前端开发环境纪实  https://www.bilibili.com/video/BV1Uh411a7A1/\n\n\n\n## 1 前端开发环境\n\n1.1 谷歌浏览器（首先登录自己的账号-同步书签；插件：React Developer Tools、JSONView、谷歌上网助手）\n\n1.2 火狐浏览器\n1.3 vscode\n\n​\t快速下载途径\n\n​\thttps://zhuanlan.zhihu.com/p/112215618\n\n1.3.1 vscode各种插件（汉化、代码格式化、自动保存、、、）\n\nVScode 前端常用插件推荐 https://blog.csdn.net/qq_41895296/article/details/108105969\n\nVSCode - Beautify插件配置 https://www.cnblogs.com/hukuangjie/p/11226948.html\n\n1.4 git安装\n\n1.5 github Desktop代码托管可视化工具\n\n1.6 node.js安装\n\n## 2 计算机常用软件及办公软件\n\n2.1 QQ\n\n2.2 钉钉\n\n2.3 微信\n\n2.4 有道\n\n2.5 Typora （写markdown用的）\n\n2.6 Nodepad++\n\n2.7 腾讯会议\n\n## 3 个人习惯软件安装\n\n3.1 电脑管家\n\n3.2 净网大师 （去弹窗广告）\n\n3.3 坚果云（将本地文档实时同步云端，防丢失）\n\n3.4 FSCapture （录屏软件）\n\n3.5 shadowfly （上网的）\n\n3.6 网易云\n\n3.7 百度网盘\n\n## 4 运行一个简单的前端项目\n\n4.1 创建一个react应用\n\nhttps://zh-hans.reactjs.org/docs/create-a-new-react-app.html\n\n## 5 搭建开发环境，运行实际开发项目\n\n5.1 配置vpn（前后端分离，用于请求服务器，获取后端的数据）\n\n5.2 将gitLab关联到github desktop（方便自由拉取推送线上仓库代码，合作开发方便）\n\n5.3 运行项目\n\n\n\n>\n>\t注：\n>\t\t\n>\t如果觉得这些内容有对你有用的话，就请点个赞吧~ 谢谢~ \n>\t\t\n>\t个人博客网站：https://zhangqiang.hk.cn\n>\t\t\n>\t欢迎加入博主的前端学习qq交流群：706947563，专注前端开发，共同学习进步！"
    },
    {
      "id": "使用react+docusaurus快速搭建一个博客网站",
      "metadata": {
        "permalink": "/使用react+docusaurus快速搭建一个博客网站",
        "source": "@site/blog/2021-05-23-快速搭建一个博客网站.md",
        "title": "使用react+docusaurus快速搭建一个博客网站",
        "description": "请输入描述",
        "date": "2021-05-23T00:00:00.000Z",
        "formattedDate": "2021年5月23日",
        "tags": [
          {
            "label": "前端",
            "permalink": "/tags/前端"
          },
          {
            "label": "React",
            "permalink": "/tags/react"
          },
          {
            "label": "博客网站",
            "permalink": "/tags/博客网站"
          }
        ],
        "readingTime": 2.415,
        "truncated": true,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "使用react+docusaurus快速搭建一个博客网站",
          "title": "使用react+docusaurus快速搭建一个博客网站",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "请输入描述",
          "tags": [
            "前端",
            "React",
            "博客网站"
          ]
        },
        "prevItem": {
          "title": "一个前端开发从零开始配置前端开发环境纪实",
          "permalink": "/一个前端开发从零开始配置前端开发环境纪实"
        },
        "nextItem": {
          "title": "js map函数的用法",
          "permalink": "/map-use"
        }
      },
      "content": "<!-- truncate -->\n\n# 快速搭建一个react个人静态博客网站，并使用vercel免费部署发布到线上\n\n**首先看下成果图：**\n\n![image-20210520214105685](https://i.loli.net/2021/05/20/3q8YEVRFz5gMUBd.png)\n\n**本篇你将您学到：**\n\n> 1 如何快速搭建一个自己的博客网站，可以在这个网站里面上传自己的博客、撰写自己的文档；\n>\n> 2 通过github、vercel 自动化部署一个前端项目到线上，**免费的。**（正常我们要买域名、服务器才能，而这里不需要，当然免费的话网就有点慢了，后面也可以自己搞一个域名服务器发布）\n\n**博客框架：**\n\n- docusaurus，快速构建一个静态网站。\n\n官方文档：https://docusaurus.io/zh-CN/\n\n**网站UI及源码参考：**\n\n- 峰华前端工程师个人博客：https://zxuqian.cn/\n\n（已联系过峰华大佬，再次感谢峰华大佬，可以让我在他的源码基础上再进行创作！）\n\n关于docusaurus的讲解，可以看峰华的视频，有讲解，本篇不再赘述。\n\n> 【JAMSTACK】使用 Docusaurus 静态网站生成器搭建个人博客：https://www.bilibili.com/video/BV1uE411x7mE\n>\n> 【JAMSTACK】部署 Docusaurus 搭建的个人博客：https://www.bilibili.com/video/BV11E411M7WL\n\n-----\n\n## 1 拉取github源码到本地，然后运行\n\n此处可以选择峰华的源码，也可以选择我的这个仓库的源码，我这个仓库源码是改完之后的，下面我将以我的仓库源码作为演示。\n\n![image-20210522104648826](https://i.loli.net/2021/05/23/4OrkDwSQsFePdMH.png)\n\n## 2 修改页眉页脚、首页\n\nb站视频10:00’往后；\n\n## 3 上传自己的博客（blog）\n\nb站视频16:40‘往后；\n\n## 4 上传自己的文档（doc）\n\nb站视频27:35秒往后；\n\n## 5 将前端网站部署发布到线上 （vercel）\n\n见b站视频；\n\n\n\n## 6 本篇博客网站搭建视频教程\n\nhttps://www.bilibili.com/video/BV19K4y197yA/\n\n\n\n\n\n> 注：本网站仅作为个人记录博客、分享学习知识所用。如果觉得这些内容有对你有用的话，就请点个赞吧~ 谢谢~"
    },
    {
      "id": "map-use",
      "metadata": {
        "permalink": "/map-use",
        "source": "@site/blog/2021-05-18-map-use.md",
        "title": "js map函数的用法",
        "description": "map()方法只能应用于数组遍历。如果想要遍历对象，可将对象转化为数组对象再其进行遍历。下面让我们来了解map的用法吧~",
        "date": "2021-05-18T00:00:00.000Z",
        "formattedDate": "2021年5月18日",
        "tags": [
          {
            "label": "js",
            "permalink": "/tags/js"
          },
          {
            "label": "前端",
            "permalink": "/tags/前端"
          }
        ],
        "readingTime": 0.795,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "map-use",
          "title": "js map函数的用法",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "map()方法只能应用于数组遍历。如果想要遍历对象，可将对象转化为数组对象再其进行遍历。下面让我们来了解map的用法吧~",
          "tags": [
            "js",
            "前端"
          ],
          "activityId": "20210518"
        },
        "prevItem": {
          "title": "使用react+docusaurus快速搭建一个博客网站",
          "permalink": "/使用react+docusaurus快速搭建一个博客网站"
        },
        "nextItem": {
          "title": "vscode+react环境部署，运行第一个react框架",
          "permalink": "/react-use"
        }
      },
      "content": "- map()方法只能应用于数组遍历。如果想要遍历对象，可将对象转化为数组对象再其进行遍历。\n\n```javascript\nvar arr = [1,2,3,4];\n//item,index,arr 分别为：当前元素的值（必填），当前元素的索引值，当前元素属于的数组对象\n//最终在不改变原有数组值的情况下将原来数组循环一遍，处理好数据，返回一个新数组。\nvar arr1 = arr.map((item,index,arr) => {\n    console.log(\"--\");\n    console.log(item);//当前元素值\n    console.log(index);//当前索引值\n    console.log(arr);//对象\n    return item*10 //新数组为10,20,30,40\n})\nconsole.log(\"arr1:\",arr1);\n```\n\n - **输出结果：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200901150019426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwNzEwMw==,size_16,color_FFFFFF,t_70#pic_center)"
    },
    {
      "id": "react-use",
      "metadata": {
        "permalink": "/react-use",
        "source": "@site/blog/2021-05-18-react-use copy.md",
        "title": "vscode+react环境部署，运行第一个react框架",
        "description": "s",
        "date": "2021-05-18T00:00:00.000Z",
        "formattedDate": "2021年5月18日",
        "tags": [
          {
            "label": "js",
            "permalink": "/tags/js"
          },
          {
            "label": "react",
            "permalink": "/tags/react"
          },
          {
            "label": "前端",
            "permalink": "/tags/前端"
          }
        ],
        "readingTime": 1.185,
        "truncated": false,
        "authors": [
          {
            "name": "潜心专研前端的Peyton",
            "title": "前端工程师 / B站UP主",
            "url": "https://github.com/JACK-ZHANG-coming",
            "imageURL": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png"
          }
        ],
        "frontMatter": {
          "slug": "react-use",
          "title": "vscode+react环境部署，运行第一个react框架",
          "author": "潜心专研前端的Peyton",
          "author_title": "前端工程师 / B站UP主",
          "author_url": "https://github.com/JACK-ZHANG-coming",
          "author_image_url": "https://dscache.tencent-cloud.cn/upload/uploader/999-12e331ae5bd4149e615b9056a1a05b198a70c0d7.png",
          "description": "s",
          "tags": [
            "js",
            "react",
            "前端"
          ],
          "activityId": "2021051801"
        },
        "prevItem": {
          "title": "js map函数的用法",
          "permalink": "/map-use"
        }
      },
      "content": "- react官网 [https://react.docschina.org/docs/getting-started.html](https://react.docschina.org/docs/getting-started.html)\n\n运行结果图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218151721408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwNzEwMw==,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n\n# 一、安装vscode\n\n\n见链接：[https://www.cnblogs.com/csji/p/13558221.html](https://www.cnblogs.com/csji/p/13558221.html)。\n\n\n\n# 二、安装node、npm、yarn（采用淘宝镜像）\n## 1.安装node\n\n\n见链接：[https://blog.csdn.net/bbj12345678/article/details/106741758](https://blog.csdn.net/bbj12345678/article/details/106741758)\n\n - 检测是否已经安装\n 键盘同时按下win+r，然后输入cmd，在黑窗口内输入：node -v\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210208184805692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwNzEwMw==,size_16,color_FFFFFF,t_70)\n\n会出现相应的版本号，说明已经安装好了。\n\n## 2.安装yarn\n\n见链接：[https://blog.csdn.net/qq_45011985/article/details/105566648](https://blog.csdn.net/qq_45011985/article/details/105566648)\n\n- 检测是否已经安装\n  键盘同时按下win+r，然后输入cmd，在黑窗口内输入：yarn -v\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218151936346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwNzEwMw==,size_16,color_FFFFFF,t_70)\n\n\n# 三、拉取React脚手架，运行第一个项目\n- 官网教程：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218153040241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIwNzEwMw==,size_16,color_FFFFFF,t_70)\n- 在vscode终端里面运行下面的语句：\n```javascript\nnpx create-react-app my-app\ncd my-app\nnpm start\n```\n\n\n- 视频教程：[https://www.bilibili.com/video/BV1CK4y1p7fb/](https://www.bilibili.com/video/BV1CK4y1p7fb/)\n\n> 等待加载完毕，我们再输入 yarn run start 运行即可。\n\n\n# 总结\n待更新。"
    }
  ]
}